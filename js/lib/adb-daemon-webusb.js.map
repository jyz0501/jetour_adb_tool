{
  "version": 3,
  "sources": ["../../node_modules/@yume-chan/async/src/promise-resolver.ts", "../../node_modules/@yume-chan/async/src/maybe-promise.ts", "../../node_modules/@yume-chan/struct/src/bipedal.ts", "../../node_modules/@yume-chan/struct/src/field/serialize.ts", "../../node_modules/@yume-chan/struct/src/field/factory.ts", "../../node_modules/@yume-chan/struct/src/buffer.ts", "../../node_modules/@yume-chan/struct/src/readable.ts", "../../node_modules/@yume-chan/struct/src/struct.ts", "../../node_modules/@yume-chan/struct/src/extend.ts", "../../node_modules/@yume-chan/no-data-view/src/int32.ts", "../../node_modules/@yume-chan/no-data-view/src/uint32.ts", "../../node_modules/@yume-chan/struct/src/number.ts", "../../node_modules/@yume-chan/stream-extra/src/stream.ts", "../../node_modules/@yume-chan/stream-extra/src/try-close.ts", "../../node_modules/@yume-chan/stream-extra/src/consumable/readable.ts", "../../node_modules/@yume-chan/stream-extra/src/consumable/wrap-byte-readable.ts", "../../node_modules/@yume-chan/stream-extra/src/consumable/wrap-writable.ts", "../../node_modules/@yume-chan/stream-extra/src/consumable/writable.ts", "../../node_modules/@yume-chan/stream-extra/src/task.ts", "../../node_modules/@yume-chan/stream-extra/src/consumable.ts", "../../node_modules/@yume-chan/stream-extra/src/maybe-consumable/index.ts", "../../node_modules/@yume-chan/stream-extra/src/maybe-consumable/utils.ts", "../../node_modules/@yume-chan/stream-extra/src/maybe-consumable/wrap-writable.ts", "../../node_modules/@yume-chan/stream-extra/src/maybe-consumable/writable.ts", "../../node_modules/@yume-chan/stream-extra/src/wrap-readable.ts", "../../node_modules/@yume-chan/stream-extra/src/duplex.ts", "../../node_modules/@yume-chan/stream-extra/src/pipe-from.ts", "../../node_modules/@yume-chan/event/src/event-emitter.ts", "../../node_modules/@yume-chan/event/src/sticky-event-emitter.ts", "../../node_modules/@yume-chan/adb/src/utils/array-buffer.ts", "../../node_modules/@yume-chan/adb/src/utils/no-op.ts", "../../node_modules/@yume-chan/adb/src/daemon/packet.ts", "../../node_modules/@yume-chan/adb/src/server/observer.ts", "../../node_modules/@yume-chan/adb-daemon-webusb/src/error.ts", "../../node_modules/@yume-chan/adb-daemon-webusb/src/utils.ts", "../../node_modules/@yume-chan/adb-daemon-webusb/src/device.ts", "../../node_modules/@yume-chan/adb-daemon-webusb/src/observer.ts", "../../node_modules/@yume-chan/adb-daemon-webusb/src/manager.ts"],
  "sourcesContent": ["export type PromiseResolverState = 'running' | 'resolved' | 'rejected';\n\nexport class PromiseResolver<T> {\n    #promise: Promise<T>;\n    public get promise(): Promise<T> { return this.#promise; }\n\n    #resolve!: (value: T | PromiseLike<T>) => void;\n    #reject!: (reason?: any) => void;\n\n    #state: PromiseResolverState = 'running';\n    public get state(): PromiseResolverState { return this.#state; }\n\n    public constructor() {\n        this.#promise = new Promise<T>((resolve, reject) => {\n            this.#resolve = resolve;\n            this.#reject = reject;\n        });\n    }\n\n    public resolve = (value: T | PromiseLike<T>): void => {\n        this.#resolve(value);\n        this.#state = 'resolved';\n    };\n\n    public reject = (reason?: any): void => {\n        this.#reject(reason);\n        this.#state = 'rejected';\n    };\n}\n", "export type MaybePromise<T> = T | Promise<T>;\n\nexport type MaybePromiseLike<T> = T | PromiseLike<T>;\n\nexport function isPromiseLike<T>(value: unknown): value is PromiseLike<T> {\n    return typeof value === \"object\" && value !== null && \"then\" in value;\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport { isPromiseLike } from \"@yume-chan/async\";\n\nfunction advance<T>(\n    iterator: Iterator<unknown, T, unknown>,\n    next: unknown,\n): MaybePromiseLike<T> {\n    while (true) {\n        const { done, value } = iterator.next(next);\n        if (done) {\n            return value;\n        }\n        if (isPromiseLike(value)) {\n            return value.then(\n                (value) => advance(iterator, { resolved: value }),\n                (error: unknown) => advance(iterator, { error }),\n            );\n        }\n        next = value;\n    }\n}\n\nexport type BipedalGenerator<This, T, A extends unknown[]> = (\n    this: This,\n    then: <U>(value: MaybePromiseLike<U>) => Iterable<unknown, U, unknown>,\n    ...args: A\n) => Generator<unknown, T, unknown>;\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function bipedal<This, T, A extends unknown[]>(\n    fn: BipedalGenerator<This, T, A>,\n    bindThis?: This,\n): { (this: This, ...args: A): MaybePromiseLike<T> } {\n    function result(this: This, ...args: A): MaybePromiseLike<T> {\n        const iterator = fn.call(\n            this,\n            function* <U>(\n                value: MaybePromiseLike<U>,\n            ): Generator<\n                PromiseLike<U>,\n                U,\n                { resolved: U } | { error: unknown }\n            > {\n                if (isPromiseLike(value)) {\n                    const result = yield value;\n                    if (\"resolved\" in result) {\n                        return result.resolved;\n                    } else {\n                        throw result.error;\n                    }\n                }\n\n                return value;\n            },\n            ...args,\n        ) as never;\n        return advance(iterator, undefined);\n    }\n\n    if (bindThis) {\n        return result.bind(bindThis);\n    } else {\n        return result;\n    }\n}\n", "import type {\n    FieldByobSerializeContext,\n    FieldDefaultSerializeContext,\n    FieldSerializer,\n} from \"./types.js\";\n\nexport type DefaultFieldSerializer<T> = (\n    source: T,\n    context: FieldDefaultSerializeContext,\n) => Uint8Array;\n\n/* Adapt default field serializer to universal field serializer */\nexport function defaultFieldSerializer<T>(\n    serializer: DefaultFieldSerializer<T>,\n): FieldSerializer<T>[\"serialize\"] {\n    return (\n        source,\n        context: FieldDefaultSerializeContext | FieldByobSerializeContext,\n    ): never => {\n        if (\"buffer\" in context) {\n            const buffer = serializer(source, context);\n            context.buffer.set(buffer, context.index);\n            return buffer.length as never;\n        } else {\n            return serializer(source, context) as never;\n        }\n    };\n}\n\nexport type ByobFieldSerializer<T> = (\n    source: T,\n    context: FieldByobSerializeContext & { index: number },\n) => void;\n\n/* Adapt byob field serializer to universal field serializer */\nexport function byobFieldSerializer<T>(\n    size: number,\n    serializer: ByobFieldSerializer<T>,\n): FieldSerializer<T>[\"serialize\"] {\n    return (\n        source,\n        context: FieldDefaultSerializeContext | FieldByobSerializeContext,\n    ): never => {\n        if (\"buffer\" in context) {\n            context.index ??= 0;\n            serializer(source, context as never);\n            return size as never;\n        } else {\n            const buffer = new Uint8Array(size);\n            serializer(source, {\n                buffer,\n                index: 0,\n                littleEndian: context.littleEndian,\n            });\n            return buffer as never;\n        }\n    };\n}\n", "import type { BipedalGenerator } from \"../bipedal.js\";\nimport { bipedal } from \"../bipedal.js\";\nimport type { AsyncExactReadable } from \"../readable.js\";\n\nimport type {\n    ByobFieldSerializer,\n    DefaultFieldSerializer,\n} from \"./serialize.js\";\nimport { byobFieldSerializer, defaultFieldSerializer } from \"./serialize.js\";\nimport type { Field, FieldDeserializeContext, FieldOptions } from \"./types.js\";\n\nexport type BipedalFieldDeserializer<T, D> = BipedalGenerator<\n    undefined,\n    T,\n    [reader: AsyncExactReadable, context: FieldDeserializeContext<D>]\n>;\n\n// eslint-disable-next-line @typescript-eslint/max-params\nfunction _field<T, OmitInit extends string, D, Raw = T>(\n    size: number,\n    type: \"default\",\n    serialize: DefaultFieldSerializer<Raw>,\n    deserialize: BipedalFieldDeserializer<T, D>,\n    options?: FieldOptions<T, OmitInit, D, Raw>,\n): Field<T, OmitInit, D, Raw>;\n// eslint-disable-next-line @typescript-eslint/max-params\nfunction _field<T, OmitInit extends string, D, Raw = T>(\n    size: number,\n    type: \"byob\",\n    serialize: ByobFieldSerializer<Raw>,\n    deserialize: BipedalFieldDeserializer<T, D>,\n    options?: FieldOptions<T, OmitInit, D, Raw>,\n): Field<T, OmitInit, D, Raw>;\n/* #__NO_SIDE_EFFECTS__ */\n// eslint-disable-next-line @typescript-eslint/max-params\nfunction _field<T, OmitInit extends string, D, Raw = T>(\n    size: number,\n    type: \"default\" | \"byob\",\n    serialize: DefaultFieldSerializer<Raw> | ByobFieldSerializer<Raw>,\n    deserialize: BipedalFieldDeserializer<T, D>,\n    options?: FieldOptions<T, OmitInit, D, Raw>,\n): Field<T, OmitInit, D, Raw> {\n    const field: Field<T, OmitInit, D, Raw> = {\n        size,\n        type: type,\n        serialize:\n            type === \"default\"\n                ? defaultFieldSerializer(\n                      serialize as DefaultFieldSerializer<Raw>,\n                  )\n                : byobFieldSerializer(\n                      size,\n                      serialize as ByobFieldSerializer<Raw>,\n                  ),\n        deserialize: bipedal(deserialize) as never,\n        omitInit: options?.omitInit,\n    };\n    if (options?.init) {\n        field.init = options.init;\n    }\n    return field;\n}\n\nexport const field = _field;\n", "import type {\n    BipedalFieldDeserializer,\n    ByobFieldSerializer,\n    Field,\n} from \"./field/index.js\";\nimport { field } from \"./field/index.js\";\n\nexport const EmptyUint8Array = new Uint8Array(0);\n\nfunction copyMaybeDifferentLength(\n    dest: Uint8Array,\n    source: Uint8Array,\n    index: number,\n    length: number,\n) {\n    if (source.length < length) {\n        dest.set(source, index);\n        // Clear trailing bytes\n        dest.fill(0, index + source.length, index + length);\n    } else if (source.length === length) {\n        dest.set(source, index);\n    } else {\n        dest.set(source.subarray(0, length), index);\n    }\n}\n\nexport interface Converter<From, To> {\n    convert: (value: From) => To;\n    back: (value: To) => From;\n}\n\nexport interface BufferLengthConverter<K, KT> extends Converter<KT, number> {\n    field: K;\n}\n\n/**\n * Create a fixed-length `Uint8Array` field.\n *\n * @param length Length of the field\n */\nexport function buffer(\n    length: number,\n): Field<Uint8Array, never, never, Uint8Array>;\n/**\n * Create a custom-typed field, backed by a fixed-length `Uint8Array`.\n *\n * @param length Length of the field\n * @param converter A value converter to convert between `Uint8Array` and the target type\n */\nexport function buffer<U>(\n    length: number,\n    converter: Converter<Uint8Array, U>,\n): Field<U, never, never, Uint8Array>;\n\n/**\n * Create a variable-length `Uint8Array` field.\n * The length is determined by another number-typed field.\n *\n * @param lengthField Name of the length field. Must be declared before this field\n */\nexport function buffer<K extends string>(\n    lengthField: K,\n): Field<Uint8Array, K, Record<K, number>, Uint8Array>;\n/**\n * Create a custom-typed field, backed by a variable-length `Uint8Array`.\n * The length is determined by another number-typed field.\n *\n * @param lengthField Name of the length field. Must be declared before this field\n * @param converter A value converter to convert between `Uint8Array` and the target type\n */\nexport function buffer<K extends string, U>(\n    lengthField: K,\n    converter: Converter<Uint8Array, U>,\n): Field<U, K, Record<K, number>, Uint8Array>;\n\n/**\n * Create a variable-length `Uint8Array` field.\n * The length is determined by converting another field to `number`.\n *\n * @param length\n * Name of the length field,\n * and a converter to convert between source type and `number`.\n * Must be declared before this field\n */\nexport function buffer<K extends string, KT>(\n    length: BufferLengthConverter<K, KT>,\n): Field<Uint8Array, K, Record<K, KT>, Uint8Array>;\n/**\n * Create a custom-typed field, backed by a variable-length `Uint8Array`.\n * The length is determined by converting another field to `number`.\n *\n * @param length\n * Name of the length field,\n * and a converter to convert between source type and `number`.\n * Must be declared before this field\n * @param converter\n * A value converter to convert between `Uint8Array` and the target type\n */\nexport function buffer<K extends string, KT, U>(\n    length: BufferLengthConverter<K, KT>,\n    converter: Converter<Uint8Array, U>,\n): Field<U, K, Record<K, KT>, Uint8Array>;\n\n/**\n * Create a length field, and a variable-length `Uint8Array` field.\n * This is a shortcut when the length field is directly before the data field.\n *\n * @param length The length field declaration\n */\nexport function buffer<LengthOmitInit extends string, LengthDependencies>(\n    length: Field<number, LengthOmitInit, LengthDependencies, number>,\n): Field<Uint8Array, LengthOmitInit, LengthDependencies, Uint8Array>;\n/**\n * Create a length field, and a custom-typed field, backed by a variable-length `Uint8Array`.\n * This is a shortcut when the length field is directly before the data field.\n *\n * @param length The length field declaration\n * @param converter A value converter to convert between `Uint8Array` and the target type\n */\nexport function buffer<LengthOmitInit extends string, LengthDependencies, U>(\n    length: Field<number, LengthOmitInit, LengthDependencies, number>,\n    converter: Converter<Uint8Array, U>,\n): Field<U, LengthOmitInit, LengthDependencies, Uint8Array>;\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function buffer(\n    lengthOrField:\n        | string\n        | number\n        | Field<number, string, unknown, number>\n        | BufferLengthConverter<string, unknown>,\n    converter?: Converter<Uint8Array, unknown>,\n): Field<unknown, string, Record<string, unknown>, Uint8Array> {\n    // Fixed length\n    if (typeof lengthOrField === \"number\") {\n        let serialize: ByobFieldSerializer<Uint8Array>;\n        let deserialize: BipedalFieldDeserializer<\n            unknown,\n            Record<string, unknown>\n        >;\n        let init: ((value: unknown) => Uint8Array) | undefined;\n\n        if (lengthOrField === 0) {\n            serialize = () => {};\n\n            if (converter) {\n                // eslint-disable-next-line require-yield\n                deserialize = function* () {\n                    return converter.convert(EmptyUint8Array);\n                };\n            } else {\n                // eslint-disable-next-line require-yield\n                deserialize = function* () {\n                    return EmptyUint8Array;\n                };\n            }\n        } else {\n            serialize = (value, { buffer, index }) =>\n                copyMaybeDifferentLength(buffer, value, index, lengthOrField);\n\n            if (converter) {\n                deserialize = function* (then, reader) {\n                    const array = reader.readExactly(lengthOrField);\n                    return converter.convert(yield* then(array));\n                };\n                init = (value) => converter.back(value);\n            } else {\n                // eslint-disable-next-line require-yield\n                deserialize = function* (_then, reader) {\n                    const array = reader.readExactly(lengthOrField);\n                    return array;\n                };\n            }\n        }\n\n        return field(lengthOrField, \"byob\", serialize, deserialize, { init });\n    }\n\n    // Declare length field\n    // Some field types are `function`s\n    if (\n        (typeof lengthOrField === \"object\" ||\n            typeof lengthOrField === \"function\") &&\n        \"serialize\" in lengthOrField\n    ) {\n        let deserialize: BipedalFieldDeserializer<\n            unknown,\n            Record<string, unknown>\n        >;\n        let init: ((value: unknown) => Uint8Array) | undefined;\n\n        if (converter) {\n            deserialize = function* (then, reader, context) {\n                const length = yield* then(\n                    lengthOrField.deserialize(reader, context),\n                );\n                const array =\n                    length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n                return converter.convert(yield* then(array));\n            };\n            init = (value) => converter.back(value);\n        } else {\n            deserialize = function* (then, reader, context) {\n                const length = yield* then(\n                    lengthOrField.deserialize(reader, context),\n                );\n                const array =\n                    length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n                return array;\n            };\n        }\n\n        return field(\n            lengthOrField.size,\n            \"default\",\n            (value, { littleEndian }) => {\n                if (lengthOrField.type === \"default\") {\n                    const lengthBuffer = lengthOrField.serialize(value.length, {\n                        littleEndian,\n                    });\n\n                    if (value.length === 0) {\n                        return lengthBuffer;\n                    }\n\n                    const result = new Uint8Array(\n                        lengthBuffer.length + value.length,\n                    );\n                    result.set(lengthBuffer, 0);\n                    result.set(value, lengthBuffer.length);\n                    return result;\n                } else {\n                    const result = new Uint8Array(\n                        lengthOrField.size + value.length,\n                    );\n                    lengthOrField.serialize(value.length, {\n                        buffer: result,\n                        index: 0,\n                        littleEndian,\n                    });\n                    result.set(value, lengthOrField.size);\n                    return result;\n                }\n            },\n            deserialize,\n            { init },\n        );\n    }\n\n    // Reference existing length field\n    if (typeof lengthOrField === \"string\") {\n        let deserialize: BipedalFieldDeserializer<\n            unknown,\n            Record<string, unknown>\n        >;\n        let init: (\n            value: unknown,\n            dependencies: Record<string, unknown>,\n        ) => Uint8Array;\n\n        if (converter) {\n            deserialize = function* (then, reader, { dependencies }) {\n                const length = dependencies[lengthOrField] as number;\n                const array =\n                    length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n                return converter.convert(yield* then(array));\n            };\n            init = (value, dependencies) => {\n                const array = converter.back(value);\n                dependencies[lengthOrField] = array.length;\n                return array;\n            };\n        } else {\n            // eslint-disable-next-line require-yield\n            deserialize = function* (_then, reader, { dependencies }) {\n                const length = dependencies[lengthOrField] as number;\n                const array =\n                    length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n                return array;\n            };\n            init = (value, dependencies) => {\n                const array = value as Uint8Array;\n                dependencies[lengthOrField] = array.length;\n                return array;\n            };\n        }\n\n        return field(0, \"default\", (source) => source, deserialize, { init });\n    }\n\n    let deserialize: BipedalFieldDeserializer<unknown, Record<string, unknown>>;\n    let init: (\n        value: unknown,\n        dependencies: Record<string, unknown>,\n    ) => Uint8Array;\n\n    // Reference existing length field + length converter\n    if (converter) {\n        deserialize = function* (then, reader, { dependencies }) {\n            const rawLength = dependencies[lengthOrField.field];\n            const length = lengthOrField.convert(rawLength);\n            const array =\n                length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n            return converter.convert(yield* then(array));\n        };\n        init = (value, dependencies) => {\n            const array = converter.back(value);\n            dependencies[lengthOrField.field] = lengthOrField.back(\n                array.length,\n            );\n            return array;\n        };\n    } else {\n        // eslint-disable-next-line require-yield\n        deserialize = function* (_then, reader, { dependencies }) {\n            const rawLength = dependencies[lengthOrField.field];\n            const length = lengthOrField.convert(rawLength);\n            const array =\n                length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n            return array;\n        };\n        init = (value, dependencies) => {\n            const array = value as Uint8Array;\n            dependencies[lengthOrField.field] = lengthOrField.back(\n                array.length,\n            );\n            return array;\n        };\n    }\n\n    return field(0, \"default\", (source) => source, deserialize, { init });\n}\n", "// TODO: allow over reading (returning a `Uint8Array`, an `offset` and a `length`) to avoid copying\n\nimport type { MaybePromiseLike } from \"@yume-chan/async\";\n\nexport class ExactReadableEndedError extends Error {\n    constructor() {\n        super(\"ExactReadable ended\");\n    }\n}\n\nexport interface ExactReadable {\n    readonly position: number;\n\n    /**\n     * Read data from the underlying data source.\n     *\n     * The stream must return exactly `length` bytes or data. If that's not possible\n     * (due to end of file or other error condition), it must throw an {@link ExactReadableEndedError}.\n     */\n    readExactly(length: number): Uint8Array;\n}\n\nexport class Uint8ArrayExactReadable implements ExactReadable {\n    #data: Uint8Array;\n    #position: number;\n\n    get position() {\n        return this.#position;\n    }\n\n    constructor(data: Uint8Array) {\n        this.#data = data;\n        this.#position = 0;\n    }\n\n    readExactly(length: number): Uint8Array {\n        if (this.#position + length > this.#data.length) {\n            throw new ExactReadableEndedError();\n        }\n\n        const result = this.#data.subarray(\n            this.#position,\n            this.#position + length,\n        );\n\n        this.#position += length;\n        return result;\n    }\n}\n\nexport interface AsyncExactReadable {\n    readonly position: number;\n\n    /**\n     * Read data from the underlying data source.\n     *\n     * The stream must return exactly `length` bytes or data. If that's not possible\n     * (due to end of file or other error condition), it must throw an {@link ExactReadableEndedError}.\n     */\n    readExactly(length: number): MaybePromiseLike<Uint8Array>;\n}\n", "import { bipedal } from \"./bipedal.js\";\nimport type {\n    Field,\n    FieldByobSerializeContext,\n    FieldDefaultSerializeContext,\n    FieldDeserializeContext,\n    FieldDeserializer,\n} from \"./field/index.js\";\nimport type { AsyncExactReadable } from \"./readable.js\";\nimport { ExactReadableEndedError } from \"./readable.js\";\nimport type {\n    StructDeserializer,\n    StructLike,\n    StructSerializeContext,\n    StructSerializer,\n} from \"./types.js\";\n\nexport type StructField =\n    | Field<unknown, string, unknown, unknown>\n    | (StructSerializer<unknown> & StructDeserializer<unknown>);\n\nexport type StructFields = Record<string, StructField>;\n\nexport type FieldsValue<T extends StructFields> = {\n    [K in keyof T]: T[K] extends FieldDeserializer<infer U, unknown>\n        ? U\n        : never;\n};\n\nexport type FieldOmitInit<T extends StructField> =\n    T extends Field<unknown, infer U, unknown, unknown>\n        ? string extends U\n            ? never\n            : U\n        : never;\n\nexport type FieldsOmitInits<T extends StructFields> = {\n    [K in keyof T]: FieldOmitInit<T[K]>;\n}[keyof T];\n\nexport type FieldsInit<T extends StructFields> = Omit<\n    FieldsValue<T>,\n    FieldsOmitInits<T>\n>;\n\nexport class StructDeserializeError extends Error {\n    constructor(message: string) {\n        super(message);\n    }\n}\n\nexport class StructNotEnoughDataError extends StructDeserializeError {\n    constructor() {\n        super(\n            \"The underlying readable was ended before the struct was fully deserialized\",\n        );\n    }\n}\n\nexport class StructEmptyError extends StructDeserializeError {\n    constructor() {\n        super(\"The underlying readable doesn't contain any more struct\");\n    }\n}\n\nexport type ExtraToIntersection<\n    Extra extends Record<PropertyKey, unknown> | undefined,\n> = Extra extends undefined ? unknown : Extra;\n\nexport interface Struct<\n    Fields extends StructFields,\n    Extra extends Record<PropertyKey, unknown> | undefined = undefined,\n    PostDeserialize = FieldsValue<Fields> & Extra,\n> extends StructSerializer<FieldsInit<Fields>>,\n        StructDeserializer<PostDeserialize> {\n    littleEndian: boolean;\n    fields: Fields;\n    extra: Extra;\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function struct<\n    Fields extends Record<\n        string,\n        | Field<unknown, string, Partial<FieldsValue<Fields>>, unknown>\n        | StructLike<unknown>\n    >,\n    Extra extends Record<PropertyKey, unknown> | undefined = undefined,\n    PostDeserialize = FieldsValue<Fields> & ExtraToIntersection<Extra>,\n>(\n    fields: Fields,\n    options: {\n        littleEndian: boolean;\n        extra?: (Extra & ThisType<FieldsValue<Fields>>) | undefined;\n        postDeserialize?:\n            | ((\n                  this: FieldsValue<Fields> & ExtraToIntersection<Extra>,\n                  value: FieldsValue<Fields> & ExtraToIntersection<Extra>,\n              ) => PostDeserialize)\n            | undefined;\n    },\n): Struct<Fields, Extra, PostDeserialize> {\n    const fieldList = Object.entries(fields);\n\n    let size = 0;\n    let byob = true;\n    for (const [, field] of fieldList) {\n        size += field.size;\n        if (byob && field.type !== \"byob\") {\n            byob = false;\n        }\n    }\n\n    const littleEndian = options.littleEndian;\n    const extra = options.extra\n        ? Object.getOwnPropertyDescriptors(options.extra)\n        : undefined;\n\n    return {\n        littleEndian,\n        fields,\n        extra: options.extra,\n\n        type: byob ? \"byob\" : \"default\",\n        size,\n        serialize(\n            source: FieldsInit<Fields>,\n            bufferOrContext?: Uint8Array | StructSerializeContext,\n        ): Uint8Array | number {\n            const temp: Record<string, unknown> = { ...source };\n\n            for (const [key, field] of fieldList) {\n                if (key in temp && \"init\" in field) {\n                    const result = field.init?.(temp[key], temp as never);\n                    temp[key] = result;\n                }\n            }\n\n            const sizes = new Array<number>(fieldList.length);\n            const buffers = new Array<Uint8Array | undefined>(fieldList.length);\n            {\n                const context: FieldDefaultSerializeContext = { littleEndian };\n                for (const [index, [key, field]] of fieldList.entries()) {\n                    if (field.type === \"byob\") {\n                        sizes[index] = field.size;\n                    } else {\n                        buffers[index] = field.serialize(temp[key], context);\n                        sizes[index] = buffers[index].length;\n                    }\n                }\n            }\n\n            const size = sizes.reduce((sum, size) => sum + size, 0);\n\n            let externalBuffer: boolean;\n            let buffer: Uint8Array;\n            let index: number;\n            if (bufferOrContext instanceof Uint8Array) {\n                if (bufferOrContext.length < size) {\n                    throw new Error(\"Buffer too small\");\n                }\n                externalBuffer = true;\n                buffer = bufferOrContext;\n                index = 0;\n            } else if (\n                typeof bufferOrContext === \"object\" &&\n                \"buffer\" in bufferOrContext\n            ) {\n                externalBuffer = true;\n                buffer = bufferOrContext.buffer;\n                index = bufferOrContext.index ?? 0;\n                if (buffer.length - index < size) {\n                    throw new Error(\"Buffer too small\");\n                }\n            } else {\n                externalBuffer = false;\n                buffer = new Uint8Array(size);\n                index = 0;\n            }\n\n            const context = {\n                buffer,\n                index,\n                littleEndian,\n            } satisfies FieldByobSerializeContext;\n            for (const [index, [key, field]] of fieldList.entries()) {\n                if (buffers[index]) {\n                    buffer.set(buffers[index], context.index);\n                } else {\n                    field.serialize(temp[key], context);\n                }\n                context.index += sizes[index]!;\n            }\n\n            if (externalBuffer) {\n                return size;\n            } else {\n                return buffer;\n            }\n        },\n        deserialize: bipedal(function* (\n            this: Struct<Fields, Extra, PostDeserialize>,\n            then,\n            reader: AsyncExactReadable,\n        ) {\n            const startPosition = reader.position;\n\n            const result = {} as Record<string, unknown>;\n            const context: FieldDeserializeContext<\n                Partial<FieldsValue<Fields>>\n            > = {\n                dependencies: result as never,\n                littleEndian: littleEndian,\n            };\n\n            try {\n                for (const [key, field] of fieldList) {\n                    result[key] = yield* then(\n                        field.deserialize(reader, context),\n                    );\n                }\n            } catch (e) {\n                if (!(e instanceof ExactReadableEndedError)) {\n                    throw e;\n                }\n\n                if (reader.position === startPosition) {\n                    throw new StructEmptyError();\n                } else {\n                    throw new StructNotEnoughDataError();\n                }\n            }\n\n            if (extra) {\n                Object.defineProperties(result, extra);\n            }\n\n            if (options.postDeserialize) {\n                return options.postDeserialize.call(\n                    result as never,\n                    result as never,\n                );\n            } else {\n                return result;\n            }\n        }),\n    } as never;\n}\n", "import type {\n    ExtraToIntersection,\n    FieldsValue,\n    Struct,\n    StructFields,\n} from \"./struct.js\";\nimport { struct } from \"./struct.js\";\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function extend<\n    Base extends Struct<\n        StructFields,\n        Record<PropertyKey, unknown> | undefined,\n        unknown\n    >,\n    Fields extends StructFields,\n    PostDeserialize = FieldsValue<Base[\"fields\"] & Fields> &\n        ExtraToIntersection<Base[\"extra\"]>,\n>(\n    base: Base,\n    fields: Fields,\n    options?: {\n        littleEndian?: boolean | undefined;\n        postDeserialize?: (\n            this: FieldsValue<Base[\"fields\"] & Fields> &\n                ExtraToIntersection<Base[\"extra\"]>,\n            value: FieldsValue<Base[\"fields\"] & Fields> &\n                ExtraToIntersection<Base[\"extra\"]>,\n        ) => PostDeserialize;\n    },\n): Struct<Base[\"fields\"] & Fields, Base[\"extra\"], PostDeserialize> {\n    return struct(Object.assign({}, base.fields, fields), {\n        littleEndian: options?.littleEndian ?? base.littleEndian,\n        extra: base.extra as never,\n        postDeserialize: options?.postDeserialize,\n    }) as never;\n}\n", "/* #__NO_SIDE_EFFECTS__ */\nexport function getInt32LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n): number {\n    return (\n        buffer[offset]! |\n        (buffer[offset + 1]! << 8) |\n        (buffer[offset + 2]! << 16) |\n        (buffer[offset + 3]! << 24)\n    );\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function getInt32BigEndian(buffer: Uint8Array, offset: number): number {\n    return (\n        (buffer[offset]! << 24) |\n        (buffer[offset + 1]! << 16) |\n        (buffer[offset + 2]! << 8) |\n        buffer[offset + 3]!\n    );\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function getInt32(\n    buffer: Uint8Array,\n    offset: number,\n    littleEndian: boolean,\n) {\n    return littleEndian\n        ? buffer[offset]! |\n              (buffer[offset + 1]! << 8) |\n              (buffer[offset + 2]! << 16) |\n              (buffer[offset + 3]! << 24)\n        : (buffer[offset]! << 24) |\n              (buffer[offset + 1]! << 16) |\n              (buffer[offset + 2]! << 8) |\n              buffer[offset + 3]!;\n}\n\nexport function setInt32LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n) {\n    buffer[offset] = value;\n    buffer[offset + 1] = value >> 8;\n    buffer[offset + 2] = value >> 16;\n    buffer[offset + 3] = value >> 24;\n}\n\nexport function setInt32BigEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n) {\n    buffer[offset] = value >> 24;\n    buffer[offset + 1] = value >> 16;\n    buffer[offset + 2] = value >> 8;\n    buffer[offset + 3] = value;\n}\n\nexport function setInt32(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n    littleEndian: boolean,\n) {\n    if (littleEndian) {\n        buffer[offset] = value;\n        buffer[offset + 1] = value >> 8;\n        buffer[offset + 2] = value >> 16;\n        buffer[offset + 3] = value >> 24;\n    } else {\n        buffer[offset] = value >> 24;\n        buffer[offset + 1] = value >> 16;\n        buffer[offset + 2] = value >> 8;\n        buffer[offset + 3] = value;\n    }\n}\n", "/* #__NO_SIDE_EFFECTS__ */\nexport function getUint32LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n): number {\n    return (\n        (buffer[offset]! |\n            (buffer[offset + 1]! << 8) |\n            (buffer[offset + 2]! << 16) |\n            (buffer[offset + 3]! << 24)) >>>\n        0\n    );\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function getUint32BigEndian(buffer: Uint8Array, offset: number): number {\n    return (\n        ((buffer[offset]! << 24) |\n            (buffer[offset + 1]! << 16) |\n            (buffer[offset + 2]! << 8) |\n            buffer[offset + 3]!) >>>\n        0\n    );\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function getUint32(\n    buffer: Uint8Array,\n    offset: number,\n    littleEndian: boolean,\n) {\n    return littleEndian\n        ? (buffer[offset]! |\n              (buffer[offset + 1]! << 8) |\n              (buffer[offset + 2]! << 16) |\n              (buffer[offset + 3]! << 24)) >>>\n              0\n        : ((buffer[offset]! << 24) |\n              (buffer[offset + 1]! << 16) |\n              (buffer[offset + 2]! << 8) |\n              buffer[offset + 3]!) >>>\n              0;\n}\n\nexport function setUint32LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n): void {\n    buffer[offset] = value;\n    buffer[offset + 1] = value >> 8;\n    buffer[offset + 2] = value >> 16;\n    buffer[offset + 3] = value >> 24;\n}\n\nexport function setUint32BigEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n): void {\n    buffer[offset] = value >> 24;\n    buffer[offset + 1] = value >> 16;\n    buffer[offset + 2] = value >> 8;\n    buffer[offset + 3] = value;\n}\n\nexport function setUint32(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n    littleEndian: boolean,\n): void {\n    if (littleEndian) {\n        buffer[offset] = value;\n        buffer[offset + 1] = value >> 8;\n        buffer[offset + 2] = value >> 16;\n        buffer[offset + 3] = value >> 24;\n    } else {\n        buffer[offset] = value >> 24;\n        buffer[offset + 1] = value >> 16;\n        buffer[offset + 2] = value >> 8;\n        buffer[offset + 3] = value;\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport {\n    getInt16,\n    getInt32,\n    getInt64,\n    getInt8,\n    getUint16,\n    getUint32,\n    getUint64,\n    setInt16,\n    setInt32,\n    setInt64,\n    setUint16,\n    setUint32,\n    setUint64,\n} from \"@yume-chan/no-data-view\";\n\nimport type {\n    Field,\n    FieldByobSerializeContext,\n    FieldDeserializeContext,\n} from \"./field/index.js\";\nimport { field } from \"./field/index.js\";\nimport type { AsyncExactReadable } from \"./readable.js\";\n\nexport interface NumberField<T> extends Field<T, never, never, T> {\n    <const U>(infer?: U): Field<U, never, never, T>;\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nfunction number<T>(\n    size: number,\n    serialize: (\n        source: T,\n        context: FieldByobSerializeContext & { index: number },\n    ) => void,\n    deserialize: (\n        then: <U>(value: MaybePromiseLike<U>) => Iterable<unknown, U, unknown>,\n        reader: AsyncExactReadable,\n        context: FieldDeserializeContext<never>,\n    ) => Generator<unknown, T, unknown>,\n) {\n    const fn: NumberField<T> = (() => fn) as never;\n    Object.assign(fn, field(size, \"byob\", serialize, deserialize));\n    return fn;\n}\n\nexport const u8: NumberField<number> = number(\n    1,\n    (value, { buffer, index }) => {\n        buffer[index] = value;\n    },\n    function* (then, reader) {\n        const data = yield* then(reader.readExactly(1));\n        return data[0]!;\n    },\n);\n\nexport const s8: NumberField<number> = number(\n    1,\n    (value, { buffer, index }) => {\n        buffer[index] = value;\n    },\n    function* (then, reader) {\n        const data = yield* then(reader.readExactly(1));\n        return getInt8(data, 0);\n    },\n);\n\nexport const u16: NumberField<number> = number(\n    2,\n    (value, { buffer, index, littleEndian }) => {\n        setUint16(buffer, index, value, littleEndian);\n    },\n    function* (then, reader, { littleEndian }) {\n        const data = yield* then(reader.readExactly(2));\n        return getUint16(data, 0, littleEndian);\n    },\n);\n\nexport const s16: NumberField<number> = number(\n    2,\n    (value, { buffer, index, littleEndian }) => {\n        setInt16(buffer, index, value, littleEndian);\n    },\n    function* (then, reader, { littleEndian }) {\n        const data = yield* then(reader.readExactly(2));\n        return getInt16(data, 0, littleEndian);\n    },\n);\n\nexport const u32: NumberField<number> = number(\n    4,\n    (value, { buffer, index, littleEndian }) => {\n        setUint32(buffer, index, value, littleEndian);\n    },\n    function* (then, reader, { littleEndian }) {\n        const data = yield* then(reader.readExactly(4));\n        return getUint32(data, 0, littleEndian);\n    },\n);\n\nexport const s32: NumberField<number> = number(\n    4,\n    (value, { buffer, index, littleEndian }) => {\n        setInt32(buffer, index, value, littleEndian);\n    },\n    function* (then, reader, { littleEndian }) {\n        const data = yield* then(reader.readExactly(4));\n        return getInt32(data, 0, littleEndian);\n    },\n);\n\nexport const u64: NumberField<bigint> = number(\n    8,\n    (value, { buffer, index, littleEndian }) => {\n        setUint64(buffer, index, value, littleEndian);\n    },\n    function* (then, reader, { littleEndian }) {\n        const data = yield* then(reader.readExactly(8));\n        return getUint64(data, 0, littleEndian);\n    },\n);\n\nexport const s64: NumberField<bigint> = number(\n    8,\n    (value, { buffer, index, littleEndian }) => {\n        setInt64(buffer, index, value, littleEndian);\n    },\n    function* (then, reader, { littleEndian }) {\n        const data = yield* then(reader.readExactly(8));\n        return getInt64(data, 0, littleEndian);\n    },\n);\n", "import type {\n    AbortSignal,\n    ReadableStreamIteratorOptions,\n    ReadableStream as ReadableStreamType,\n    TransformStream as TransformStreamType,\n    WritableStream as WritableStreamType,\n} from \"./types.js\";\n\nexport * from \"./types.js\";\nexport { ReadableStream };\n\n/** A controller object that allows you to abort one or more DOM requests as and when desired. */\nexport interface AbortController {\n    /**\n     * Returns the AbortSignal object associated with this object.\n     */\n    readonly signal: AbortSignal;\n\n    /**\n     * Invoking this method will set this object's AbortSignal's aborted flag and signal to any observers that the associated activity is to be aborted.\n     */\n    abort(reason?: unknown): void;\n}\n\ninterface AbortControllerConstructor {\n    prototype: AbortController;\n    new (): AbortController;\n}\n\ninterface GlobalExtension {\n    AbortController: AbortControllerConstructor;\n    ReadableStream: typeof ReadableStreamType;\n    WritableStream: typeof WritableStreamType;\n    TransformStream: typeof TransformStreamType;\n}\n\nexport const { AbortController } = globalThis as unknown as GlobalExtension;\n\nexport type ReadableStream<T> = ReadableStreamType<T>;\nexport type WritableStream<T> = WritableStreamType<T>;\nexport type TransformStream<I, O> = TransformStreamType<I, O>;\n\nconst ReadableStream = /* #__PURE__ */ (() => {\n    const { ReadableStream } = globalThis as unknown as GlobalExtension;\n\n    if (!ReadableStream.from) {\n        ReadableStream.from = function (iterable) {\n            const iterator =\n                Symbol.asyncIterator in iterable\n                    ? iterable[Symbol.asyncIterator]()\n                    : iterable[Symbol.iterator]();\n\n            return new ReadableStream({\n                async pull(controller) {\n                    const result = await iterator.next();\n                    if (result.done) {\n                        controller.close();\n                        return;\n                    }\n                    controller.enqueue(result.value);\n                },\n                async cancel(reason) {\n                    await iterator.return?.(reason);\n                },\n            });\n        };\n    }\n\n    if (\n        !ReadableStream.prototype[Symbol.asyncIterator] ||\n        !ReadableStream.prototype.values\n    ) {\n        ReadableStream.prototype.values = async function* <R>(\n            this: ReadableStream<R>,\n            options?: ReadableStreamIteratorOptions,\n        ) {\n            const reader = this.getReader();\n            try {\n                while (true) {\n                    const { done, value } = await reader.read();\n                    if (done) {\n                        return;\n                    }\n                    yield value;\n                }\n            } finally {\n                // Calling `iterator.return` will enter this `finally` block.\n                // We don't need to care about the parameter to `iterator.return`,\n                // it will be returned as the final `result.value` automatically.\n                if (!options?.preventCancel) {\n                    await reader.cancel();\n                }\n                reader.releaseLock();\n            }\n        };\n\n        ReadableStream.prototype[Symbol.asyncIterator] =\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            ReadableStream.prototype.values;\n    }\n\n    return ReadableStream;\n})();\n\nexport const { WritableStream, TransformStream } =\n    globalThis as unknown as GlobalExtension;\n", "import type { BufferedReadableStream } from \"./buffered.js\";\nimport type { PushReadableStreamController } from \"./push-readable.js\";\nimport type {\n    ReadableStream,\n    ReadableStreamDefaultController,\n    ReadableStreamDefaultReader,\n    WritableStreamDefaultWriter,\n} from \"./stream.js\";\n\nexport function tryClose(\n    controller: PushReadableStreamController<unknown>,\n): boolean;\nexport function tryClose(\n    controller: ReadableStreamDefaultController<unknown>,\n): boolean;\nexport function tryClose(writer: WritableStreamDefaultWriter<never>): boolean;\nexport function tryClose(controller: { close(): void }) {\n    try {\n        controller.close();\n        return true;\n    } catch {\n        return false;\n    }\n}\n\nexport async function tryCancel(\n    stream: ReadableStream<unknown>,\n): Promise<boolean>;\nexport async function tryCancel(\n    stream: BufferedReadableStream,\n): Promise<boolean>;\nexport async function tryCancel(\n    reader: ReadableStreamDefaultReader<unknown>,\n): Promise<boolean>;\nexport async function tryCancel(stream: {\n    cancel(): Promise<void>;\n}): Promise<boolean> {\n    try {\n        await stream.cancel();\n        return true;\n    } catch {\n        return false;\n    }\n}\n", "import { Consumable } from \"../consumable.js\";\nimport type { QueuingStrategy } from \"../stream.js\";\nimport { ReadableStream } from \"../stream.js\";\n\nexport interface ConsumableReadableStreamController<T> {\n    enqueue(chunk: T): Promise<void>;\n    close(): void;\n    error(reason: unknown): void;\n}\n\nexport interface ConsumableReadableStreamSource<T> {\n    start?(\n        controller: ConsumableReadableStreamController<T>,\n    ): void | PromiseLike<void>;\n    pull?(\n        controller: ConsumableReadableStreamController<T>,\n    ): void | PromiseLike<void>;\n    cancel?(reason: unknown): void | PromiseLike<void>;\n}\n\nexport class ConsumableReadableStream<T> extends ReadableStream<Consumable<T>> {\n    static async enqueue<T>(\n        controller: { enqueue: (chunk: Consumable<T>) => void },\n        chunk: T,\n    ) {\n        const output = new Consumable(chunk);\n        controller.enqueue(output);\n        await output.consumed;\n    }\n\n    constructor(\n        source: ConsumableReadableStreamSource<T>,\n        strategy?: QueuingStrategy<T>,\n    ) {\n        let wrappedController!: ConsumableReadableStreamController<T>;\n\n        let wrappedStrategy: QueuingStrategy<Consumable<T>> | undefined;\n        if (strategy) {\n            wrappedStrategy = {};\n            if (\"highWaterMark\" in strategy) {\n                wrappedStrategy.highWaterMark = strategy.highWaterMark;\n            }\n            if (\"size\" in strategy) {\n                wrappedStrategy.size = (chunk) => {\n                    return strategy.size!(chunk.value);\n                };\n            }\n        }\n\n        super(\n            {\n                start(controller) {\n                    wrappedController = {\n                        enqueue(chunk) {\n                            return ConsumableReadableStream.enqueue(\n                                controller,\n                                chunk,\n                            );\n                        },\n                        close() {\n                            controller.close();\n                        },\n                        error(reason) {\n                            controller.error(reason);\n                        },\n                    };\n\n                    return source.start?.(wrappedController);\n                },\n                pull() {\n                    return source.pull?.(wrappedController);\n                },\n                cancel(reason) {\n                    return source.cancel?.(reason);\n                },\n            },\n            wrappedStrategy,\n        );\n    }\n}\n", "import type { Consumable } from \"../consumable.js\";\nimport { ReadableStream } from \"../stream.js\";\n\nimport { ConsumableReadableStream } from \"./readable.js\";\n\nexport class ConsumableWrapByteReadableStream extends ReadableStream<\n    Consumable<Uint8Array>\n> {\n    constructor(\n        stream: ReadableStream<Uint8Array>,\n        chunkSize: number,\n        min?: number,\n    ) {\n        const reader = stream.getReader({ mode: \"byob\" });\n        let array = new Uint8Array(chunkSize);\n        super({\n            async pull(controller) {\n                const { done, value } = await reader.read(array, { min });\n                if (done) {\n                    controller.close();\n                    return;\n                }\n\n                await ConsumableReadableStream.enqueue(controller, value);\n\n                array = new Uint8Array(value.buffer);\n            },\n            cancel(reason) {\n                return reader.cancel(reason);\n            },\n        });\n    }\n}\n", "import type { Consumable } from \"../consumable.js\";\nimport { WritableStream } from \"../stream.js\";\n\nexport class ConsumableWrapWritableStream<in T> extends WritableStream<\n    Consumable<T>\n> {\n    constructor(stream: WritableStream<T>) {\n        const writer = stream.getWriter();\n        super({\n            write(chunk) {\n                return chunk.tryConsume((chunk) => writer.write(chunk));\n            },\n            abort(reason) {\n                return writer.abort(reason);\n            },\n            close() {\n                return writer.close();\n            },\n        });\n    }\n}\n", "import { Consumable } from \"../consumable.js\";\nimport type {\n    QueuingStrategy,\n    WritableStreamDefaultController,\n    WritableStreamDefaultWriter,\n} from \"../stream.js\";\nimport { WritableStream } from \"../stream.js\";\n\nexport interface ConsumableWritableStreamSink<in T> {\n    start?(\n        controller: WritableStreamDefaultController,\n    ): void | PromiseLike<void>;\n    write?(\n        chunk: T,\n        controller: WritableStreamDefaultController,\n    ): void | PromiseLike<void>;\n    abort?(reason: unknown): void | PromiseLike<void>;\n    close?(): void | PromiseLike<void>;\n}\n\nexport class ConsumableWritableStream<in T> extends WritableStream<\n    Consumable<T>\n> {\n    static async write<T>(\n        writer: WritableStreamDefaultWriter<Consumable<T>>,\n        value: T,\n    ) {\n        const consumable = new Consumable(value);\n        await writer.write(consumable);\n        await consumable.consumed;\n    }\n\n    constructor(\n        sink: ConsumableWritableStreamSink<T>,\n        strategy?: QueuingStrategy<T>,\n    ) {\n        let wrappedStrategy: QueuingStrategy<Consumable<T>> | undefined;\n        if (strategy) {\n            wrappedStrategy = {};\n            if (\"highWaterMark\" in strategy) {\n                wrappedStrategy.highWaterMark = strategy.highWaterMark;\n            }\n            if (\"size\" in strategy) {\n                wrappedStrategy.size = (chunk) => {\n                    return strategy.size!(\n                        chunk instanceof Consumable ? chunk.value : chunk,\n                    );\n                };\n            }\n        }\n\n        super(\n            {\n                start(controller) {\n                    return sink.start?.(controller);\n                },\n                write(chunk, controller) {\n                    return chunk.tryConsume((chunk) =>\n                        sink.write?.(chunk, controller),\n                    );\n                },\n                abort(reason) {\n                    return sink.abort?.(reason);\n                },\n                close() {\n                    return sink.close?.();\n                },\n            },\n            wrappedStrategy,\n        );\n    }\n}\n", "export interface Task {\n    run<T>(callback: () => T): T;\n}\n\ninterface Console {\n    createTask(name: string): Task;\n}\n\ninterface GlobalExtension {\n    console?: Console;\n}\n\n// `createTask` allows browser DevTools to track the call stack across async boundaries.\nconst { console } = globalThis as unknown as GlobalExtension;\nexport const createTask: (name: string) => Task = /* #__PURE__ */ (() =>\n    console?.createTask?.bind(console) ??\n    (() => ({\n        run(callback) {\n            return callback();\n        },\n    })))();\n", "import { PromiseResolver, isPromiseLike } from \"@yume-chan/async\";\n\nimport type {\n    ConsumableReadableStreamController,\n    ConsumableReadableStreamSource,\n    ConsumableWritableStreamSink,\n} from \"./consumable/index.js\";\nimport {\n    ConsumableReadableStream,\n    ConsumableWrapByteReadableStream,\n    ConsumableWrapWritableStream,\n    ConsumableWritableStream,\n} from \"./consumable/index.js\";\nimport type { Task } from \"./task.js\";\nimport { createTask } from \"./task.js\";\n\nexport class Consumable<T> {\n    static readonly WritableStream = ConsumableWritableStream;\n    static readonly WrapWritableStream = ConsumableWrapWritableStream;\n    static readonly ReadableStream = ConsumableReadableStream;\n    static readonly WrapByteReadableStream = ConsumableWrapByteReadableStream;\n\n    readonly #task: Task;\n    readonly #resolver: PromiseResolver<void>;\n\n    readonly value: T;\n    readonly consumed: Promise<void>;\n\n    constructor(value: T) {\n        this.#task = createTask(\"Consumable\");\n        this.value = value;\n        this.#resolver = new PromiseResolver<void>();\n        this.consumed = this.#resolver.promise;\n    }\n\n    consume() {\n        this.#resolver.resolve();\n    }\n\n    error(error: unknown) {\n        this.#resolver.reject(error);\n    }\n\n    tryConsume<U>(callback: (value: T) => U) {\n        try {\n            let result = this.#task.run(() => callback(this.value));\n            if (isPromiseLike(result)) {\n                result = result.then(\n                    (value) => {\n                        this.#resolver.resolve();\n                        return value;\n                    },\n                    (e) => {\n                        this.#resolver.reject(e);\n                        throw e;\n                    },\n                ) as U;\n            } else {\n                this.#resolver.resolve();\n            }\n            return result;\n        } catch (e) {\n            this.#resolver.reject(e);\n            throw e;\n        }\n    }\n}\n\nexport namespace Consumable {\n    export type WritableStreamSink<T> = ConsumableWritableStreamSink<T>;\n    export type WritableStream<in T> = typeof ConsumableWritableStream<T>;\n\n    export type WrapWritableStream<in T> =\n        typeof ConsumableWrapWritableStream<T>;\n\n    export type ReadableStreamController<T> =\n        ConsumableReadableStreamController<T>;\n    export type ReadableStreamSource<T> = ConsumableReadableStreamSource<T>;\n    export type ReadableStream<T> = typeof ConsumableReadableStream<T>;\n\n    export type WrapByteReadableStream =\n        typeof ConsumableWrapByteReadableStream;\n}\n", "export * from \"./utils.js\";\nexport { MaybeConsumableWrapWritableStream as WrapWritableStream } from \"./wrap-writable.js\";\nexport { MaybeConsumableWritableStream as WritableStream } from \"./writable.js\";\nexport type { MaybeConsumableWritableStreamSink as WritableStreamSink } from \"./writable.js\";\n", "import { Consumable } from \"../consumable.js\";\nimport type { MaybeConsumable } from \"../maybe-consumable.js\";\n\nexport function getValue<T>(value: MaybeConsumable<T>): T {\n    return value instanceof Consumable ? value.value : value;\n}\n\nexport function tryConsume<T, R>(\n    value: T,\n    callback: (value: T extends Consumable<infer U> ? U : T) => R,\n): R {\n    if (value instanceof Consumable) {\n        return value.tryConsume(callback);\n    } else {\n        return callback(value as never);\n    }\n}\n", "import type { MaybeConsumable } from \"../maybe-consumable.js\";\nimport { WritableStream } from \"../stream.js\";\n\nimport { tryConsume } from \"./utils.js\";\n\nexport class MaybeConsumableWrapWritableStream<T> extends WritableStream<\n    MaybeConsumable<T>\n> {\n    constructor(stream: WritableStream<T>) {\n        const writer = stream.getWriter();\n        super({\n            write(chunk) {\n                return tryConsume(chunk, (chunk) => writer.write(chunk as T));\n            },\n            abort(reason) {\n                return writer.abort(reason);\n            },\n            close() {\n                return writer.close();\n            },\n        });\n    }\n}\n", "import { Consumable } from \"../consumable.js\";\nimport type { MaybeConsumable } from \"../maybe-consumable.js\";\nimport type {\n    QueuingStrategy,\n    WritableStreamDefaultController,\n} from \"../stream.js\";\nimport { WritableStream } from \"../stream.js\";\n\nimport { tryConsume } from \"./utils.js\";\n\nexport interface MaybeConsumableWritableStreamSink<in T> {\n    start?(\n        controller: WritableStreamDefaultController,\n    ): void | PromiseLike<void>;\n    write?(\n        chunk: T,\n        controller: WritableStreamDefaultController,\n    ): void | PromiseLike<void>;\n    abort?(reason: unknown): void | PromiseLike<void>;\n    close?(): void | PromiseLike<void>;\n}\n\nexport class MaybeConsumableWritableStream<in T> extends WritableStream<\n    MaybeConsumable<T>\n> {\n    constructor(\n        sink: MaybeConsumableWritableStreamSink<T>,\n        strategy?: QueuingStrategy<T>,\n    ) {\n        let wrappedStrategy: QueuingStrategy<MaybeConsumable<T>> | undefined;\n        if (strategy) {\n            wrappedStrategy = {};\n            if (\"highWaterMark\" in strategy) {\n                wrappedStrategy.highWaterMark = strategy.highWaterMark;\n            }\n            if (\"size\" in strategy) {\n                wrappedStrategy.size = (chunk) => {\n                    return strategy.size!(\n                        chunk instanceof Consumable ? chunk.value : chunk,\n                    );\n                };\n            }\n        }\n\n        super(\n            {\n                start(controller) {\n                    return sink.start?.(controller);\n                },\n                write(chunk, controller) {\n                    return tryConsume(chunk, (chunk) =>\n                        sink.write?.(chunk as T, controller),\n                    );\n                },\n                abort(reason) {\n                    return sink.abort?.(reason);\n                },\n                close() {\n                    return sink.close?.();\n                },\n            },\n            wrappedStrategy,\n        );\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\n\nimport type {\n    QueuingStrategy,\n    ReadableStreamDefaultController,\n    ReadableStreamDefaultReader,\n} from \"./stream.js\";\nimport { ReadableStream } from \"./stream.js\";\n\nexport type WrapReadableStreamStart<T> = (\n    controller: ReadableStreamDefaultController<T>,\n) => MaybePromiseLike<ReadableStream<T>>;\n\nexport interface ReadableStreamWrapper<T> {\n    start: WrapReadableStreamStart<T>;\n    cancel?: (reason?: unknown) => MaybePromiseLike<void>;\n    close?: () => MaybePromiseLike<void>;\n    error?: (reason?: unknown) => MaybePromiseLike<void>;\n}\n\nfunction getWrappedReadableStream<T>(\n    wrapper:\n        | ReadableStream<T>\n        | WrapReadableStreamStart<T>\n        | ReadableStreamWrapper<T>,\n    controller: ReadableStreamDefaultController<T>,\n) {\n    if (\"start\" in wrapper) {\n        return wrapper.start(controller);\n    } else if (typeof wrapper === \"function\") {\n        return wrapper(controller);\n    } else {\n        // Can't use `wrapper instanceof ReadableStream`\n        // Because we want to be compatible with any ReadableStream-like objects\n        return wrapper;\n    }\n}\n\n/**\n * This class has multiple usages:\n *\n * 1. Get notified when the stream is cancelled or closed.\n * 2. Synchronously create a `ReadableStream` by asynchronously return another `ReadableStream`.\n * 3. Convert native `ReadableStream`s to polyfilled ones so they can `pipe` between.\n */\nexport class WrapReadableStream<T> extends ReadableStream<T> {\n    readable!: ReadableStream<T>;\n\n    #reader!: ReadableStreamDefaultReader<T>;\n\n    constructor(\n        wrapper:\n            | ReadableStream<T>\n            | WrapReadableStreamStart<T>\n            | ReadableStreamWrapper<T>,\n        strategy?: QueuingStrategy<T>,\n    ) {\n        super(\n            {\n                start: async (controller) => {\n                    const readable = await getWrappedReadableStream(\n                        wrapper,\n                        controller,\n                    );\n                    // `start` is called in `super()`, so can't use `this` synchronously.\n                    // but it's fine after the first `await`\n                    this.readable = readable;\n                    this.#reader = this.readable.getReader();\n                },\n                pull: async (controller) => {\n                    const { done, value } = await this.#reader\n                        .read()\n                        .catch((e) => {\n                            if (\"error\" in wrapper) {\n                                wrapper.error(e);\n                            }\n                            throw e;\n                        });\n\n                    if (done) {\n                        controller.close();\n                        if (\"close\" in wrapper) {\n                            await wrapper.close?.();\n                        }\n                    } else {\n                        controller.enqueue(value);\n                    }\n                },\n                cancel: async (reason) => {\n                    await this.#reader.cancel(reason);\n                    if (\"cancel\" in wrapper) {\n                        await wrapper.cancel?.(reason);\n                    }\n                },\n            },\n            strategy,\n        );\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport { PromiseResolver } from \"@yume-chan/async\";\n\nimport type {\n    QueuingStrategy,\n    ReadableStream,\n    ReadableStreamDefaultController,\n    WritableStreamDefaultWriter,\n} from \"./stream.js\";\nimport { WritableStream } from \"./stream.js\";\nimport { tryClose } from \"./try-close.js\";\nimport { WrapReadableStream } from \"./wrap-readable.js\";\n\nconst NOOP = () => {\n    // no-op\n};\n\nexport interface DuplexStreamFactoryOptions {\n    /**\n     * Callback when any `ReadableStream` is cancelled (the user doesn't need any more data),\n     * or `WritableStream` is ended (the user won't produce any more data),\n     * or `DuplexStreamFactory#close` is called.\n     *\n     * Usually you want to let the other peer know that the duplex stream should be closed.\n     *\n     * `dispose` will automatically be called after `close` completes,\n     * but if you want to wait another peer for a close confirmation and call\n     * `DuplexStreamFactory#dispose` yourself, you can return `false`\n     * (or a `Promise` that resolves to `false`) to disable the automatic call.\n     */\n    close?: (() => MaybePromiseLike<boolean | void>) | undefined;\n\n    /**\n     * Callback when any `ReadableStream` is closed (the other peer doesn't produce any more data),\n     * or `WritableStream` is aborted (the other peer can't receive any more data),\n     * or `DuplexStreamFactory#abort` is called.\n     *\n     * Usually indicates the other peer has closed the duplex stream. You can clean up\n     * any resources you have allocated now.\n     */\n    dispose?: (() => void | Promise<void>) | undefined;\n}\n\n/**\n * A factory for creating a duplex stream.\n *\n * It can create multiple `ReadableStream`s and `WritableStream`s,\n * when any of them is closed, all other streams will be closed as well.\n */\nexport class DuplexStreamFactory<R, W> {\n    #readableControllers: ReadableStreamDefaultController<R>[] = [];\n    #writers: WritableStreamDefaultWriter<W>[] = [];\n\n    #writableClosed = false;\n    get writableClosed() {\n        return this.#writableClosed;\n    }\n\n    #closed = new PromiseResolver<void>();\n    get closed() {\n        return this.#closed.promise;\n    }\n\n    readonly #options: DuplexStreamFactoryOptions;\n\n    constructor(options?: DuplexStreamFactoryOptions) {\n        this.#options = options ?? {};\n    }\n\n    wrapReadable(\n        readable: ReadableStream<R>,\n        strategy?: QueuingStrategy<R>,\n    ): WrapReadableStream<R> {\n        return new WrapReadableStream<R>(\n            {\n                start: (controller) => {\n                    this.#readableControllers.push(controller);\n                    return readable;\n                },\n                cancel: async () => {\n                    // cancel means the local peer wants to close the connection.\n                    await this.close();\n                },\n                close: async () => {\n                    // stream end means the remote peer closed the connection first.\n                    await this.dispose();\n                },\n            },\n            strategy,\n        );\n    }\n\n    createWritable(stream: WritableStream<W>): WritableStream<W> {\n        const writer = stream.getWriter();\n        this.#writers.push(writer);\n\n        // `WritableStream` has no way to tell if the remote peer has closed the connection.\n        // So it only triggers `close`.\n        return new WritableStream<W>({\n            write: async (chunk) => {\n                await writer.write(chunk);\n            },\n            abort: async (reason) => {\n                await writer.abort(reason);\n                await this.close();\n            },\n            close: async () => {\n                // NOOP: the writer is already closed\n                await writer.close().catch(NOOP);\n                await this.close();\n            },\n        });\n    }\n\n    async close() {\n        if (this.#writableClosed) {\n            return;\n        }\n        this.#writableClosed = true;\n\n        // Call `close` first, so it can still write data to `WritableStream`s.\n        if ((await this.#options.close?.()) !== false) {\n            // `close` can return `false` to disable automatic `dispose`.\n            await this.dispose();\n        }\n\n        for (const writer of this.#writers) {\n            // NOOP: the writer is already closed\n            writer.close().catch(NOOP);\n        }\n    }\n\n    async dispose() {\n        this.#writableClosed = true;\n        this.#closed.resolve();\n\n        for (const controller of this.#readableControllers) {\n            tryClose(controller);\n        }\n\n        await this.#options.dispose?.();\n    }\n}\n", "import type { ReadableWritablePair } from \"./stream.js\";\nimport { WritableStream } from \"./stream.js\";\n\n/**\n * Pipe `pair.readable` to `writable`, then returns `pair.writable`.\n *\n * This is the opposite of `ReadableStream#pipeThrough()`.\n *\n * @param writable The `WritableStream` to write to.\n * @param pair A `TransformStream` that converts chunks.\n * @returns `pair`'s `writable` stream.\n */\nexport function pipeFrom<W, T>(\n    writable: WritableStream<W>,\n    pair: ReadableWritablePair<W, T>,\n) {\n    const writer = pair.writable.getWriter();\n    const pipe = pair.readable.pipeTo(writable);\n    return new WritableStream<T>({\n        async write(chunk) {\n            await writer.write(chunk);\n        },\n        async close() {\n            await writer.close();\n            await pipe;\n        },\n    });\n}\n", "import type { Disposable } from \"./disposable.js\";\nimport type { Event, EventListener, RemoveEventListener } from \"./event.js\";\n\nexport interface EventListenerInfo<TEvent, TResult = unknown> {\n    listener: EventListener<TEvent, unknown, unknown[], TResult>;\n\n    thisArg: unknown;\n\n    args: unknown[];\n}\n\nexport class EventEmitter<TEvent, TResult = unknown> implements Disposable {\n    protected readonly listeners: EventListenerInfo<TEvent, TResult>[] = [];\n\n    constructor() {\n        this.event = this.event.bind(this);\n    }\n\n    protected addEventListener(\n        info: EventListenerInfo<TEvent, TResult>,\n    ): RemoveEventListener {\n        this.listeners.push(info);\n\n        const remove: RemoveEventListener = () => {\n            const index = this.listeners.indexOf(info);\n            if (index !== -1) {\n                this.listeners.splice(index, 1);\n            }\n        };\n        remove.dispose = remove;\n        return remove;\n    }\n\n    event: Event<TEvent, TResult> = <TThis, TArgs extends unknown[]>(\n        listener: EventListener<TEvent, TThis, TArgs, TResult>,\n        thisArg?: TThis,\n        ...args: TArgs\n    ) => {\n        const info: EventListenerInfo<TEvent, TResult> = {\n            listener: listener as EventListener<\n                TEvent,\n                unknown,\n                unknown[],\n                TResult\n            >,\n            thisArg,\n            args,\n        };\n        return this.addEventListener(info);\n    };\n\n    fire(e: TEvent) {\n        for (const info of this.listeners.slice()) {\n            info.listener.call(info.thisArg, e, ...info.args);\n        }\n    }\n\n    dispose() {\n        this.listeners.length = 0;\n    }\n}\n", "import type { EventListenerInfo } from \"./event-emitter.js\";\nimport { EventEmitter } from \"./event-emitter.js\";\nimport type { RemoveEventListener } from \"./event.js\";\n\nconst Undefined = Symbol(\"undefined\");\n\nexport class StickyEventEmitter<TEvent, TResult = unknown> extends EventEmitter<\n    TEvent,\n    TResult\n> {\n    #value: TEvent | typeof Undefined = Undefined;\n\n    protected override addEventListener(\n        info: EventListenerInfo<TEvent, TResult>,\n    ): RemoveEventListener {\n        if (this.#value !== Undefined) {\n            info.listener.call(info.thisArg, this.#value, ...info.args);\n        }\n        return super.addEventListener(info);\n    }\n\n    override fire(e: TEvent): void {\n        this.#value = e;\n        super.fire(e);\n    }\n}\n", "export function toLocalUint8Array(value: Uint8Array): Uint8Array<ArrayBuffer> {\n    if (value.buffer instanceof ArrayBuffer) {\n        return value as Uint8Array<ArrayBuffer>;\n    }\n\n    const copy = new Uint8Array(value.length);\n    copy.set(value);\n    return copy;\n}\n", "/* #__NO_SIDE_EFFECTS__ */\nexport const NOOP = () => {\n    // no-op\n};\n\n/**\n * When used in `Promise#catch`, means the promise should never throw errors.\n * An explicit way to suppress ESLint floating promise warnings.\n */\nexport function unreachable(...args: unknown[]): never {\n    // Trigger runtime's unhandled rejection event.\n    throw new Error(\"Unreachable. Arguments:\\n\" + args.join(\"\\n\"));\n}\n", "import { Consumable, TransformStream } from \"@yume-chan/stream-extra\";\nimport type { StructInit, StructValue } from \"@yume-chan/struct\";\nimport { buffer, extend, s32, struct, u32 } from \"@yume-chan/struct\";\n\nexport const AdbCommand = {\n    Auth: 0x48545541, // 'AUTH'\n    Close: 0x45534c43, // 'CLSE'\n    Connect: 0x4e584e43, // 'CNXN'\n    Okay: 0x59414b4f, // 'OKAY'\n    Open: 0x4e45504f, // 'OPEN'\n    Write: 0x45545257, // 'WRTE'\n} as const;\n\nexport type AdbCommand = (typeof AdbCommand)[keyof typeof AdbCommand];\n\nexport const AdbPacketHeader = struct(\n    {\n        command: u32,\n        arg0: u32,\n        arg1: u32,\n        payloadLength: u32,\n        checksum: u32,\n        magic: s32,\n    },\n    { littleEndian: true },\n);\n\nexport type AdbPacketHeader = StructValue<typeof AdbPacketHeader>;\n\ntype AdbPacketHeaderInit = StructInit<typeof AdbPacketHeader>;\n\nexport const AdbPacket = extend(AdbPacketHeader, {\n    payload: buffer(\"payloadLength\"),\n});\n\nexport type AdbPacket = StructValue<typeof AdbPacket>;\n\n/**\n * `AdbPacketData` contains all the useful fields of `AdbPacket`.\n *\n * `AdvDaemonConnection#connect` will return a `ReadableStream<AdbPacketData>`,\n * allow each connection to encode `AdbPacket` in different methods.\n *\n * `AdbDaemonConnection#connect` will return a `WritableStream<AdbPacketInit>`,\n * however, `AdbDaemonTransport` will transform `AdbPacketData` to `AdbPacketInit` for you,\n * so `AdbSocket#writable#write` only needs `AdbPacketData`.\n */\nexport type AdbPacketData = Omit<\n    StructInit<typeof AdbPacket>,\n    \"checksum\" | \"magic\"\n>;\n\nexport type AdbPacketInit = StructInit<typeof AdbPacket>;\n\nexport function calculateChecksum(payload: Uint8Array): number {\n    return payload.reduce((result, item) => result + item, 0);\n}\n\nexport class AdbPacketSerializeStream extends TransformStream<\n    Consumable<AdbPacketInit>,\n    Consumable<Uint8Array>\n> {\n    constructor() {\n        const headerBuffer = new Uint8Array(AdbPacketHeader.size);\n        super({\n            transform: async (chunk, controller) => {\n                await chunk.tryConsume(async (chunk) => {\n                    const init = chunk as AdbPacketInit & AdbPacketHeaderInit;\n                    init.payloadLength = init.payload.length;\n\n                    AdbPacketHeader.serialize(init, headerBuffer);\n                    await Consumable.ReadableStream.enqueue(\n                        controller,\n                        headerBuffer,\n                    );\n\n                    if (init.payloadLength) {\n                        // USB protocol preserves packet boundaries,\n                        // so we must write payload separately as native ADB does,\n                        // otherwise the read operation on device will fail.\n                        await Consumable.ReadableStream.enqueue(\n                            controller,\n                            init.payload,\n                        );\n                    }\n                });\n            },\n        });\n    }\n}\n", "import { EventEmitter, StickyEventEmitter } from \"@yume-chan/event\";\n\nimport { Ref } from \"../utils/index.js\";\n\nimport { AdbServerClient } from \"./client.js\";\nimport type { AdbServerStream } from \"./stream.js\";\n\nexport function unorderedRemove<T>(array: T[], index: number) {\n    if (index < 0 || index >= array.length) {\n        return;\n    }\n    array[index] = array[array.length - 1]!;\n    array.length -= 1;\n}\n\ninterface Observer {\n    includeStates: readonly AdbServerClient.ConnectionState[];\n    onDeviceAdd: EventEmitter<readonly AdbServerClient.Device[]>;\n    onDeviceRemove: EventEmitter<readonly AdbServerClient.Device[]>;\n    onListChange: EventEmitter<readonly AdbServerClient.Device[]>;\n    onError: EventEmitter<Error>;\n}\n\nfunction filterDeviceStates(\n    devices: readonly AdbServerClient.Device[],\n    states: readonly AdbServerClient.ConnectionState[],\n) {\n    return devices.filter((device) => states.includes(device.state));\n}\n\nexport class AdbServerDeviceObserverOwner {\n    current: readonly AdbServerClient.Device[] = [];\n\n    readonly #client: AdbServerClient;\n\n    #stream: Promise<AdbServerStream> | undefined;\n    #observers: Observer[] = [];\n\n    constructor(client: AdbServerClient) {\n        this.#client = client;\n    }\n\n    async #receive(stream: AdbServerStream) {\n        const response = await stream.readString();\n        const next = AdbServerClient.parseDeviceList(response);\n\n        const removed = this.current.slice();\n        const added: AdbServerClient.Device[] = [];\n        for (const nextDevice of next) {\n            const index = removed.findIndex(\n                (device) => device.transportId === nextDevice.transportId,\n            );\n\n            if (index === -1) {\n                added.push(nextDevice);\n                continue;\n            }\n\n            unorderedRemove(removed, index);\n        }\n\n        this.current = next;\n\n        if (added.length) {\n            for (const observer of this.#observers) {\n                const filtered = filterDeviceStates(\n                    added,\n                    observer.includeStates,\n                );\n                if (filtered.length) {\n                    observer.onDeviceAdd.fire(filtered);\n                }\n            }\n        }\n        if (removed.length) {\n            for (const observer of this.#observers) {\n                const filtered = filterDeviceStates(\n                    removed,\n                    observer.includeStates,\n                );\n                if (filtered.length) {\n                    observer.onDeviceRemove.fire(removed);\n                }\n            }\n        }\n\n        for (const observer of this.#observers) {\n            const filtered = filterDeviceStates(\n                this.current,\n                observer.includeStates,\n            );\n            observer.onListChange.fire(filtered);\n        }\n    }\n\n    async #receiveLoop(stream: AdbServerStream) {\n        try {\n            while (true) {\n                await this.#receive(stream);\n            }\n        } catch (e) {\n            this.#stream = undefined;\n\n            for (const observer of this.#observers) {\n                observer.onError.fire(e as Error);\n            }\n        }\n    }\n\n    async #connect() {\n        const stream = await this.#client.createConnection(\n            \"host:track-devices-l\",\n            // Each individual observer will ref depending on their options\n            { unref: true },\n        );\n\n        // Set `current` and `onListChange` value before returning\n        await this.#receive(stream);\n\n        // Then start receive loop\n        void this.#receiveLoop(stream);\n\n        return stream;\n    }\n\n    async #handleObserverStop(stream: AdbServerStream) {\n        if (this.#observers.length === 0) {\n            this.#stream = undefined;\n            await stream.dispose();\n        }\n    }\n\n    async createObserver(\n        options?: AdbServerDeviceObserverOwner.Options,\n    ): Promise<AdbServerClient.DeviceObserver> {\n        options?.signal?.throwIfAborted();\n\n        let current: readonly AdbServerClient.Device[] = [];\n        const onDeviceAdd = new EventEmitter<\n            readonly AdbServerClient.Device[]\n        >();\n        const onDeviceRemove = new EventEmitter<\n            readonly AdbServerClient.Device[]\n        >();\n        const onListChange = new StickyEventEmitter<\n            readonly AdbServerClient.Device[]\n        >();\n        const onError = new StickyEventEmitter<Error>();\n\n        const includeStates = options?.includeStates ?? [\n            \"device\",\n            \"unauthorized\",\n        ];\n        const observer = {\n            includeStates,\n            onDeviceAdd,\n            onDeviceRemove,\n            onListChange,\n            onError,\n        } satisfies Observer;\n        // Register `observer` before `#connect`.\n        // So `#handleObserverStop` knows if there is any observer.\n        this.#observers.push(observer);\n\n        // Read the filtered `current` value from `onListChange` event\n        onListChange.event((value) => (current = value));\n\n        let stream: AdbServerStream;\n        if (!this.#stream) {\n            // `#connect` will initialize `onListChange` and `current`\n            this.#stream = this.#connect();\n\n            try {\n                stream = await this.#stream;\n            } catch (e) {\n                this.#stream = undefined;\n                throw e;\n            }\n        } else {\n            stream = await this.#stream;\n            // Initialize `onListChange` and `current` ourselves\n            onListChange.fire(filterDeviceStates(this.current, includeStates));\n        }\n\n        const ref = new Ref(options);\n\n        const stop = async () => {\n            unorderedRemove(this.#observers, this.#observers.indexOf(observer));\n            await this.#handleObserverStop(stream);\n            ref.unref();\n        };\n\n        if (options?.signal) {\n            if (options.signal.aborted) {\n                await stop();\n                throw options.signal.reason;\n            }\n\n            options.signal.addEventListener(\"abort\", () => void stop());\n        }\n\n        return {\n            onDeviceAdd: onDeviceAdd.event,\n            onDeviceRemove: onDeviceRemove.event,\n            onListChange: onListChange.event,\n            onError: onError.event,\n            get current() {\n                return current;\n            },\n            stop,\n        };\n    }\n}\n\nexport namespace AdbServerDeviceObserverOwner {\n    export interface Options extends AdbServerClient.ServerConnectionOptions {\n        includeStates?: readonly AdbServerClient.ConnectionState[];\n    }\n}\n", "export class DeviceBusyError extends Error {\n    constructor(cause?: Error) {\n        super(\"The device is already in used by another program\", {\n            cause,\n        });\n    }\n}\n", "export function isErrorName(e: unknown, name: string): e is Error {\n    // node-usb package doesn't use `DOMException`,\n    // so use a looser check\n    // https://github.com/node-usb/node-usb/issues/573\n    return (\n        typeof e === \"object\" && e !== null && \"name\" in e && e.name === name\n    );\n}\n\nexport type PickNonNullable<T, K extends keyof T> = {\n    [P in K]-?: NonNullable<T[P]>;\n};\n\n/**\n * `classCode`, `subclassCode` and `protocolCode` are required\n * for selecting correct USB configuration and interface.\n */\nexport type UsbInterfaceFilter = PickNonNullable<\n    USBDeviceFilter,\n    \"classCode\" | \"subclassCode\" | \"protocolCode\"\n>;\n\nexport function isUsbInterfaceFilter(\n    filter: USBDeviceFilter,\n): filter is UsbInterfaceFilter {\n    return (\n        filter.classCode !== undefined &&\n        filter.subclassCode !== undefined &&\n        filter.protocolCode !== undefined\n    );\n}\n\nfunction matchUsbInterfaceFilter(\n    alternate: USBAlternateInterface,\n    filter: UsbInterfaceFilter,\n) {\n    return (\n        alternate.interfaceClass === filter.classCode &&\n        alternate.interfaceSubclass === filter.subclassCode &&\n        alternate.interfaceProtocol === filter.protocolCode\n    );\n}\n\nexport interface UsbInterfaceIdentifier {\n    configuration: USBConfiguration;\n    interface_: USBInterface;\n    alternate: USBAlternateInterface;\n}\n\nexport function findUsbInterface(\n    device: USBDevice,\n    filter: UsbInterfaceFilter,\n): UsbInterfaceIdentifier | undefined {\n    for (const configuration of device.configurations) {\n        for (const interface_ of configuration.interfaces) {\n            for (const alternate of interface_.alternates) {\n                if (matchUsbInterfaceFilter(alternate, filter)) {\n                    return { configuration, interface_, alternate };\n                }\n            }\n        }\n    }\n    return undefined;\n}\n\nfunction padNumber(value: number) {\n    return value.toString(16).padStart(4, \"0\");\n}\n\nexport function getSerialNumber(device: USBDevice) {\n    if (device.serialNumber) {\n        return device.serialNumber;\n    }\n\n    return padNumber(device.vendorId) + \"x\" + padNumber(device.productId);\n}\n\n/**\n * Find the first pair of input and output endpoints from an alternate interface.\n *\n * ADB interface only has two endpoints, one for input and one for output.\n */\nexport function findUsbEndpoints(endpoints: readonly USBEndpoint[]) {\n    if (endpoints.length === 0) {\n        throw new TypeError(\"No endpoints given\");\n    }\n\n    let inEndpoint: USBEndpoint | undefined;\n    let outEndpoint: USBEndpoint | undefined;\n\n    for (const endpoint of endpoints) {\n        switch (endpoint.direction) {\n            case \"in\":\n                inEndpoint = endpoint;\n                if (outEndpoint) {\n                    return { inEndpoint, outEndpoint };\n                }\n                break;\n            case \"out\":\n                outEndpoint = endpoint;\n                if (inEndpoint) {\n                    return { inEndpoint, outEndpoint };\n                }\n                break;\n        }\n    }\n\n    if (!inEndpoint) {\n        throw new TypeError(\"No input endpoint found.\");\n    }\n    if (!outEndpoint) {\n        throw new TypeError(\"No output endpoint found.\");\n    }\n    throw new Error(\"unreachable\");\n}\n\nexport function matchFilter(\n    device: USBDevice,\n    filter: USBDeviceFilter & UsbInterfaceFilter,\n): UsbInterfaceIdentifier | false;\nexport function matchFilter(\n    device: USBDevice,\n    filter: USBDeviceFilter,\n): boolean;\nexport function matchFilter(\n    device: USBDevice,\n    filter: USBDeviceFilter,\n): UsbInterfaceIdentifier | boolean {\n    if (filter.vendorId !== undefined && device.vendorId !== filter.vendorId) {\n        return false;\n    }\n\n    if (\n        filter.productId !== undefined &&\n        device.productId !== filter.productId\n    ) {\n        return false;\n    }\n\n    if (\n        filter.serialNumber !== undefined &&\n        getSerialNumber(device) !== filter.serialNumber\n    ) {\n        return false;\n    }\n\n    if (isUsbInterfaceFilter(filter)) {\n        return findUsbInterface(device, filter) || false;\n    }\n\n    return true;\n}\n\nexport function matchFilters(\n    device: USBDevice,\n    filters: readonly (USBDeviceFilter & UsbInterfaceFilter)[],\n    exclusionFilters?: readonly USBDeviceFilter[],\n): UsbInterfaceIdentifier | false;\nexport function matchFilters(\n    device: USBDevice,\n    filters: readonly USBDeviceFilter[],\n    exclusionFilters?: readonly USBDeviceFilter[],\n): boolean;\nexport function matchFilters(\n    device: USBDevice,\n    filters: readonly USBDeviceFilter[],\n    exclusionFilters?: readonly USBDeviceFilter[],\n): UsbInterfaceIdentifier | boolean {\n    if (exclusionFilters && exclusionFilters.length > 0) {\n        if (matchFilters(device, exclusionFilters)) {\n            return false;\n        }\n    }\n\n    for (const filter of filters) {\n        const result = matchFilter(device, filter);\n        if (result) {\n            return result;\n        }\n    }\n    return false;\n}\n", "import type {\n    AdbDaemonDevice,\n    AdbPacketData,\n    AdbPacketInit,\n} from \"@yume-chan/adb\";\nimport {\n    AdbPacketHeader,\n    AdbPacketSerializeStream,\n    toLocalUint8Array,\n    unreachable,\n} from \"@yume-chan/adb\";\nimport type {\n    Consumable,\n    ReadableWritablePair,\n    WritableStream,\n} from \"@yume-chan/stream-extra\";\nimport {\n    DuplexStreamFactory,\n    MaybeConsumable,\n    ReadableStream,\n    pipeFrom,\n} from \"@yume-chan/stream-extra\";\nimport { EmptyUint8Array, Uint8ArrayExactReadable } from \"@yume-chan/struct\";\n\nimport { DeviceBusyError as _DeviceBusyError } from \"./error.js\";\nimport type { UsbInterfaceFilter, UsbInterfaceIdentifier } from \"./utils.js\";\nimport { findUsbEndpoints, getSerialNumber, isErrorName } from \"./utils.js\";\n\n/**\n * The default filter for ADB devices, as defined by Google.\n */\nexport const AdbDefaultInterfaceFilter = {\n    classCode: 0xff,\n    subclassCode: 0x42,\n    protocolCode: 1,\n} as const satisfies UsbInterfaceFilter;\n\nexport function mergeDefaultAdbInterfaceFilter(\n    filters: readonly USBDeviceFilter[] | undefined,\n): (USBDeviceFilter & UsbInterfaceFilter)[] {\n    if (!filters || filters.length === 0) {\n        return [AdbDefaultInterfaceFilter];\n    } else {\n        return filters.map((filter) => ({\n            ...filter,\n            classCode: filter.classCode ?? AdbDefaultInterfaceFilter.classCode,\n            subclassCode:\n                filter.subclassCode ?? AdbDefaultInterfaceFilter.subclassCode,\n            protocolCode:\n                filter.protocolCode ?? AdbDefaultInterfaceFilter.protocolCode,\n        }));\n    }\n}\n\nexport class AdbDaemonWebUsbConnection\n    implements ReadableWritablePair<AdbPacketData, Consumable<AdbPacketInit>>\n{\n    readonly #device: AdbDaemonWebUsbDevice;\n    get device() {\n        return this.#device;\n    }\n\n    readonly #inEndpoint: USBEndpoint;\n    get inEndpoint() {\n        return this.#inEndpoint;\n    }\n\n    readonly #outEndpoint: USBEndpoint;\n    get outEndpoint() {\n        return this.#outEndpoint;\n    }\n\n    readonly #readable: ReadableStream<AdbPacketData>;\n    get readable() {\n        return this.#readable;\n    }\n\n    readonly #writable: WritableStream<Consumable<AdbPacketInit>>;\n    get writable() {\n        return this.#writable;\n    }\n\n    constructor(\n        device: AdbDaemonWebUsbDevice,\n        inEndpoint: USBEndpoint,\n        outEndpoint: USBEndpoint,\n        usbManager: USB,\n    ) {\n        this.#device = device;\n        this.#inEndpoint = inEndpoint;\n        this.#outEndpoint = outEndpoint;\n\n        let closed = false;\n\n        const duplex = new DuplexStreamFactory<\n            AdbPacketData,\n            Consumable<Uint8Array>\n        >({\n            close: async () => {\n                try {\n                    closed = true;\n                    await device.raw.close();\n                } catch {\n                    /* device may have already disconnected */\n                }\n            },\n            dispose: () => {\n                closed = true;\n                usbManager.removeEventListener(\n                    \"disconnect\",\n                    handleUsbDisconnect,\n                );\n            },\n        });\n\n        function handleUsbDisconnect(e: USBConnectionEvent) {\n            if (e.device === device.raw) {\n                duplex.dispose().catch(unreachable);\n            }\n        }\n\n        usbManager.addEventListener(\"disconnect\", handleUsbDisconnect);\n\n        this.#readable = duplex.wrapReadable(\n            new ReadableStream<AdbPacketData>(\n                {\n                    pull: async (controller) => {\n                        const packet = await this.#transferIn();\n                        if (packet) {\n                            controller.enqueue(packet);\n                        } else {\n                            controller.close();\n                        }\n                    },\n                },\n                { highWaterMark: 0 },\n            ),\n        );\n\n        const zeroMask = outEndpoint.packetSize - 1;\n        this.#writable = pipeFrom(\n            duplex.createWritable(\n                new MaybeConsumable.WritableStream({\n                    write: async (chunk) => {\n                        try {\n                            await device.raw.transferOut(\n                                outEndpoint.endpointNumber,\n                                toLocalUint8Array(chunk),\n                            );\n\n                            // In USB protocol, a not-full packet indicates the end of a transfer.\n                            // If the payload size is a multiple of the packet size,\n                            // we need to send an empty packet to indicate the end,\n                            // so the OS will send it to the device immediately.\n                            if (zeroMask && (chunk.length & zeroMask) === 0) {\n                                await device.raw.transferOut(\n                                    outEndpoint.endpointNumber,\n                                    EmptyUint8Array,\n                                );\n                            }\n                        } catch (e) {\n                            if (closed) {\n                                return;\n                            }\n                            throw e;\n                        }\n                    },\n                }),\n            ),\n            new AdbPacketSerializeStream(),\n        );\n    }\n\n    async #transferIn(): Promise<AdbPacketData | undefined> {\n        try {\n            while (true) {\n                // ADB daemon sends each packet in two parts, the 24-byte header and the payload.\n                const result = await this.#device.raw.transferIn(\n                    this.#inEndpoint.endpointNumber,\n                    this.#inEndpoint.packetSize,\n                );\n\n                if (result.data!.byteLength !== 24) {\n                    continue;\n                }\n\n                // Per spec, the `result.data` always covers the whole `buffer`.\n                const buffer = new Uint8Array(result.data!.buffer);\n                const stream = new Uint8ArrayExactReadable(buffer);\n\n                // Add `payload` field to its type, it's assigned below.\n                const packet = AdbPacketHeader.deserialize(\n                    stream,\n                ) as AdbPacketHeader & { payload: Uint8Array };\n\n                if (packet.magic !== (packet.command ^ 0xffffffff)) {\n                    continue;\n                }\n\n                if (packet.payloadLength !== 0) {\n                    const result = await this.#device.raw.transferIn(\n                        this.#inEndpoint.endpointNumber,\n                        packet.payloadLength,\n                    );\n                    packet.payload = new Uint8Array(result.data!.buffer);\n                } else {\n                    packet.payload = EmptyUint8Array;\n                }\n\n                return packet;\n            }\n        } catch (e) {\n            // On Windows, disconnecting the device will cause `NetworkError` to be thrown,\n            // even before the `disconnect` event is fired.\n            // Wait a little while and check if the device is still connected.\n            // https://github.com/WICG/webusb/issues/219\n            if (isErrorName(e, \"NetworkError\")) {\n                await new Promise<void>((resolve) => {\n                    setTimeout(() => {\n                        resolve();\n                    }, 100);\n                });\n\n                if (closed) {\n                    return undefined;\n                }\n            }\n\n            throw e;\n        }\n    }\n}\n\nexport class AdbDaemonWebUsbDevice implements AdbDaemonDevice {\n    static DeviceBusyError = _DeviceBusyError;\n\n    readonly #interface: UsbInterfaceIdentifier;\n    readonly #usbManager: USB;\n\n    readonly #raw: USBDevice;\n    get raw() {\n        return this.#raw;\n    }\n\n    readonly #serial: string;\n    get serial(): string {\n        return this.#serial;\n    }\n\n    get name(): string {\n        return this.#raw.productName!;\n    }\n\n    /**\n     * Create a new instance of `AdbDaemonWebUsbConnection` using a specified `USBDevice` instance\n     *\n     * @param device The `USBDevice` instance obtained elsewhere.\n     * @param filters The filters to use when searching for ADB interface. Defaults to {@link ADB_DEFAULT_DEVICE_FILTER}.\n     */\n    constructor(\n        device: USBDevice,\n        interface_: UsbInterfaceIdentifier,\n        usbManager: USB,\n    ) {\n        this.#raw = device;\n        this.#serial = getSerialNumber(device);\n        this.#interface = interface_;\n        this.#usbManager = usbManager;\n    }\n\n    async #claimInterface(): Promise<{\n        inEndpoint: USBEndpoint;\n        outEndpoint: USBEndpoint;\n    }> {\n        if (!this.#raw.opened) {\n            await this.#raw.open();\n        }\n\n        const { configuration, interface_, alternate } = this.#interface;\n\n        if (\n            this.#raw.configuration?.configurationValue !==\n            configuration.configurationValue\n        ) {\n            // Note: Switching configuration is not supported on Windows,\n            // but Android devices should always expose ADB function at the first (default) configuration.\n            await this.#raw.selectConfiguration(\n                configuration.configurationValue,\n            );\n        }\n\n        if (!interface_.claimed) {\n            try {\n                await this.#raw.claimInterface(interface_.interfaceNumber);\n            } catch (e) {\n                if (isErrorName(e, \"NetworkError\")) {\n                    throw new AdbDaemonWebUsbDevice.DeviceBusyError(e);\n                }\n\n                throw e;\n            }\n        }\n\n        if (\n            interface_.alternate.alternateSetting !== alternate.alternateSetting\n        ) {\n            await this.#raw.selectAlternateInterface(\n                interface_.interfaceNumber,\n                alternate.alternateSetting,\n            );\n        }\n\n        return findUsbEndpoints(alternate.endpoints);\n    }\n\n    /**\n     * Open the device and create a new connection to the ADB Daemon.\n     */\n    async connect(): Promise<AdbDaemonWebUsbConnection> {\n        const { inEndpoint, outEndpoint } = await this.#claimInterface();\n        return new AdbDaemonWebUsbConnection(\n            this,\n            inEndpoint,\n            outEndpoint,\n            this.#usbManager,\n        );\n    }\n}\n\nexport namespace AdbDaemonWebUsbDevice {\n    export type DeviceBusyError = _DeviceBusyError;\n}\n", "import type { DeviceObserver } from \"@yume-chan/adb\";\nimport { unorderedRemove } from \"@yume-chan/adb\";\nimport { EventEmitter, StickyEventEmitter } from \"@yume-chan/event\";\n\nimport {\n    AdbDaemonWebUsbDevice,\n    mergeDefaultAdbInterfaceFilter,\n} from \"./device.js\";\nimport type { AdbDaemonWebUsbDeviceManager } from \"./manager.js\";\nimport type { UsbInterfaceFilter } from \"./utils.js\";\nimport { matchFilters } from \"./utils.js\";\n\n/**\n * A watcher that listens for new WebUSB devices and notifies the callback when\n * a new device is connected or disconnected.\n */\nexport class AdbDaemonWebUsbDeviceObserver\n    implements DeviceObserver<AdbDaemonWebUsbDevice>\n{\n    static async create(\n        usb: USB,\n        options: AdbDaemonWebUsbDeviceManager.RequestDeviceOptions = {},\n    ) {\n        const devices = await usb.getDevices();\n        return new AdbDaemonWebUsbDeviceObserver(usb, devices, options);\n    }\n\n    readonly #filters: readonly (USBDeviceFilter & UsbInterfaceFilter)[];\n    readonly #exclusionFilters?: readonly USBDeviceFilter[] | undefined;\n    readonly #usbManager: USB;\n\n    readonly #onDeviceAdd = new EventEmitter<\n        readonly AdbDaemonWebUsbDevice[]\n    >();\n    onDeviceAdd = this.#onDeviceAdd.event;\n\n    readonly #onDeviceRemove = new EventEmitter<\n        readonly AdbDaemonWebUsbDevice[]\n    >();\n    onDeviceRemove = this.#onDeviceRemove.event;\n\n    readonly #onListChange = new StickyEventEmitter<\n        readonly AdbDaemonWebUsbDevice[]\n    >();\n    onListChange = this.#onListChange.event;\n\n    current: readonly AdbDaemonWebUsbDevice[] = [];\n\n    constructor(\n        usb: USB,\n        initial: USBDevice[],\n        options: AdbDaemonWebUsbDeviceManager.RequestDeviceOptions = {},\n    ) {\n        this.#filters = mergeDefaultAdbInterfaceFilter(options.filters);\n        this.#exclusionFilters = options.exclusionFilters;\n        this.#usbManager = usb;\n\n        this.current = initial\n            .map((device) => this.#convertDevice(device))\n            .filter((device) => !!device);\n        // Fire `onListChange` to set the sticky value\n        this.#onListChange.fire(this.current);\n\n        this.#usbManager.addEventListener(\"connect\", this.#handleConnect);\n        this.#usbManager.addEventListener(\"disconnect\", this.#handleDisconnect);\n    }\n\n    #convertDevice(device: USBDevice): AdbDaemonWebUsbDevice | undefined {\n        const interface_ = matchFilters(\n            device,\n            this.#filters,\n            this.#exclusionFilters,\n        );\n        if (!interface_) {\n            return undefined;\n        }\n\n        return new AdbDaemonWebUsbDevice(device, interface_, this.#usbManager);\n    }\n\n    #handleConnect = (e: USBConnectionEvent) => {\n        const device = this.#convertDevice(e.device);\n        if (!device) {\n            return;\n        }\n\n        // We send a `connect` event on `requestDevice` success,\n        // but this device might already exist if we already have the permission for it.\n        if (this.current.some((item) => item.raw === device.raw)) {\n            return;\n        }\n\n        const next = this.current.slice();\n        next.push(device);\n        this.current = next;\n\n        this.#onDeviceAdd.fire([device]);\n        this.#onListChange.fire(this.current);\n    };\n\n    #handleDisconnect = (e: USBConnectionEvent) => {\n        const index = this.current.findIndex(\n            (device) => device.raw === e.device,\n        );\n        if (index !== -1) {\n            const device = this.current[index]!;\n\n            const next = this.current.slice();\n            unorderedRemove(next, index);\n            this.current = next;\n\n            this.#onDeviceRemove.fire([device]);\n            this.#onListChange.fire(this.current);\n        }\n    };\n\n    stop(): void {\n        this.#usbManager.removeEventListener(\"connect\", this.#handleConnect);\n        this.#usbManager.removeEventListener(\n            \"disconnect\",\n            this.#handleDisconnect,\n        );\n\n        this.#onDeviceAdd.dispose();\n        this.#onDeviceRemove.dispose();\n        this.#onListChange.dispose();\n    }\n}\n", "import {\n    AdbDaemonWebUsbDevice,\n    mergeDefaultAdbInterfaceFilter,\n} from \"./device.js\";\nimport { AdbDaemonWebUsbDeviceObserver } from \"./observer.js\";\nimport { isErrorName, matchFilters } from \"./utils.js\";\n\nexport namespace AdbDaemonWebUsbDeviceManager {\n    export interface RequestDeviceOptions {\n        filters?: readonly USBDeviceFilter[] | undefined;\n        exclusionFilters?: readonly USBDeviceFilter[] | undefined;\n    }\n}\n\nexport class AdbDaemonWebUsbDeviceManager {\n    /**\n     * Gets the instance of {@link AdbDaemonWebUsbDeviceManager} using browser WebUSB implementation.\n     *\n     * May be `undefined` if current runtime does not support WebUSB.\n     */\n    static readonly BROWSER = /* #__PURE__ */ (() =>\n        typeof globalThis.navigator !== \"undefined\" && globalThis.navigator.usb\n            ? new AdbDaemonWebUsbDeviceManager(globalThis.navigator.usb)\n            : undefined)();\n\n    readonly #usbManager: USB;\n\n    /**\n     * Create a new instance of {@link AdbDaemonWebUsbDeviceManager} using the specified WebUSB implementation.\n     * @param usbManager A WebUSB compatible interface.\n     */\n    constructor(usbManager: USB) {\n        this.#usbManager = usbManager;\n    }\n\n    /**\n     * Call `USB#requestDevice()` to prompt the user to select a device.\n     */\n    async requestDevice(\n        options: AdbDaemonWebUsbDeviceManager.RequestDeviceOptions = {},\n    ): Promise<AdbDaemonWebUsbDevice | undefined> {\n        const filters = mergeDefaultAdbInterfaceFilter(options.filters);\n\n        try {\n            const device = await this.#usbManager.requestDevice({\n                filters,\n                exclusionFilters: options.exclusionFilters as USBDeviceFilter[],\n            });\n\n            const interface_ = matchFilters(\n                device,\n                filters,\n                options.exclusionFilters,\n            );\n            if (!interface_) {\n                // `#usbManager` doesn't support `exclusionFilters`,\n                // selected device is invalid\n                return undefined;\n            }\n\n            // If this `requestDevice` adds a new device,\n            // Chrome won't fire a `connect` event for it.\n            // This will cause device observer to lose track of it,\n            // and when the device disconnects, device observer won't fire the disconnect event for it.\n            this.#usbManager.dispatchEvent(\n                new USBConnectionEvent(\"connect\", { device }),\n            );\n\n            return new AdbDaemonWebUsbDevice(\n                device,\n                interface_,\n                this.#usbManager,\n            );\n        } catch (e) {\n            // No device selected\n            if (isErrorName(e, \"NotFoundError\")) {\n                return undefined;\n            }\n\n            throw e;\n        }\n    }\n\n    /**\n     * Get all connected and requested devices that match the specified filters.\n     */\n    async getDevices(\n        options: AdbDaemonWebUsbDeviceManager.RequestDeviceOptions = {},\n    ): Promise<AdbDaemonWebUsbDevice[]> {\n        const filters = mergeDefaultAdbInterfaceFilter(options.filters);\n\n        const devices = await this.#usbManager.getDevices();\n        // filter map\n        const result: AdbDaemonWebUsbDevice[] = [];\n        for (const device of devices) {\n            const interface_ = matchFilters(\n                device,\n                filters,\n                options.exclusionFilters,\n            );\n            if (interface_) {\n                result.push(\n                    new AdbDaemonWebUsbDevice(\n                        device,\n                        interface_,\n                        this.#usbManager,\n                    ),\n                );\n            }\n        }\n\n        return result;\n    }\n\n    trackDevices(\n        options: AdbDaemonWebUsbDeviceManager.RequestDeviceOptions = {},\n    ): Promise<AdbDaemonWebUsbDeviceObserver> {\n        return AdbDaemonWebUsbDeviceObserver.create(this.#usbManager, options);\n    }\n}\n"],
  "mappings": "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",
  "names": ["value", "result", "buffer", "field", "deserialize", "init", "buffer", "field", "context", "index", "size", "buffer", "buffer", "buffer", "buffer", "buffer", "buffer", "ReadableStream", "chunk", "chunk", "chunk", "chunk", "chunk", "closed", "buffer", "result", "_usbManager", "_usbManager"]
}
