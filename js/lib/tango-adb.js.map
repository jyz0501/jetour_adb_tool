{
  "version": 3,
  "sources": ["../../node_modules/@yume-chan/adb/src/index.ts", "../../node_modules/@yume-chan/stream-extra/src/index.ts", "../../node_modules/@yume-chan/async/src/promise-resolver.ts", "../../node_modules/@yume-chan/async/src/async-operation-manager.ts", "../../node_modules/@yume-chan/async/src/delay.ts", "../../node_modules/@yume-chan/async/src/maybe-promise.ts", "../../node_modules/@yume-chan/struct/src/bipedal.ts", "../../node_modules/@yume-chan/struct/src/field/serialize.ts", "../../node_modules/@yume-chan/struct/src/field/factory.ts", "../../node_modules/@yume-chan/struct/src/buffer.ts", "../../node_modules/@yume-chan/struct/src/readable.ts", "../../node_modules/@yume-chan/struct/src/struct.ts", "../../node_modules/@yume-chan/struct/src/extend.ts", "../../node_modules/@yume-chan/no-data-view/src/int32.ts", "../../node_modules/@yume-chan/no-data-view/src/int64.ts", "../../node_modules/@yume-chan/no-data-view/src/uint32.ts", "../../node_modules/@yume-chan/no-data-view/src/uint64.ts", "../../node_modules/@yume-chan/struct/src/number.ts", "../../node_modules/@yume-chan/struct/src/utils.ts", "../../node_modules/@yume-chan/struct/src/string.ts", "../../node_modules/@yume-chan/stream-extra/src/stream.ts", "../../node_modules/@yume-chan/stream-extra/src/push-readable.ts", "../../node_modules/@yume-chan/stream-extra/src/try-close.ts", "../../node_modules/@yume-chan/stream-extra/src/buffered.ts", "../../node_modules/@yume-chan/stream-extra/src/buffered-transform.ts", "../../node_modules/@yume-chan/stream-extra/src/concat.ts", "../../node_modules/@yume-chan/stream-extra/src/consumable/readable.ts", "../../node_modules/@yume-chan/stream-extra/src/consumable/wrap-byte-readable.ts", "../../node_modules/@yume-chan/stream-extra/src/consumable/wrap-writable.ts", "../../node_modules/@yume-chan/stream-extra/src/consumable/writable.ts", "../../node_modules/@yume-chan/stream-extra/src/task.ts", "../../node_modules/@yume-chan/stream-extra/src/consumable.ts", "../../node_modules/@yume-chan/stream-extra/src/maybe-consumable/index.ts", "../../node_modules/@yume-chan/stream-extra/src/maybe-consumable/utils.ts", "../../node_modules/@yume-chan/stream-extra/src/maybe-consumable/wrap-writable.ts", "../../node_modules/@yume-chan/stream-extra/src/maybe-consumable/writable.ts", "../../node_modules/@yume-chan/stream-extra/src/distribution.ts", "../../node_modules/@yume-chan/stream-extra/src/wrap-readable.ts", "../../node_modules/@yume-chan/stream-extra/src/duplex.ts", "../../node_modules/@yume-chan/stream-extra/src/encoding.ts", "../../node_modules/@yume-chan/stream-extra/src/inspect.ts", "../../node_modules/@yume-chan/stream-extra/src/pipe-from.ts", "../../node_modules/@yume-chan/stream-extra/src/split-string.ts", "../../node_modules/@yume-chan/stream-extra/src/struct-deserialize.ts", "../../node_modules/@yume-chan/stream-extra/src/struct-serialize.ts", "../../node_modules/@yume-chan/stream-extra/src/wrap-writable.ts", "../../node_modules/@yume-chan/event/src/disposable.ts", "../../node_modules/@yume-chan/event/src/event-emitter.ts", "../../node_modules/@yume-chan/event/src/sticky-event-emitter.ts", "../../node_modules/@yume-chan/adb/src/commands/base.ts", "../../node_modules/@yume-chan/adb/src/commands/framebuffer.ts", "../../node_modules/@yume-chan/adb/src/commands/power.ts", "../../node_modules/@yume-chan/adb/src/utils/array-buffer.ts", "../../node_modules/@yume-chan/adb/src/utils/auto-reset-event.ts", "../../node_modules/@yume-chan/adb/src/utils/base64.ts", "../../node_modules/@yume-chan/adb/src/utils/hex.ts", "../../node_modules/@yume-chan/adb/src/utils/no-op.ts", "../../node_modules/@yume-chan/adb/src/utils/ref.ts", "../../node_modules/@yume-chan/adb/src/utils/sequence-equal.ts", "../../node_modules/@yume-chan/adb/src/commands/reverse.ts", "../../node_modules/@yume-chan/adb/src/commands/subprocess/none/process.ts", "../../node_modules/@yume-chan/adb/src/commands/subprocess/none/pty.ts", "../../node_modules/@yume-chan/adb/src/commands/subprocess/utils.ts", "../../node_modules/@yume-chan/adb/src/commands/subprocess/none/spawner.ts", "../../node_modules/@yume-chan/adb/src/commands/subprocess/none/service.ts", "../../node_modules/@yume-chan/adb/src/features.ts", "../../node_modules/@yume-chan/adb/src/commands/subprocess/shell/shared.ts", "../../node_modules/@yume-chan/adb/src/commands/subprocess/shell/process.ts", "../../node_modules/@yume-chan/adb/src/commands/subprocess/shell/pty.ts", "../../node_modules/@yume-chan/adb/src/commands/subprocess/shell/spawner.ts", "../../node_modules/@yume-chan/adb/src/commands/subprocess/shell/service.ts", "../../node_modules/@yume-chan/adb/src/commands/subprocess/service.ts", "../../node_modules/@yume-chan/adb/src/commands/sync/response.ts", "../../node_modules/@yume-chan/adb/src/commands/sync/request.ts", "../../node_modules/@yume-chan/adb/src/commands/sync/stat.ts", "../../node_modules/@yume-chan/adb/src/commands/sync/list.ts", "../../node_modules/@yume-chan/adb/src/commands/sync/pull.ts", "../../node_modules/@yume-chan/adb/src/commands/sync/push.ts", "../../node_modules/@yume-chan/adb/src/commands/sync/socket.ts", "../../node_modules/@yume-chan/adb/src/commands/sync/sync.ts", "../../node_modules/@yume-chan/adb/src/commands/tcpip.ts", "../../node_modules/@yume-chan/adb/src/adb.ts", "../../node_modules/@yume-chan/adb/src/banner.ts", "../../node_modules/@yume-chan/adb/src/daemon/crypto.ts", "../../node_modules/@yume-chan/adb/src/daemon/packet.ts", "../../node_modules/@yume-chan/adb/src/daemon/auth.ts", "../../node_modules/@yume-chan/adb/src/daemon/socket.ts", "../../node_modules/@yume-chan/adb/src/daemon/dispatcher.ts", "../../node_modules/@yume-chan/adb/src/daemon/transport.ts", "../../node_modules/@yume-chan/adb/src/server/commands/m-dns.ts", "../../node_modules/@yume-chan/adb/src/server/stream.ts", "../../node_modules/@yume-chan/adb/src/server/commands/wireless.ts", "../../node_modules/@yume-chan/adb/src/server/observer.ts", "../../node_modules/@yume-chan/adb/src/server/transport.ts", "../../node_modules/@yume-chan/adb/src/server/client.ts", "../../node_modules/@yume-chan/adb-daemon-webusb/src/index.ts", "../../node_modules/@yume-chan/adb-daemon-webusb/src/error.ts", "../../node_modules/@yume-chan/adb-daemon-webusb/src/utils.ts", "../../node_modules/@yume-chan/adb-daemon-webusb/src/device.ts", "../../node_modules/@yume-chan/adb-daemon-webusb/src/observer.ts", "../../node_modules/@yume-chan/adb-daemon-webusb/src/manager.ts", "../../node_modules/@yume-chan/adb-credential-web/src/index.ts", "../tango-entry.js"],
  "sourcesContent": ["export * from \"./adb.js\";\nexport * from \"./banner.js\";\nexport * from \"./commands/index.js\";\nexport * from \"./daemon/index.js\";\nexport * from \"./device-observer.js\";\nexport * from \"./features.js\";\nexport * from \"./server/index.js\";\nexport * from \"./utils/index.js\";\n", "export * from \"./buffered-transform.js\";\nexport * from \"./buffered.js\";\nexport * from \"./concat.js\";\nexport * from \"./consumable.js\";\nexport * from \"./distribution.js\";\nexport * from \"./duplex.js\";\nexport * from \"./encoding.js\";\nexport * from \"./inspect.js\";\nexport * from \"./maybe-consumable.js\";\nexport * from \"./pipe-from.js\";\nexport * from \"./push-readable.js\";\nexport * from \"./split-string.js\";\nexport * from \"./stream.js\";\nexport * from \"./struct-deserialize.js\";\nexport * from \"./struct-serialize.js\";\nexport * from \"./task.js\";\nexport * from \"./try-close.js\";\nexport * from \"./wrap-readable.js\";\nexport * from \"./wrap-writable.js\";\n", "export type PromiseResolverState = 'running' | 'resolved' | 'rejected';\n\nexport class PromiseResolver<T> {\n    #promise: Promise<T>;\n    public get promise(): Promise<T> { return this.#promise; }\n\n    #resolve!: (value: T | PromiseLike<T>) => void;\n    #reject!: (reason?: any) => void;\n\n    #state: PromiseResolverState = 'running';\n    public get state(): PromiseResolverState { return this.#state; }\n\n    public constructor() {\n        this.#promise = new Promise<T>((resolve, reject) => {\n            this.#resolve = resolve;\n            this.#reject = reject;\n        });\n    }\n\n    public resolve = (value: T | PromiseLike<T>): void => {\n        this.#resolve(value);\n        this.#state = 'resolved';\n    };\n\n    public reject = (reason?: any): void => {\n        this.#reject(reason);\n        this.#state = 'rejected';\n    };\n}\n", "import { PromiseResolver } from \"./promise-resolver.js\";\n\nexport class AsyncOperationManager {\n    private nextId: number;\n\n    private pendingResolvers: Map<number, PromiseResolver<any>> = new Map();\n\n    public constructor(startId: number = 0) {\n        this.nextId = startId;\n    }\n\n    public add<T>(): [id: number, promise: Promise<T>] {\n        const id = this.nextId++;\n        const resolver = new PromiseResolver<T>();\n        this.pendingResolvers.set(id, resolver);\n        return [id, resolver.promise];\n    }\n\n    private getResolver(id: number): PromiseResolver<unknown> | null {\n        if (!this.pendingResolvers.has(id)) {\n            return null;\n        }\n\n        const resolver = this.pendingResolvers.get(id)!;\n        this.pendingResolvers.delete(id);\n        return resolver;\n    }\n\n    public resolve<T>(id: number, result: T): boolean {\n        const resolver = this.getResolver(id);\n        if (resolver !== null) {\n            resolver.resolve(result);\n            return true;\n        }\n        return false;\n    }\n\n    public reject(id: number, reason: Error): boolean {\n        const resolver = this.getResolver(id);\n        if (resolver !== null) {\n            resolver.reject(reason);\n            return true;\n        }\n        return false;\n    }\n}\n", "export function delay(time: number): Promise<void> {\n    return new Promise<void>(resolve => {\n        // Don't call `resolve` with any value.\n        (globalThis as any).setTimeout(() => resolve(), time);\n    });\n}\n", "export type MaybePromise<T> = T | Promise<T>;\n\nexport type MaybePromiseLike<T> = T | PromiseLike<T>;\n\nexport function isPromiseLike<T>(value: unknown): value is PromiseLike<T> {\n    return typeof value === \"object\" && value !== null && \"then\" in value;\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport { isPromiseLike } from \"@yume-chan/async\";\n\nfunction advance<T>(\n    iterator: Iterator<unknown, T, unknown>,\n    next: unknown,\n): MaybePromiseLike<T> {\n    while (true) {\n        const { done, value } = iterator.next(next);\n        if (done) {\n            return value;\n        }\n        if (isPromiseLike(value)) {\n            return value.then(\n                (value) => advance(iterator, { resolved: value }),\n                (error: unknown) => advance(iterator, { error }),\n            );\n        }\n        next = value;\n    }\n}\n\nexport type BipedalGenerator<This, T, A extends unknown[]> = (\n    this: This,\n    then: <U>(value: MaybePromiseLike<U>) => Iterable<unknown, U, unknown>,\n    ...args: A\n) => Generator<unknown, T, unknown>;\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function bipedal<This, T, A extends unknown[]>(\n    fn: BipedalGenerator<This, T, A>,\n    bindThis?: This,\n): { (this: This, ...args: A): MaybePromiseLike<T> } {\n    function result(this: This, ...args: A): MaybePromiseLike<T> {\n        const iterator = fn.call(\n            this,\n            function* <U>(\n                value: MaybePromiseLike<U>,\n            ): Generator<\n                PromiseLike<U>,\n                U,\n                { resolved: U } | { error: unknown }\n            > {\n                if (isPromiseLike(value)) {\n                    const result = yield value;\n                    if (\"resolved\" in result) {\n                        return result.resolved;\n                    } else {\n                        throw result.error;\n                    }\n                }\n\n                return value;\n            },\n            ...args,\n        ) as never;\n        return advance(iterator, undefined);\n    }\n\n    if (bindThis) {\n        return result.bind(bindThis);\n    } else {\n        return result;\n    }\n}\n", "import type {\n    FieldByobSerializeContext,\n    FieldDefaultSerializeContext,\n    FieldSerializer,\n} from \"./types.js\";\n\nexport type DefaultFieldSerializer<T> = (\n    source: T,\n    context: FieldDefaultSerializeContext,\n) => Uint8Array;\n\n/* Adapt default field serializer to universal field serializer */\nexport function defaultFieldSerializer<T>(\n    serializer: DefaultFieldSerializer<T>,\n): FieldSerializer<T>[\"serialize\"] {\n    return (\n        source,\n        context: FieldDefaultSerializeContext | FieldByobSerializeContext,\n    ): never => {\n        if (\"buffer\" in context) {\n            const buffer = serializer(source, context);\n            context.buffer.set(buffer, context.index);\n            return buffer.length as never;\n        } else {\n            return serializer(source, context) as never;\n        }\n    };\n}\n\nexport type ByobFieldSerializer<T> = (\n    source: T,\n    context: FieldByobSerializeContext & { index: number },\n) => void;\n\n/* Adapt byob field serializer to universal field serializer */\nexport function byobFieldSerializer<T>(\n    size: number,\n    serializer: ByobFieldSerializer<T>,\n): FieldSerializer<T>[\"serialize\"] {\n    return (\n        source,\n        context: FieldDefaultSerializeContext | FieldByobSerializeContext,\n    ): never => {\n        if (\"buffer\" in context) {\n            context.index ??= 0;\n            serializer(source, context as never);\n            return size as never;\n        } else {\n            const buffer = new Uint8Array(size);\n            serializer(source, {\n                buffer,\n                index: 0,\n                littleEndian: context.littleEndian,\n            });\n            return buffer as never;\n        }\n    };\n}\n", "import type { BipedalGenerator } from \"../bipedal.js\";\nimport { bipedal } from \"../bipedal.js\";\nimport type { AsyncExactReadable } from \"../readable.js\";\n\nimport type {\n    ByobFieldSerializer,\n    DefaultFieldSerializer,\n} from \"./serialize.js\";\nimport { byobFieldSerializer, defaultFieldSerializer } from \"./serialize.js\";\nimport type { Field, FieldDeserializeContext, FieldOptions } from \"./types.js\";\n\nexport type BipedalFieldDeserializer<T, D> = BipedalGenerator<\n    undefined,\n    T,\n    [reader: AsyncExactReadable, context: FieldDeserializeContext<D>]\n>;\n\n// eslint-disable-next-line @typescript-eslint/max-params\nfunction _field<T, OmitInit extends string, D, Raw = T>(\n    size: number,\n    type: \"default\",\n    serialize: DefaultFieldSerializer<Raw>,\n    deserialize: BipedalFieldDeserializer<T, D>,\n    options?: FieldOptions<T, OmitInit, D, Raw>,\n): Field<T, OmitInit, D, Raw>;\n// eslint-disable-next-line @typescript-eslint/max-params\nfunction _field<T, OmitInit extends string, D, Raw = T>(\n    size: number,\n    type: \"byob\",\n    serialize: ByobFieldSerializer<Raw>,\n    deserialize: BipedalFieldDeserializer<T, D>,\n    options?: FieldOptions<T, OmitInit, D, Raw>,\n): Field<T, OmitInit, D, Raw>;\n/* #__NO_SIDE_EFFECTS__ */\n// eslint-disable-next-line @typescript-eslint/max-params\nfunction _field<T, OmitInit extends string, D, Raw = T>(\n    size: number,\n    type: \"default\" | \"byob\",\n    serialize: DefaultFieldSerializer<Raw> | ByobFieldSerializer<Raw>,\n    deserialize: BipedalFieldDeserializer<T, D>,\n    options?: FieldOptions<T, OmitInit, D, Raw>,\n): Field<T, OmitInit, D, Raw> {\n    const field: Field<T, OmitInit, D, Raw> = {\n        size,\n        type: type,\n        serialize:\n            type === \"default\"\n                ? defaultFieldSerializer(\n                      serialize as DefaultFieldSerializer<Raw>,\n                  )\n                : byobFieldSerializer(\n                      size,\n                      serialize as ByobFieldSerializer<Raw>,\n                  ),\n        deserialize: bipedal(deserialize) as never,\n        omitInit: options?.omitInit,\n    };\n    if (options?.init) {\n        field.init = options.init;\n    }\n    return field;\n}\n\nexport const field = _field;\n", "import type {\n    BipedalFieldDeserializer,\n    ByobFieldSerializer,\n    Field,\n} from \"./field/index.js\";\nimport { field } from \"./field/index.js\";\n\nexport const EmptyUint8Array = new Uint8Array(0);\n\nfunction copyMaybeDifferentLength(\n    dest: Uint8Array,\n    source: Uint8Array,\n    index: number,\n    length: number,\n) {\n    if (source.length < length) {\n        dest.set(source, index);\n        // Clear trailing bytes\n        dest.fill(0, index + source.length, index + length);\n    } else if (source.length === length) {\n        dest.set(source, index);\n    } else {\n        dest.set(source.subarray(0, length), index);\n    }\n}\n\nexport interface Converter<From, To> {\n    convert: (value: From) => To;\n    back: (value: To) => From;\n}\n\nexport interface BufferLengthConverter<K, KT> extends Converter<KT, number> {\n    field: K;\n}\n\n/**\n * Create a fixed-length `Uint8Array` field.\n *\n * @param length Length of the field\n */\nexport function buffer(\n    length: number,\n): Field<Uint8Array, never, never, Uint8Array>;\n/**\n * Create a custom-typed field, backed by a fixed-length `Uint8Array`.\n *\n * @param length Length of the field\n * @param converter A value converter to convert between `Uint8Array` and the target type\n */\nexport function buffer<U>(\n    length: number,\n    converter: Converter<Uint8Array, U>,\n): Field<U, never, never, Uint8Array>;\n\n/**\n * Create a variable-length `Uint8Array` field.\n * The length is determined by another number-typed field.\n *\n * @param lengthField Name of the length field. Must be declared before this field\n */\nexport function buffer<K extends string>(\n    lengthField: K,\n): Field<Uint8Array, K, Record<K, number>, Uint8Array>;\n/**\n * Create a custom-typed field, backed by a variable-length `Uint8Array`.\n * The length is determined by another number-typed field.\n *\n * @param lengthField Name of the length field. Must be declared before this field\n * @param converter A value converter to convert between `Uint8Array` and the target type\n */\nexport function buffer<K extends string, U>(\n    lengthField: K,\n    converter: Converter<Uint8Array, U>,\n): Field<U, K, Record<K, number>, Uint8Array>;\n\n/**\n * Create a variable-length `Uint8Array` field.\n * The length is determined by converting another field to `number`.\n *\n * @param length\n * Name of the length field,\n * and a converter to convert between source type and `number`.\n * Must be declared before this field\n */\nexport function buffer<K extends string, KT>(\n    length: BufferLengthConverter<K, KT>,\n): Field<Uint8Array, K, Record<K, KT>, Uint8Array>;\n/**\n * Create a custom-typed field, backed by a variable-length `Uint8Array`.\n * The length is determined by converting another field to `number`.\n *\n * @param length\n * Name of the length field,\n * and a converter to convert between source type and `number`.\n * Must be declared before this field\n * @param converter\n * A value converter to convert between `Uint8Array` and the target type\n */\nexport function buffer<K extends string, KT, U>(\n    length: BufferLengthConverter<K, KT>,\n    converter: Converter<Uint8Array, U>,\n): Field<U, K, Record<K, KT>, Uint8Array>;\n\n/**\n * Create a length field, and a variable-length `Uint8Array` field.\n * This is a shortcut when the length field is directly before the data field.\n *\n * @param length The length field declaration\n */\nexport function buffer<LengthOmitInit extends string, LengthDependencies>(\n    length: Field<number, LengthOmitInit, LengthDependencies, number>,\n): Field<Uint8Array, LengthOmitInit, LengthDependencies, Uint8Array>;\n/**\n * Create a length field, and a custom-typed field, backed by a variable-length `Uint8Array`.\n * This is a shortcut when the length field is directly before the data field.\n *\n * @param length The length field declaration\n * @param converter A value converter to convert between `Uint8Array` and the target type\n */\nexport function buffer<LengthOmitInit extends string, LengthDependencies, U>(\n    length: Field<number, LengthOmitInit, LengthDependencies, number>,\n    converter: Converter<Uint8Array, U>,\n): Field<U, LengthOmitInit, LengthDependencies, Uint8Array>;\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function buffer(\n    lengthOrField:\n        | string\n        | number\n        | Field<number, string, unknown, number>\n        | BufferLengthConverter<string, unknown>,\n    converter?: Converter<Uint8Array, unknown>,\n): Field<unknown, string, Record<string, unknown>, Uint8Array> {\n    // Fixed length\n    if (typeof lengthOrField === \"number\") {\n        let serialize: ByobFieldSerializer<Uint8Array>;\n        let deserialize: BipedalFieldDeserializer<\n            unknown,\n            Record<string, unknown>\n        >;\n        let init: ((value: unknown) => Uint8Array) | undefined;\n\n        if (lengthOrField === 0) {\n            serialize = () => {};\n\n            if (converter) {\n                // eslint-disable-next-line require-yield\n                deserialize = function* () {\n                    return converter.convert(EmptyUint8Array);\n                };\n            } else {\n                // eslint-disable-next-line require-yield\n                deserialize = function* () {\n                    return EmptyUint8Array;\n                };\n            }\n        } else {\n            serialize = (value, { buffer, index }) =>\n                copyMaybeDifferentLength(buffer, value, index, lengthOrField);\n\n            if (converter) {\n                deserialize = function* (then, reader) {\n                    const array = reader.readExactly(lengthOrField);\n                    return converter.convert(yield* then(array));\n                };\n                init = (value) => converter.back(value);\n            } else {\n                // eslint-disable-next-line require-yield\n                deserialize = function* (_then, reader) {\n                    const array = reader.readExactly(lengthOrField);\n                    return array;\n                };\n            }\n        }\n\n        return field(lengthOrField, \"byob\", serialize, deserialize, { init });\n    }\n\n    // Declare length field\n    // Some field types are `function`s\n    if (\n        (typeof lengthOrField === \"object\" ||\n            typeof lengthOrField === \"function\") &&\n        \"serialize\" in lengthOrField\n    ) {\n        let deserialize: BipedalFieldDeserializer<\n            unknown,\n            Record<string, unknown>\n        >;\n        let init: ((value: unknown) => Uint8Array) | undefined;\n\n        if (converter) {\n            deserialize = function* (then, reader, context) {\n                const length = yield* then(\n                    lengthOrField.deserialize(reader, context),\n                );\n                const array =\n                    length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n                return converter.convert(yield* then(array));\n            };\n            init = (value) => converter.back(value);\n        } else {\n            deserialize = function* (then, reader, context) {\n                const length = yield* then(\n                    lengthOrField.deserialize(reader, context),\n                );\n                const array =\n                    length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n                return array;\n            };\n        }\n\n        return field(\n            lengthOrField.size,\n            \"default\",\n            (value, { littleEndian }) => {\n                if (lengthOrField.type === \"default\") {\n                    const lengthBuffer = lengthOrField.serialize(value.length, {\n                        littleEndian,\n                    });\n\n                    if (value.length === 0) {\n                        return lengthBuffer;\n                    }\n\n                    const result = new Uint8Array(\n                        lengthBuffer.length + value.length,\n                    );\n                    result.set(lengthBuffer, 0);\n                    result.set(value, lengthBuffer.length);\n                    return result;\n                } else {\n                    const result = new Uint8Array(\n                        lengthOrField.size + value.length,\n                    );\n                    lengthOrField.serialize(value.length, {\n                        buffer: result,\n                        index: 0,\n                        littleEndian,\n                    });\n                    result.set(value, lengthOrField.size);\n                    return result;\n                }\n            },\n            deserialize,\n            { init },\n        );\n    }\n\n    // Reference existing length field\n    if (typeof lengthOrField === \"string\") {\n        let deserialize: BipedalFieldDeserializer<\n            unknown,\n            Record<string, unknown>\n        >;\n        let init: (\n            value: unknown,\n            dependencies: Record<string, unknown>,\n        ) => Uint8Array;\n\n        if (converter) {\n            deserialize = function* (then, reader, { dependencies }) {\n                const length = dependencies[lengthOrField] as number;\n                const array =\n                    length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n                return converter.convert(yield* then(array));\n            };\n            init = (value, dependencies) => {\n                const array = converter.back(value);\n                dependencies[lengthOrField] = array.length;\n                return array;\n            };\n        } else {\n            // eslint-disable-next-line require-yield\n            deserialize = function* (_then, reader, { dependencies }) {\n                const length = dependencies[lengthOrField] as number;\n                const array =\n                    length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n                return array;\n            };\n            init = (value, dependencies) => {\n                const array = value as Uint8Array;\n                dependencies[lengthOrField] = array.length;\n                return array;\n            };\n        }\n\n        return field(0, \"default\", (source) => source, deserialize, { init });\n    }\n\n    let deserialize: BipedalFieldDeserializer<unknown, Record<string, unknown>>;\n    let init: (\n        value: unknown,\n        dependencies: Record<string, unknown>,\n    ) => Uint8Array;\n\n    // Reference existing length field + length converter\n    if (converter) {\n        deserialize = function* (then, reader, { dependencies }) {\n            const rawLength = dependencies[lengthOrField.field];\n            const length = lengthOrField.convert(rawLength);\n            const array =\n                length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n            return converter.convert(yield* then(array));\n        };\n        init = (value, dependencies) => {\n            const array = converter.back(value);\n            dependencies[lengthOrField.field] = lengthOrField.back(\n                array.length,\n            );\n            return array;\n        };\n    } else {\n        // eslint-disable-next-line require-yield\n        deserialize = function* (_then, reader, { dependencies }) {\n            const rawLength = dependencies[lengthOrField.field];\n            const length = lengthOrField.convert(rawLength);\n            const array =\n                length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n            return array;\n        };\n        init = (value, dependencies) => {\n            const array = value as Uint8Array;\n            dependencies[lengthOrField.field] = lengthOrField.back(\n                array.length,\n            );\n            return array;\n        };\n    }\n\n    return field(0, \"default\", (source) => source, deserialize, { init });\n}\n", "// TODO: allow over reading (returning a `Uint8Array`, an `offset` and a `length`) to avoid copying\n\nimport type { MaybePromiseLike } from \"@yume-chan/async\";\n\nexport class ExactReadableEndedError extends Error {\n    constructor() {\n        super(\"ExactReadable ended\");\n    }\n}\n\nexport interface ExactReadable {\n    readonly position: number;\n\n    /**\n     * Read data from the underlying data source.\n     *\n     * The stream must return exactly `length` bytes or data. If that's not possible\n     * (due to end of file or other error condition), it must throw an {@link ExactReadableEndedError}.\n     */\n    readExactly(length: number): Uint8Array;\n}\n\nexport class Uint8ArrayExactReadable implements ExactReadable {\n    #data: Uint8Array;\n    #position: number;\n\n    get position() {\n        return this.#position;\n    }\n\n    constructor(data: Uint8Array) {\n        this.#data = data;\n        this.#position = 0;\n    }\n\n    readExactly(length: number): Uint8Array {\n        if (this.#position + length > this.#data.length) {\n            throw new ExactReadableEndedError();\n        }\n\n        const result = this.#data.subarray(\n            this.#position,\n            this.#position + length,\n        );\n\n        this.#position += length;\n        return result;\n    }\n}\n\nexport interface AsyncExactReadable {\n    readonly position: number;\n\n    /**\n     * Read data from the underlying data source.\n     *\n     * The stream must return exactly `length` bytes or data. If that's not possible\n     * (due to end of file or other error condition), it must throw an {@link ExactReadableEndedError}.\n     */\n    readExactly(length: number): MaybePromiseLike<Uint8Array>;\n}\n", "import { bipedal } from \"./bipedal.js\";\nimport type {\n    Field,\n    FieldByobSerializeContext,\n    FieldDefaultSerializeContext,\n    FieldDeserializeContext,\n    FieldDeserializer,\n} from \"./field/index.js\";\nimport type { AsyncExactReadable } from \"./readable.js\";\nimport { ExactReadableEndedError } from \"./readable.js\";\nimport type {\n    StructDeserializer,\n    StructLike,\n    StructSerializeContext,\n    StructSerializer,\n} from \"./types.js\";\n\nexport type StructField =\n    | Field<unknown, string, unknown, unknown>\n    | (StructSerializer<unknown> & StructDeserializer<unknown>);\n\nexport type StructFields = Record<string, StructField>;\n\nexport type FieldsValue<T extends StructFields> = {\n    [K in keyof T]: T[K] extends FieldDeserializer<infer U, unknown>\n        ? U\n        : never;\n};\n\nexport type FieldOmitInit<T extends StructField> =\n    T extends Field<unknown, infer U, unknown, unknown>\n        ? string extends U\n            ? never\n            : U\n        : never;\n\nexport type FieldsOmitInits<T extends StructFields> = {\n    [K in keyof T]: FieldOmitInit<T[K]>;\n}[keyof T];\n\nexport type FieldsInit<T extends StructFields> = Omit<\n    FieldsValue<T>,\n    FieldsOmitInits<T>\n>;\n\nexport class StructDeserializeError extends Error {\n    constructor(message: string) {\n        super(message);\n    }\n}\n\nexport class StructNotEnoughDataError extends StructDeserializeError {\n    constructor() {\n        super(\n            \"The underlying readable was ended before the struct was fully deserialized\",\n        );\n    }\n}\n\nexport class StructEmptyError extends StructDeserializeError {\n    constructor() {\n        super(\"The underlying readable doesn't contain any more struct\");\n    }\n}\n\nexport type ExtraToIntersection<\n    Extra extends Record<PropertyKey, unknown> | undefined,\n> = Extra extends undefined ? unknown : Extra;\n\nexport interface Struct<\n    Fields extends StructFields,\n    Extra extends Record<PropertyKey, unknown> | undefined = undefined,\n    PostDeserialize = FieldsValue<Fields> & Extra,\n> extends StructSerializer<FieldsInit<Fields>>,\n        StructDeserializer<PostDeserialize> {\n    littleEndian: boolean;\n    fields: Fields;\n    extra: Extra;\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function struct<\n    Fields extends Record<\n        string,\n        | Field<unknown, string, Partial<FieldsValue<Fields>>, unknown>\n        | StructLike<unknown>\n    >,\n    Extra extends Record<PropertyKey, unknown> | undefined = undefined,\n    PostDeserialize = FieldsValue<Fields> & ExtraToIntersection<Extra>,\n>(\n    fields: Fields,\n    options: {\n        littleEndian: boolean;\n        extra?: (Extra & ThisType<FieldsValue<Fields>>) | undefined;\n        postDeserialize?:\n            | ((\n                  this: FieldsValue<Fields> & ExtraToIntersection<Extra>,\n                  value: FieldsValue<Fields> & ExtraToIntersection<Extra>,\n              ) => PostDeserialize)\n            | undefined;\n    },\n): Struct<Fields, Extra, PostDeserialize> {\n    const fieldList = Object.entries(fields);\n\n    let size = 0;\n    let byob = true;\n    for (const [, field] of fieldList) {\n        size += field.size;\n        if (byob && field.type !== \"byob\") {\n            byob = false;\n        }\n    }\n\n    const littleEndian = options.littleEndian;\n    const extra = options.extra\n        ? Object.getOwnPropertyDescriptors(options.extra)\n        : undefined;\n\n    return {\n        littleEndian,\n        fields,\n        extra: options.extra,\n\n        type: byob ? \"byob\" : \"default\",\n        size,\n        serialize(\n            source: FieldsInit<Fields>,\n            bufferOrContext?: Uint8Array | StructSerializeContext,\n        ): Uint8Array | number {\n            const temp: Record<string, unknown> = { ...source };\n\n            for (const [key, field] of fieldList) {\n                if (key in temp && \"init\" in field) {\n                    const result = field.init?.(temp[key], temp as never);\n                    temp[key] = result;\n                }\n            }\n\n            const sizes = new Array<number>(fieldList.length);\n            const buffers = new Array<Uint8Array | undefined>(fieldList.length);\n            {\n                const context: FieldDefaultSerializeContext = { littleEndian };\n                for (const [index, [key, field]] of fieldList.entries()) {\n                    if (field.type === \"byob\") {\n                        sizes[index] = field.size;\n                    } else {\n                        buffers[index] = field.serialize(temp[key], context);\n                        sizes[index] = buffers[index].length;\n                    }\n                }\n            }\n\n            const size = sizes.reduce((sum, size) => sum + size, 0);\n\n            let externalBuffer: boolean;\n            let buffer: Uint8Array;\n            let index: number;\n            if (bufferOrContext instanceof Uint8Array) {\n                if (bufferOrContext.length < size) {\n                    throw new Error(\"Buffer too small\");\n                }\n                externalBuffer = true;\n                buffer = bufferOrContext;\n                index = 0;\n            } else if (\n                typeof bufferOrContext === \"object\" &&\n                \"buffer\" in bufferOrContext\n            ) {\n                externalBuffer = true;\n                buffer = bufferOrContext.buffer;\n                index = bufferOrContext.index ?? 0;\n                if (buffer.length - index < size) {\n                    throw new Error(\"Buffer too small\");\n                }\n            } else {\n                externalBuffer = false;\n                buffer = new Uint8Array(size);\n                index = 0;\n            }\n\n            const context = {\n                buffer,\n                index,\n                littleEndian,\n            } satisfies FieldByobSerializeContext;\n            for (const [index, [key, field]] of fieldList.entries()) {\n                if (buffers[index]) {\n                    buffer.set(buffers[index], context.index);\n                } else {\n                    field.serialize(temp[key], context);\n                }\n                context.index += sizes[index]!;\n            }\n\n            if (externalBuffer) {\n                return size;\n            } else {\n                return buffer;\n            }\n        },\n        deserialize: bipedal(function* (\n            this: Struct<Fields, Extra, PostDeserialize>,\n            then,\n            reader: AsyncExactReadable,\n        ) {\n            const startPosition = reader.position;\n\n            const result = {} as Record<string, unknown>;\n            const context: FieldDeserializeContext<\n                Partial<FieldsValue<Fields>>\n            > = {\n                dependencies: result as never,\n                littleEndian: littleEndian,\n            };\n\n            try {\n                for (const [key, field] of fieldList) {\n                    result[key] = yield* then(\n                        field.deserialize(reader, context),\n                    );\n                }\n            } catch (e) {\n                if (!(e instanceof ExactReadableEndedError)) {\n                    throw e;\n                }\n\n                if (reader.position === startPosition) {\n                    throw new StructEmptyError();\n                } else {\n                    throw new StructNotEnoughDataError();\n                }\n            }\n\n            if (extra) {\n                Object.defineProperties(result, extra);\n            }\n\n            if (options.postDeserialize) {\n                return options.postDeserialize.call(\n                    result as never,\n                    result as never,\n                );\n            } else {\n                return result;\n            }\n        }),\n    } as never;\n}\n", "import type {\n    ExtraToIntersection,\n    FieldsValue,\n    Struct,\n    StructFields,\n} from \"./struct.js\";\nimport { struct } from \"./struct.js\";\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function extend<\n    Base extends Struct<\n        StructFields,\n        Record<PropertyKey, unknown> | undefined,\n        unknown\n    >,\n    Fields extends StructFields,\n    PostDeserialize = FieldsValue<Base[\"fields\"] & Fields> &\n        ExtraToIntersection<Base[\"extra\"]>,\n>(\n    base: Base,\n    fields: Fields,\n    options?: {\n        littleEndian?: boolean | undefined;\n        postDeserialize?: (\n            this: FieldsValue<Base[\"fields\"] & Fields> &\n                ExtraToIntersection<Base[\"extra\"]>,\n            value: FieldsValue<Base[\"fields\"] & Fields> &\n                ExtraToIntersection<Base[\"extra\"]>,\n        ) => PostDeserialize;\n    },\n): Struct<Base[\"fields\"] & Fields, Base[\"extra\"], PostDeserialize> {\n    return struct(Object.assign({}, base.fields, fields), {\n        littleEndian: options?.littleEndian ?? base.littleEndian,\n        extra: base.extra as never,\n        postDeserialize: options?.postDeserialize,\n    }) as never;\n}\n", "/* #__NO_SIDE_EFFECTS__ */\nexport function getInt32LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n): number {\n    return (\n        buffer[offset]! |\n        (buffer[offset + 1]! << 8) |\n        (buffer[offset + 2]! << 16) |\n        (buffer[offset + 3]! << 24)\n    );\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function getInt32BigEndian(buffer: Uint8Array, offset: number): number {\n    return (\n        (buffer[offset]! << 24) |\n        (buffer[offset + 1]! << 16) |\n        (buffer[offset + 2]! << 8) |\n        buffer[offset + 3]!\n    );\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function getInt32(\n    buffer: Uint8Array,\n    offset: number,\n    littleEndian: boolean,\n) {\n    return littleEndian\n        ? buffer[offset]! |\n              (buffer[offset + 1]! << 8) |\n              (buffer[offset + 2]! << 16) |\n              (buffer[offset + 3]! << 24)\n        : (buffer[offset]! << 24) |\n              (buffer[offset + 1]! << 16) |\n              (buffer[offset + 2]! << 8) |\n              buffer[offset + 3]!;\n}\n\nexport function setInt32LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n) {\n    buffer[offset] = value;\n    buffer[offset + 1] = value >> 8;\n    buffer[offset + 2] = value >> 16;\n    buffer[offset + 3] = value >> 24;\n}\n\nexport function setInt32BigEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n) {\n    buffer[offset] = value >> 24;\n    buffer[offset + 1] = value >> 16;\n    buffer[offset + 2] = value >> 8;\n    buffer[offset + 3] = value;\n}\n\nexport function setInt32(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n    littleEndian: boolean,\n) {\n    if (littleEndian) {\n        buffer[offset] = value;\n        buffer[offset + 1] = value >> 8;\n        buffer[offset + 2] = value >> 16;\n        buffer[offset + 3] = value >> 24;\n    } else {\n        buffer[offset] = value >> 24;\n        buffer[offset + 1] = value >> 16;\n        buffer[offset + 2] = value >> 8;\n        buffer[offset + 3] = value;\n    }\n}\n", "/* #__NO_SIDE_EFFECTS__ */\nexport function getInt64LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n): bigint {\n    return (\n        BigInt(buffer[offset]!) |\n        (BigInt(buffer[offset + 1]!) << 8n) |\n        (BigInt(buffer[offset + 2]!) << 16n) |\n        (BigInt(buffer[offset + 3]!) << 24n) |\n        (BigInt(buffer[offset + 4]!) << 32n) |\n        (BigInt(buffer[offset + 5]!) << 40n) |\n        (BigInt(buffer[offset + 6]!) << 48n) |\n        (BigInt(buffer[offset + 7]! << 24) << 32n)\n    );\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function getInt64BigEndian(buffer: Uint8Array, offset: number): bigint {\n    return (\n        (BigInt(buffer[offset]! << 24) << 32n) |\n        (BigInt(buffer[offset + 1]!) << 48n) |\n        (BigInt(buffer[offset + 2]!) << 40n) |\n        (BigInt(buffer[offset + 3]!) << 32n) |\n        (BigInt(buffer[offset + 4]!) << 24n) |\n        (BigInt(buffer[offset + 5]!) << 16n) |\n        (BigInt(buffer[offset + 6]!) << 8n) |\n        BigInt(buffer[offset + 7]!)\n    );\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function getInt64(\n    buffer: Uint8Array,\n    offset: number,\n    littleEndian: boolean,\n): bigint {\n    return littleEndian\n        ? BigInt(buffer[offset]!) |\n              (BigInt(buffer[offset + 1]!) << 8n) |\n              (BigInt(buffer[offset + 2]!) << 16n) |\n              (BigInt(buffer[offset + 3]!) << 24n) |\n              (BigInt(buffer[offset + 4]!) << 32n) |\n              (BigInt(buffer[offset + 5]!) << 40n) |\n              (BigInt(buffer[offset + 6]!) << 48n) |\n              (BigInt(buffer[offset + 7]! << 24) << 32n)\n        : (BigInt(buffer[offset]! << 24) << 32n) |\n              (BigInt(buffer[offset + 1]!) << 48n) |\n              (BigInt(buffer[offset + 2]!) << 40n) |\n              (BigInt(buffer[offset + 3]!) << 32n) |\n              (BigInt(buffer[offset + 4]!) << 24n) |\n              (BigInt(buffer[offset + 5]!) << 16n) |\n              (BigInt(buffer[offset + 6]!) << 8n) |\n              BigInt(buffer[offset + 7]!);\n}\n\nexport function setInt64LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: bigint,\n): void {\n    buffer[offset] = Number(value & 0xffn);\n    buffer[offset + 1] = Number((value >> 8n) & 0xffn);\n    buffer[offset + 2] = Number((value >> 16n) & 0xffn);\n    buffer[offset + 3] = Number((value >> 24n) & 0xffn);\n    buffer[offset + 4] = Number((value >> 32n) & 0xffn);\n    buffer[offset + 5] = Number((value >> 40n) & 0xffn);\n    buffer[offset + 6] = Number((value >> 48n) & 0xffn);\n    buffer[offset + 7] = Number((value >> 56n) & 0xffn);\n}\n\nexport function setInt64BigEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: bigint,\n): void {\n    buffer[offset] = Number((value >> 56n) & 0xffn);\n    buffer[offset + 1] = Number((value >> 48n) & 0xffn);\n    buffer[offset + 2] = Number((value >> 40n) & 0xffn);\n    buffer[offset + 3] = Number((value >> 32n) & 0xffn);\n    buffer[offset + 4] = Number((value >> 24n) & 0xffn);\n    buffer[offset + 5] = Number((value >> 16n) & 0xffn);\n    buffer[offset + 6] = Number((value >> 8n) & 0xffn);\n    buffer[offset + 7] = Number(value & 0xffn);\n}\n\nexport function setInt64(\n    buffer: Uint8Array,\n    offset: number,\n    value: bigint,\n    littleEndian: boolean,\n): void {\n    if (littleEndian) {\n        buffer[offset] = Number(value & 0xffn);\n        buffer[offset + 1] = Number((value >> 8n) & 0xffn);\n        buffer[offset + 2] = Number((value >> 16n) & 0xffn);\n        buffer[offset + 3] = Number((value >> 24n) & 0xffn);\n        buffer[offset + 4] = Number((value >> 32n) & 0xffn);\n        buffer[offset + 5] = Number((value >> 40n) & 0xffn);\n        buffer[offset + 6] = Number((value >> 48n) & 0xffn);\n        buffer[offset + 7] = Number((value >> 56n) & 0xffn);\n    } else {\n        buffer[offset] = Number((value >> 56n) & 0xffn);\n        buffer[offset + 1] = Number((value >> 48n) & 0xffn);\n        buffer[offset + 2] = Number((value >> 40n) & 0xffn);\n        buffer[offset + 3] = Number((value >> 32n) & 0xffn);\n        buffer[offset + 4] = Number((value >> 24n) & 0xffn);\n        buffer[offset + 5] = Number((value >> 16n) & 0xffn);\n        buffer[offset + 6] = Number((value >> 8n) & 0xffn);\n        buffer[offset + 7] = Number(value & 0xffn);\n    }\n}\n", "/* #__NO_SIDE_EFFECTS__ */\nexport function getUint32LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n): number {\n    return (\n        (buffer[offset]! |\n            (buffer[offset + 1]! << 8) |\n            (buffer[offset + 2]! << 16) |\n            (buffer[offset + 3]! << 24)) >>>\n        0\n    );\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function getUint32BigEndian(buffer: Uint8Array, offset: number): number {\n    return (\n        ((buffer[offset]! << 24) |\n            (buffer[offset + 1]! << 16) |\n            (buffer[offset + 2]! << 8) |\n            buffer[offset + 3]!) >>>\n        0\n    );\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function getUint32(\n    buffer: Uint8Array,\n    offset: number,\n    littleEndian: boolean,\n) {\n    return littleEndian\n        ? (buffer[offset]! |\n              (buffer[offset + 1]! << 8) |\n              (buffer[offset + 2]! << 16) |\n              (buffer[offset + 3]! << 24)) >>>\n              0\n        : ((buffer[offset]! << 24) |\n              (buffer[offset + 1]! << 16) |\n              (buffer[offset + 2]! << 8) |\n              buffer[offset + 3]!) >>>\n              0;\n}\n\nexport function setUint32LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n): void {\n    buffer[offset] = value;\n    buffer[offset + 1] = value >> 8;\n    buffer[offset + 2] = value >> 16;\n    buffer[offset + 3] = value >> 24;\n}\n\nexport function setUint32BigEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n): void {\n    buffer[offset] = value >> 24;\n    buffer[offset + 1] = value >> 16;\n    buffer[offset + 2] = value >> 8;\n    buffer[offset + 3] = value;\n}\n\nexport function setUint32(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n    littleEndian: boolean,\n): void {\n    if (littleEndian) {\n        buffer[offset] = value;\n        buffer[offset + 1] = value >> 8;\n        buffer[offset + 2] = value >> 16;\n        buffer[offset + 3] = value >> 24;\n    } else {\n        buffer[offset] = value >> 24;\n        buffer[offset + 1] = value >> 16;\n        buffer[offset + 2] = value >> 8;\n        buffer[offset + 3] = value;\n    }\n}\n", "export function getUint64LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n): bigint {\n    return (\n        BigInt(buffer[offset]!) |\n        (BigInt(buffer[offset + 1]!) << 8n) |\n        (BigInt(buffer[offset + 2]!) << 16n) |\n        (BigInt(buffer[offset + 3]!) << 24n) |\n        (BigInt(buffer[offset + 4]!) << 32n) |\n        (BigInt(buffer[offset + 5]!) << 40n) |\n        (BigInt(buffer[offset + 6]!) << 48n) |\n        (BigInt(buffer[offset + 7]!) << 56n)\n    );\n}\n\nexport function getUint64BigEndian(buffer: Uint8Array, offset: number): bigint {\n    return (\n        (BigInt(buffer[offset]!) << 56n) |\n        (BigInt(buffer[offset + 1]!) << 48n) |\n        (BigInt(buffer[offset + 2]!) << 40n) |\n        (BigInt(buffer[offset + 3]!) << 32n) |\n        (BigInt(buffer[offset + 4]!) << 24n) |\n        (BigInt(buffer[offset + 5]!) << 16n) |\n        (BigInt(buffer[offset + 6]!) << 8n) |\n        BigInt(buffer[offset + 7]!)\n    );\n}\n\nexport function getUint64(\n    buffer: Uint8Array,\n    offset: number,\n    littleEndian: boolean,\n): bigint {\n    return littleEndian\n        ? BigInt(buffer[offset]!) |\n              (BigInt(buffer[offset + 1]!) << 8n) |\n              (BigInt(buffer[offset + 2]!) << 16n) |\n              (BigInt(buffer[offset + 3]!) << 24n) |\n              (BigInt(buffer[offset + 4]!) << 32n) |\n              (BigInt(buffer[offset + 5]!) << 40n) |\n              (BigInt(buffer[offset + 6]!) << 48n) |\n              (BigInt(buffer[offset + 7]!) << 56n)\n        : (BigInt(buffer[offset]!) << 56n) |\n              (BigInt(buffer[offset + 1]!) << 48n) |\n              (BigInt(buffer[offset + 2]!) << 40n) |\n              (BigInt(buffer[offset + 3]!) << 32n) |\n              (BigInt(buffer[offset + 4]!) << 24n) |\n              (BigInt(buffer[offset + 5]!) << 16n) |\n              (BigInt(buffer[offset + 6]!) << 8n) |\n              BigInt(buffer[offset + 7]!);\n}\n\nexport function setUint64LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: bigint,\n): void {\n    buffer[offset] = Number(value & 0xffn);\n    buffer[offset + 1] = Number((value >> 8n) & 0xffn);\n    buffer[offset + 2] = Number((value >> 16n) & 0xffn);\n    buffer[offset + 3] = Number((value >> 24n) & 0xffn);\n    buffer[offset + 4] = Number((value >> 32n) & 0xffn);\n    buffer[offset + 5] = Number((value >> 40n) & 0xffn);\n    buffer[offset + 6] = Number((value >> 48n) & 0xffn);\n    buffer[offset + 7] = Number((value >> 56n) & 0xffn);\n}\n\nexport function setUint64BigEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: bigint,\n): void {\n    buffer[offset] = Number((value >> 56n) & 0xffn);\n    buffer[offset + 1] = Number((value >> 48n) & 0xffn);\n    buffer[offset + 2] = Number((value >> 40n) & 0xffn);\n    buffer[offset + 3] = Number((value >> 32n) & 0xffn);\n    buffer[offset + 4] = Number((value >> 24n) & 0xffn);\n    buffer[offset + 5] = Number((value >> 16n) & 0xffn);\n    buffer[offset + 6] = Number((value >> 8n) & 0xffn);\n    buffer[offset + 7] = Number(value & 0xffn);\n}\n\nexport function setUint64(\n    buffer: Uint8Array,\n    offset: number,\n    value: bigint,\n    littleEndian: boolean,\n): void {\n    if (littleEndian) {\n        buffer[offset] = Number(value & 0xffn);\n        buffer[offset + 1] = Number((value >> 8n) & 0xffn);\n        buffer[offset + 2] = Number((value >> 16n) & 0xffn);\n        buffer[offset + 3] = Number((value >> 24n) & 0xffn);\n        buffer[offset + 4] = Number((value >> 32n) & 0xffn);\n        buffer[offset + 5] = Number((value >> 40n) & 0xffn);\n        buffer[offset + 6] = Number((value >> 48n) & 0xffn);\n        buffer[offset + 7] = Number((value >> 56n) & 0xffn);\n    } else {\n        buffer[offset] = Number((value >> 56n) & 0xffn);\n        buffer[offset + 1] = Number((value >> 48n) & 0xffn);\n        buffer[offset + 2] = Number((value >> 40n) & 0xffn);\n        buffer[offset + 3] = Number((value >> 32n) & 0xffn);\n        buffer[offset + 4] = Number((value >> 24n) & 0xffn);\n        buffer[offset + 5] = Number((value >> 16n) & 0xffn);\n        buffer[offset + 6] = Number((value >> 8n) & 0xffn);\n        buffer[offset + 7] = Number(value & 0xffn);\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport {\n    getInt16,\n    getInt32,\n    getInt64,\n    getInt8,\n    getUint16,\n    getUint32,\n    getUint64,\n    setInt16,\n    setInt32,\n    setInt64,\n    setUint16,\n    setUint32,\n    setUint64,\n} from \"@yume-chan/no-data-view\";\n\nimport type {\n    Field,\n    FieldByobSerializeContext,\n    FieldDeserializeContext,\n} from \"./field/index.js\";\nimport { field } from \"./field/index.js\";\nimport type { AsyncExactReadable } from \"./readable.js\";\n\nexport interface NumberField<T> extends Field<T, never, never, T> {\n    <const U>(infer?: U): Field<U, never, never, T>;\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nfunction number<T>(\n    size: number,\n    serialize: (\n        source: T,\n        context: FieldByobSerializeContext & { index: number },\n    ) => void,\n    deserialize: (\n        then: <U>(value: MaybePromiseLike<U>) => Iterable<unknown, U, unknown>,\n        reader: AsyncExactReadable,\n        context: FieldDeserializeContext<never>,\n    ) => Generator<unknown, T, unknown>,\n) {\n    const fn: NumberField<T> = (() => fn) as never;\n    Object.assign(fn, field(size, \"byob\", serialize, deserialize));\n    return fn;\n}\n\nexport const u8: NumberField<number> = number(\n    1,\n    (value, { buffer, index }) => {\n        buffer[index] = value;\n    },\n    function* (then, reader) {\n        const data = yield* then(reader.readExactly(1));\n        return data[0]!;\n    },\n);\n\nexport const s8: NumberField<number> = number(\n    1,\n    (value, { buffer, index }) => {\n        buffer[index] = value;\n    },\n    function* (then, reader) {\n        const data = yield* then(reader.readExactly(1));\n        return getInt8(data, 0);\n    },\n);\n\nexport const u16: NumberField<number> = number(\n    2,\n    (value, { buffer, index, littleEndian }) => {\n        setUint16(buffer, index, value, littleEndian);\n    },\n    function* (then, reader, { littleEndian }) {\n        const data = yield* then(reader.readExactly(2));\n        return getUint16(data, 0, littleEndian);\n    },\n);\n\nexport const s16: NumberField<number> = number(\n    2,\n    (value, { buffer, index, littleEndian }) => {\n        setInt16(buffer, index, value, littleEndian);\n    },\n    function* (then, reader, { littleEndian }) {\n        const data = yield* then(reader.readExactly(2));\n        return getInt16(data, 0, littleEndian);\n    },\n);\n\nexport const u32: NumberField<number> = number(\n    4,\n    (value, { buffer, index, littleEndian }) => {\n        setUint32(buffer, index, value, littleEndian);\n    },\n    function* (then, reader, { littleEndian }) {\n        const data = yield* then(reader.readExactly(4));\n        return getUint32(data, 0, littleEndian);\n    },\n);\n\nexport const s32: NumberField<number> = number(\n    4,\n    (value, { buffer, index, littleEndian }) => {\n        setInt32(buffer, index, value, littleEndian);\n    },\n    function* (then, reader, { littleEndian }) {\n        const data = yield* then(reader.readExactly(4));\n        return getInt32(data, 0, littleEndian);\n    },\n);\n\nexport const u64: NumberField<bigint> = number(\n    8,\n    (value, { buffer, index, littleEndian }) => {\n        setUint64(buffer, index, value, littleEndian);\n    },\n    function* (then, reader, { littleEndian }) {\n        const data = yield* then(reader.readExactly(8));\n        return getUint64(data, 0, littleEndian);\n    },\n);\n\nexport const s64: NumberField<bigint> = number(\n    8,\n    (value, { buffer, index, littleEndian }) => {\n        setInt64(buffer, index, value, littleEndian);\n    },\n    function* (then, reader, { littleEndian }) {\n        const data = yield* then(reader.readExactly(8));\n        return getInt64(data, 0, littleEndian);\n    },\n);\n", "// This library can't use `@types/node` or `lib: dom`\n// because they will pollute the global scope\n// So `TextEncoder` and `TextDecoder` types are not available\n\n// Node.js 8.3 ships `TextEncoder` and `TextDecoder` in `util` module.\n// But using top level await to load them requires Node.js 14.1.\n// So there is no point to do that. Let's just assume they exist in global.\n\ninterface TextEncoder {\n    encode(input: string): Uint8Array;\n}\n\ninterface TextDecoder {\n    decode(\n        buffer?: ArrayBufferView | ArrayBuffer,\n        options?: { stream?: boolean },\n    ): string;\n}\n\ninterface GlobalExtension {\n    TextEncoder: new () => TextEncoder;\n    TextDecoder: new () => TextDecoder;\n}\n\nexport const { TextEncoder, TextDecoder } =\n    globalThis as unknown as GlobalExtension;\n\nconst SharedEncoder = /* #__PURE__ */ new TextEncoder();\nconst SharedDecoder = /* #__PURE__ */ new TextDecoder();\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function encodeUtf8(input: string): Uint8Array {\n    return SharedEncoder.encode(input);\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function decodeUtf8(buffer: ArrayBufferView | ArrayBuffer): string {\n    // `TextDecoder` has internal states in stream mode,\n    // but this method is not for stream mode, so the instance can be reused\n    return SharedDecoder.decode(buffer);\n}\n", "import type { BufferLengthConverter } from \"./buffer.js\";\nimport { buffer } from \"./buffer.js\";\nimport type { Field } from \"./field/index.js\";\nimport { decodeUtf8, encodeUtf8 } from \"./utils.js\";\n\nexport interface String {\n    (length: number): Field<string, never, never> & {\n        as: <T>(infer: T) => Field<T, never, never>;\n    };\n\n    <K extends string>(\n        lengthField: K,\n    ): Field<string, K, Record<K, number>> & {\n        as: <T>(infer: T) => Field<T, K, Record<K, number>>;\n    };\n\n    <const K extends string, KT>(\n        length: BufferLengthConverter<K, KT>,\n    ): Field<string, K, Record<K, KT>> & {\n        as: <T>(infer: T) => Field<T, K, Record<K, KT>>;\n    };\n\n    <KOmitInit extends string, KS>(\n        length: Field<number, KOmitInit, KS>,\n    ): Field<string, KOmitInit, KS>;\n}\n\n// Prettier will move the annotation and make it invalid\n// prettier-ignore\nexport const string: String = (/* #__NO_SIDE_EFFECTS__ */ (\n    lengthOrField: string | number | BufferLengthConverter<string, unknown>,\n): Field<string, string, Record<string, unknown>> & {\n    as: <T>(infer: T) => Field<T, string, Record<string, unknown>>;\n} => {\n    const field = buffer(lengthOrField as never, {\n        convert: decodeUtf8,\n        back: encodeUtf8,\n    });\n    (field as never as { as: unknown }).as = () => field;\n    return field as never;\n}) as never;\n", "import type {\n    AbortSignal,\n    ReadableStreamIteratorOptions,\n    ReadableStream as ReadableStreamType,\n    TransformStream as TransformStreamType,\n    WritableStream as WritableStreamType,\n} from \"./types.js\";\n\nexport * from \"./types.js\";\nexport { ReadableStream };\n\n/** A controller object that allows you to abort one or more DOM requests as and when desired. */\nexport interface AbortController {\n    /**\n     * Returns the AbortSignal object associated with this object.\n     */\n    readonly signal: AbortSignal;\n\n    /**\n     * Invoking this method will set this object's AbortSignal's aborted flag and signal to any observers that the associated activity is to be aborted.\n     */\n    abort(reason?: unknown): void;\n}\n\ninterface AbortControllerConstructor {\n    prototype: AbortController;\n    new (): AbortController;\n}\n\ninterface GlobalExtension {\n    AbortController: AbortControllerConstructor;\n    ReadableStream: typeof ReadableStreamType;\n    WritableStream: typeof WritableStreamType;\n    TransformStream: typeof TransformStreamType;\n}\n\nexport const { AbortController } = globalThis as unknown as GlobalExtension;\n\nexport type ReadableStream<T> = ReadableStreamType<T>;\nexport type WritableStream<T> = WritableStreamType<T>;\nexport type TransformStream<I, O> = TransformStreamType<I, O>;\n\nconst ReadableStream = /* #__PURE__ */ (() => {\n    const { ReadableStream } = globalThis as unknown as GlobalExtension;\n\n    if (!ReadableStream.from) {\n        ReadableStream.from = function (iterable) {\n            const iterator =\n                Symbol.asyncIterator in iterable\n                    ? iterable[Symbol.asyncIterator]()\n                    : iterable[Symbol.iterator]();\n\n            return new ReadableStream({\n                async pull(controller) {\n                    const result = await iterator.next();\n                    if (result.done) {\n                        controller.close();\n                        return;\n                    }\n                    controller.enqueue(result.value);\n                },\n                async cancel(reason) {\n                    await iterator.return?.(reason);\n                },\n            });\n        };\n    }\n\n    if (\n        !ReadableStream.prototype[Symbol.asyncIterator] ||\n        !ReadableStream.prototype.values\n    ) {\n        ReadableStream.prototype.values = async function* <R>(\n            this: ReadableStream<R>,\n            options?: ReadableStreamIteratorOptions,\n        ) {\n            const reader = this.getReader();\n            try {\n                while (true) {\n                    const { done, value } = await reader.read();\n                    if (done) {\n                        return;\n                    }\n                    yield value;\n                }\n            } finally {\n                // Calling `iterator.return` will enter this `finally` block.\n                // We don't need to care about the parameter to `iterator.return`,\n                // it will be returned as the final `result.value` automatically.\n                if (!options?.preventCancel) {\n                    await reader.cancel();\n                }\n                reader.releaseLock();\n            }\n        };\n\n        ReadableStream.prototype[Symbol.asyncIterator] =\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            ReadableStream.prototype.values;\n    }\n\n    return ReadableStream;\n})();\n\nexport const { WritableStream, TransformStream } =\n    globalThis as unknown as GlobalExtension;\n", "import { PromiseResolver } from \"@yume-chan/async\";\n\nimport type { AbortSignal, QueuingStrategy } from \"./stream.js\";\nimport { AbortController, ReadableStream } from \"./stream.js\";\n\nexport interface PushReadableStreamController<T> {\n    abortSignal: AbortSignal;\n\n    enqueue(chunk: T): Promise<void>;\n\n    close(): void;\n\n    error(e?: unknown): void;\n}\n\nexport type PushReadableStreamSource<T> = (\n    controller: PushReadableStreamController<T>,\n) => void | Promise<void>;\n\nexport type PushReadableLogger<T> = (\n    event:\n        | {\n              source: \"producer\";\n              operation: \"enqueue\";\n              value: T;\n              phase: \"start\" | \"waiting\" | \"ignored\" | \"complete\";\n          }\n        | {\n              source: \"producer\";\n              operation: \"close\" | \"error\";\n              explicit: boolean;\n              phase: \"start\" | \"ignored\" | \"complete\";\n          }\n        | {\n              source: \"consumer\";\n              operation: \"pull\" | \"cancel\";\n              phase: \"start\" | \"complete\";\n          },\n) => void;\n\nexport class PushReadableStream<T> extends ReadableStream<T> {\n    /**\n     * Create a new `PushReadableStream` from a source.\n     *\n     * @param source If `source` returns a `Promise`, the stream will be closed\n     * when the `Promise` is resolved, and be errored when the `Promise` is rejected.\n     * @param strategy\n     */\n    constructor(\n        source: PushReadableStreamSource<T>,\n        strategy?: QueuingStrategy<T>,\n        logger?: PushReadableLogger<T>,\n    ) {\n        let waterMarkLow: PromiseResolver<void> | undefined;\n        let zeroHighWaterMarkAllowEnqueue = false;\n        const abortController = new AbortController();\n\n        super(\n            {\n                start: (controller) => {\n                    const result = source({\n                        abortSignal: abortController.signal,\n                        enqueue: async (chunk) => {\n                            logger?.({\n                                source: \"producer\",\n                                operation: \"enqueue\",\n                                value: chunk,\n                                phase: \"start\",\n                            });\n\n                            if (abortController.signal.aborted) {\n                                // In original `ReadableStream`, calling `enqueue` or `close`\n                                // on an cancelled stream will throw an error,\n                                //\n                                // But in `PushReadableStream`, `enqueue` is an async function,\n                                // the producer can't just check `abortSignal.aborted`\n                                // before calling `enqueue`, as it might change when waiting\n                                // for the backpressure to be reduced.\n                                //\n                                // So IMO it's better to handle this for the producer\n                                // by simply ignoring the `enqueue` call.\n                                //\n                                // Note that we check `abortSignal.aborted` instead of `stopped`,\n                                // as it's not allowed for the producer to call `enqueue` after\n                                // they called `close` or `error`.\n                                //\n                                // Obviously, the producer should listen to the `abortSignal` and\n                                // stop producing, but most pushing data sources don't support that.\n                                logger?.({\n                                    source: \"producer\",\n                                    operation: \"enqueue\",\n                                    value: chunk,\n                                    phase: \"ignored\",\n                                });\n                                return;\n                            }\n\n                            if (controller.desiredSize === null) {\n                                // `desiredSize` being `null` means the stream is in error state,\n                                // `controller.enqueue` will throw an error for us.\n                                controller.enqueue(chunk);\n                                // istanbul ignore next\n                                return;\n                            }\n\n                            if (zeroHighWaterMarkAllowEnqueue) {\n                                // When `highWaterMark` is set to `0`,\n                                // `controller.desiredSize` will always be `0`,\n                                // even if the consumer has called `reader.read()`.\n                                // (in this case, each `reader.read()`/`pull`\n                                // should allow one `enqueue` of any size)\n                                //\n                                // If the consumer has already called `reader.read()`,\n                                // before the producer tries to `enqueue`,\n                                // `controller.desiredSize` is `0` and normal `waterMarkLow` signal\n                                // will never trigger,\n                                // (because `ReadableStream` prevents reentrance of `pull`)\n                                // The stream will stuck.\n                                //\n                                // So we need a special signal for this case.\n                                zeroHighWaterMarkAllowEnqueue = false;\n                                controller.enqueue(chunk);\n                                logger?.({\n                                    source: \"producer\",\n                                    operation: \"enqueue\",\n                                    value: chunk,\n                                    phase: \"complete\",\n                                });\n                                return;\n                            }\n\n                            if (controller.desiredSize <= 0) {\n                                logger?.({\n                                    source: \"producer\",\n                                    operation: \"enqueue\",\n                                    value: chunk,\n                                    phase: \"waiting\",\n                                });\n\n                                waterMarkLow = new PromiseResolver<void>();\n                                await waterMarkLow.promise;\n\n                                // Recheck consumer cancellation after async operations.\n                                if (abortController.signal.aborted) {\n                                    logger?.({\n                                        source: \"producer\",\n                                        operation: \"enqueue\",\n                                        value: chunk,\n                                        phase: \"ignored\",\n                                    });\n                                    return;\n                                }\n                            }\n\n                            controller.enqueue(chunk);\n                            logger?.({\n                                source: \"producer\",\n                                operation: \"enqueue\",\n                                value: chunk,\n                                phase: \"complete\",\n                            });\n                        },\n                        close() {\n                            logger?.({\n                                source: \"producer\",\n                                operation: \"close\",\n                                explicit: true,\n                                phase: \"start\",\n                            });\n\n                            // Since `enqueue` on an cancelled stream won't throw an error,\n                            // so does `close`.\n                            if (abortController.signal.aborted) {\n                                logger?.({\n                                    source: \"producer\",\n                                    operation: \"close\",\n                                    explicit: true,\n                                    phase: \"ignored\",\n                                });\n                                return;\n                            }\n\n                            controller.close();\n                            logger?.({\n                                source: \"producer\",\n                                operation: \"close\",\n                                explicit: true,\n                                phase: \"complete\",\n                            });\n                        },\n                        error(e) {\n                            logger?.({\n                                source: \"producer\",\n                                operation: \"error\",\n                                explicit: true,\n                                phase: \"start\",\n                            });\n\n                            // Calling `error` on an already closed or errored stream is a no-op.\n                            controller.error(e);\n\n                            logger?.({\n                                source: \"producer\",\n                                operation: \"error\",\n                                explicit: true,\n                                phase: \"complete\",\n                            });\n                        },\n                    });\n\n                    if (result && \"then\" in result) {\n                        // If `source` returns a `Promise`,\n                        // close the stream when the `Promise` is resolved,\n                        // and error the stream when the `Promise` is rejected.\n                        // The producer can return a never-settling `Promise`\n                        // to disable this behavior.\n                        result.then(\n                            () => {\n                                logger?.({\n                                    source: \"producer\",\n                                    operation: \"close\",\n                                    explicit: false,\n                                    phase: \"start\",\n                                });\n\n                                try {\n                                    controller.close();\n\n                                    logger?.({\n                                        source: \"producer\",\n                                        operation: \"close\",\n                                        explicit: false,\n                                        phase: \"complete\",\n                                    });\n                                } catch {\n                                    logger?.({\n                                        source: \"producer\",\n                                        operation: \"close\",\n                                        explicit: false,\n                                        phase: \"ignored\",\n                                    });\n\n                                    // The stream is already closed by the producer,\n                                    // Or cancelled by the consumer.\n                                }\n                            },\n                            (e) => {\n                                logger?.({\n                                    source: \"producer\",\n                                    operation: \"error\",\n                                    explicit: false,\n                                    phase: \"start\",\n                                });\n\n                                controller.error(e);\n\n                                logger?.({\n                                    source: \"producer\",\n                                    operation: \"error\",\n                                    explicit: false,\n                                    phase: \"complete\",\n                                });\n                            },\n                        );\n                    }\n                },\n                pull: () => {\n                    logger?.({\n                        source: \"consumer\",\n                        operation: \"pull\",\n                        phase: \"start\",\n                    });\n\n                    if (waterMarkLow) {\n                        waterMarkLow.resolve();\n                    } else if (strategy?.highWaterMark === 0) {\n                        zeroHighWaterMarkAllowEnqueue = true;\n                    }\n\n                    logger?.({\n                        source: \"consumer\",\n                        operation: \"pull\",\n                        phase: \"complete\",\n                    });\n                },\n                cancel: (reason) => {\n                    logger?.({\n                        source: \"consumer\",\n                        operation: \"cancel\",\n                        phase: \"start\",\n                    });\n\n                    abortController.abort(reason);\n                    // Resolve it on cancellation. `pull` will check `abortSignal.aborted` again.\n                    waterMarkLow?.resolve();\n\n                    logger?.({\n                        source: \"consumer\",\n                        operation: \"cancel\",\n                        phase: \"complete\",\n                    });\n                },\n            },\n            strategy,\n        );\n    }\n}\n", "import type { BufferedReadableStream } from \"./buffered.js\";\nimport type { PushReadableStreamController } from \"./push-readable.js\";\nimport type {\n    ReadableStream,\n    ReadableStreamDefaultController,\n    ReadableStreamDefaultReader,\n    WritableStreamDefaultWriter,\n} from \"./stream.js\";\n\nexport function tryClose(\n    controller: PushReadableStreamController<unknown>,\n): boolean;\nexport function tryClose(\n    controller: ReadableStreamDefaultController<unknown>,\n): boolean;\nexport function tryClose(writer: WritableStreamDefaultWriter<never>): boolean;\nexport function tryClose(controller: { close(): void }) {\n    try {\n        controller.close();\n        return true;\n    } catch {\n        return false;\n    }\n}\n\nexport async function tryCancel(\n    stream: ReadableStream<unknown>,\n): Promise<boolean>;\nexport async function tryCancel(\n    stream: BufferedReadableStream,\n): Promise<boolean>;\nexport async function tryCancel(\n    reader: ReadableStreamDefaultReader<unknown>,\n): Promise<boolean>;\nexport async function tryCancel(stream: {\n    cancel(): Promise<void>;\n}): Promise<boolean> {\n    try {\n        await stream.cancel();\n        return true;\n    } catch {\n        return false;\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport type { AsyncExactReadable } from \"@yume-chan/struct\";\nimport { bipedal, ExactReadableEndedError } from \"@yume-chan/struct\";\n\nimport { PushReadableStream } from \"./push-readable.js\";\nimport type { ReadableStream, ReadableStreamDefaultReader } from \"./stream.js\";\nimport { tryCancel } from \"./try-close.js\";\n\nexport class BufferedReadableStream implements AsyncExactReadable {\n    #buffered: Uint8Array | undefined;\n    // PERF: `subarray` is slow\n    // don't use it until absolutely necessary\n    #bufferedOffset = 0;\n    #bufferedLength = 0;\n\n    #position = 0;\n    get position() {\n        return this.#position;\n    }\n\n    protected readonly stream: ReadableStream<Uint8Array>;\n    protected readonly reader: ReadableStreamDefaultReader<Uint8Array>;\n\n    constructor(stream: ReadableStream<Uint8Array>) {\n        this.stream = stream;\n        this.reader = stream.getReader();\n    }\n\n    #readBuffered(length: number) {\n        if (!this.#buffered) {\n            return undefined;\n        }\n\n        const value = this.#buffered.subarray(\n            this.#bufferedOffset,\n            this.#bufferedOffset + length,\n        );\n\n        // PERF: Synchronous path for reading from internal buffer\n        if (this.#bufferedLength > length) {\n            this.#position += length;\n            this.#bufferedOffset += length;\n            this.#bufferedLength -= length;\n            return value;\n        }\n\n        this.#position += this.#bufferedLength;\n        this.#buffered = undefined;\n        this.#bufferedOffset = 0;\n        this.#bufferedLength = 0;\n        return value;\n    }\n\n    async #readSource(length: number): Promise<Uint8Array> {\n        const { done, value } = await this.reader.read();\n        if (done) {\n            throw new ExactReadableEndedError();\n        }\n\n        if (value.length > length) {\n            this.#buffered = value;\n            this.#bufferedOffset = length;\n            this.#bufferedLength = value.length - length;\n            this.#position += length;\n            return value.subarray(0, length);\n        }\n\n        this.#position += value.length;\n        return value;\n    }\n\n    iterateExactly(\n        length: number,\n    ): Iterator<MaybePromiseLike<Uint8Array>, void, void> {\n        let state = this.#buffered ? 0 : 1;\n        return {\n            next: () => {\n                switch (state) {\n                    case 0: {\n                        const value = this.#readBuffered(length)!;\n                        if (value.length === length) {\n                            state = 2;\n                        } else {\n                            length -= value.length;\n                            state = 1;\n                        }\n                        return { done: false, value };\n                    }\n                    case 1:\n                        state = 3;\n                        return {\n                            done: false,\n                            value: this.#readSource(length).then((value) => {\n                                if (value.length === length) {\n                                    state = 2;\n                                } else {\n                                    length -= value.length;\n                                    state = 1;\n                                }\n                                return value;\n                            }),\n                        };\n                    case 2:\n                        return { done: true, value: undefined };\n                    case 3:\n                        throw new Error(\n                            \"Can't call `next` before previous Promise resolves\",\n                        );\n                    default:\n                        throw new Error(\"unreachable\");\n                }\n            },\n        };\n    }\n\n    readExactly = bipedal(function* (\n        this: BufferedReadableStream,\n        then,\n        length: number,\n    ) {\n        let result: Uint8Array | undefined;\n        let index = 0;\n\n        const initial = this.#readBuffered(length);\n        if (initial) {\n            if (initial.length === length) {\n                return initial;\n            }\n\n            result = new Uint8Array(length);\n            result.set(initial, index);\n            index += initial.length;\n            length -= initial.length;\n        } else {\n            result = new Uint8Array(length);\n        }\n\n        while (length > 0) {\n            const value = yield* then(this.#readSource(length));\n            result.set(value, index);\n            index += value.length;\n            length -= value.length;\n        }\n\n        return result;\n    });\n\n    /**\n     * Return a readable stream with unconsumed data (if any) and\n     * all data from the wrapped stream.\n     * @returns A `ReadableStream`\n     */\n    release(): ReadableStream<Uint8Array> {\n        if (this.#bufferedLength > 0) {\n            return new PushReadableStream<Uint8Array>(async (controller) => {\n                // Put the remaining data back to the stream\n                const buffered = this.#buffered!.subarray(this.#bufferedOffset);\n                await controller.enqueue(buffered);\n\n                controller.abortSignal.addEventListener(\"abort\", () => {\n                    void tryCancel(this.reader);\n                });\n\n                // Manually pipe the stream\n                while (true) {\n                    const { done, value } = await this.reader.read();\n                    if (done) {\n                        return;\n                    }\n\n                    await controller.enqueue(value);\n                }\n            });\n        } else {\n            // Simply release the reader and return the stream\n            this.reader.releaseLock();\n            return this.stream;\n        }\n    }\n\n    async cancel(reason?: unknown) {\n        await this.reader.cancel(reason);\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport { StructEmptyError } from \"@yume-chan/struct\";\n\nimport { BufferedReadableStream } from \"./buffered.js\";\nimport type { PushReadableStreamController } from \"./push-readable.js\";\nimport { PushReadableStream } from \"./push-readable.js\";\nimport type {\n    ReadableWritablePair,\n    WritableStreamDefaultController,\n} from \"./stream.js\";\nimport { ReadableStream, WritableStream } from \"./stream.js\";\n\n// TODO: BufferedTransformStream: find better implementation\nexport class BufferedTransformStream<T>\n    implements ReadableWritablePair<T, Uint8Array>\n{\n    #readable: ReadableStream<T>;\n    get readable() {\n        return this.#readable;\n    }\n\n    #writable: WritableStream<Uint8Array>;\n    get writable() {\n        return this.#writable;\n    }\n\n    constructor(\n        transform: (stream: BufferedReadableStream) => MaybePromiseLike<T>,\n    ) {\n        // Convert incoming chunks to a `BufferedReadableStream`\n        let bufferedStreamController!: PushReadableStreamController<Uint8Array>;\n\n        let writableStreamController!: WritableStreamDefaultController;\n\n        const buffered = new BufferedReadableStream(\n            new PushReadableStream<Uint8Array>((controller) => {\n                bufferedStreamController = controller;\n            }),\n        );\n\n        this.#readable = new ReadableStream<T>({\n            async pull(controller) {\n                try {\n                    const value = await transform(buffered);\n                    controller.enqueue(value);\n                } catch (e) {\n                    // Treat `StructEmptyError` as a normal end.\n                    // If the `transform` method doesn't have enough data to return a value,\n                    // it should throw another error to indicate that.\n                    if (e instanceof StructEmptyError) {\n                        controller.close();\n                        return;\n                    }\n                    throw e;\n                }\n            },\n            cancel: (reason) => {\n                // If a `ReadableStream` is piping into `#writable`,\n                // This will cancel the `ReadableStream` immediately.\n                // If upstream is writing using `#writable`'s writer, this will\n                // throw errors for any future writes\n                return writableStreamController.error(reason);\n            },\n        });\n\n        this.#writable = new WritableStream({\n            start(controller) {\n                writableStreamController = controller;\n            },\n            async write(chunk) {\n                await bufferedStreamController.enqueue(chunk);\n            },\n            abort() {\n                bufferedStreamController.close();\n            },\n            close() {\n                bufferedStreamController.close();\n            },\n        });\n    }\n}\n", "import { PromiseResolver } from \"@yume-chan/async\";\nimport { EmptyUint8Array } from \"@yume-chan/struct\";\n\nimport type { ReadableStreamDefaultController } from \"./stream.js\";\nimport { ReadableStream, WritableStream } from \"./stream.js\";\n\nexport interface ConcatStringReadableStream\n    extends ReadableStream<string>,\n        Promise<string> {}\n\n// `TransformStream` only calls its `source.flush` method when its `readable` is being read.\n// If the user want to use the `Promise` interface, the `flush` method will never be called,\n// so the `PromiseResolver` will never be resolved.\n// Thus we need to implement our own `TransformStream` using a `WritableStream` and a `ReadableStream`.\n\n/**\n * A `TransformStream` that concatenates strings.\n *\n * Its `readable` is also a `Promise<string>`, so it's possible to `await` it to get the result.\n *\n * ```ts\n * const result: string = await readable.pipeThrough(new ConcatStringStream());\n * ```\n */\nexport class ConcatStringStream {\n    // PERF: rope (concat strings) is faster than `[].join('')`\n    #result = \"\";\n\n    #resolver = new PromiseResolver<string>();\n\n    #writable = new WritableStream<string>({\n        write: (chunk) => {\n            this.#result += chunk;\n        },\n        close: () => {\n            this.#resolver.resolve(this.#result);\n            this.#readableController.enqueue(this.#result);\n            this.#readableController.close();\n        },\n        abort: (reason) => {\n            this.#resolver.reject(reason);\n            this.#readableController.error(reason);\n        },\n    });\n    get writable(): WritableStream<string> {\n        return this.#writable;\n    }\n\n    #readableController!: ReadableStreamDefaultController<string>;\n    #readable = new ReadableStream<string>({\n        start: (controller) => {\n            this.#readableController = controller;\n        },\n    }) as ConcatStringReadableStream;\n    get readable(): ConcatStringReadableStream {\n        return this.#readable;\n    }\n\n    constructor() {\n        void Object.defineProperties(this.#readable, {\n            then: {\n                get: () =>\n                    this.#resolver.promise.then.bind(this.#resolver.promise),\n            },\n            catch: {\n                get: () =>\n                    this.#resolver.promise.catch.bind(this.#resolver.promise),\n            },\n            finally: {\n                get: () =>\n                    this.#resolver.promise.finally.bind(this.#resolver.promise),\n            },\n        });\n    }\n}\n\nexport interface ConcatBufferReadableStream\n    extends ReadableStream<Uint8Array>,\n        Promise<Uint8Array> {}\n\n/**\n * A `TransformStream` that concatenates `Uint8Array`s.\n *\n * If you want to decode the result as string,\n * prefer `.pipeThrough(new TextDecoderStream()).pipeThrough(new ConcatStringStream())`,\n * than `.pipeThough(new ConcatBufferStream()).pipeThrough(new TextDecoderStream())`,\n * because of JavaScript engine optimizations,\n * concatenating strings is faster than concatenating `Uint8Array`s.\n */\nexport class ConcatBufferStream {\n    #segments: Uint8Array[] = [];\n\n    #resolver = new PromiseResolver<Uint8Array>();\n\n    #writable = new WritableStream<Uint8Array>({\n        write: (chunk) => {\n            this.#segments.push(chunk);\n        },\n        close: () => {\n            let result: Uint8Array;\n            let offset = 0;\n            switch (this.#segments.length) {\n                case 0:\n                    result = EmptyUint8Array;\n                    break;\n                case 1:\n                    result = this.#segments[0]!;\n                    break;\n                default:\n                    result = new Uint8Array(\n                        this.#segments.reduce(\n                            (prev, item) => prev + item.length,\n                            0,\n                        ),\n                    );\n                    for (const segment of this.#segments) {\n                        result.set(segment, offset);\n                        offset += segment.length;\n                    }\n                    break;\n            }\n\n            this.#resolver.resolve(result);\n            this.#readableController.enqueue(result);\n            this.#readableController.close();\n        },\n        abort: (reason) => {\n            this.#resolver.reject(reason);\n            this.#readableController.error(reason);\n        },\n    });\n    get writable(): WritableStream<Uint8Array> {\n        return this.#writable;\n    }\n\n    #readableController!: ReadableStreamDefaultController<Uint8Array>;\n    #readable = new ReadableStream<Uint8Array>({\n        start: (controller) => {\n            this.#readableController = controller;\n        },\n    }) as ConcatBufferReadableStream;\n    get readable(): ConcatBufferReadableStream {\n        return this.#readable;\n    }\n\n    constructor() {\n        void Object.defineProperties(this.#readable, {\n            then: {\n                get: () =>\n                    this.#resolver.promise.then.bind(this.#resolver.promise),\n            },\n            catch: {\n                get: () =>\n                    this.#resolver.promise.catch.bind(this.#resolver.promise),\n            },\n            finally: {\n                get: () =>\n                    this.#resolver.promise.finally.bind(this.#resolver.promise),\n            },\n        });\n    }\n}\n", "import { Consumable } from \"../consumable.js\";\nimport type { QueuingStrategy } from \"../stream.js\";\nimport { ReadableStream } from \"../stream.js\";\n\nexport interface ConsumableReadableStreamController<T> {\n    enqueue(chunk: T): Promise<void>;\n    close(): void;\n    error(reason: unknown): void;\n}\n\nexport interface ConsumableReadableStreamSource<T> {\n    start?(\n        controller: ConsumableReadableStreamController<T>,\n    ): void | PromiseLike<void>;\n    pull?(\n        controller: ConsumableReadableStreamController<T>,\n    ): void | PromiseLike<void>;\n    cancel?(reason: unknown): void | PromiseLike<void>;\n}\n\nexport class ConsumableReadableStream<T> extends ReadableStream<Consumable<T>> {\n    static async enqueue<T>(\n        controller: { enqueue: (chunk: Consumable<T>) => void },\n        chunk: T,\n    ) {\n        const output = new Consumable(chunk);\n        controller.enqueue(output);\n        await output.consumed;\n    }\n\n    constructor(\n        source: ConsumableReadableStreamSource<T>,\n        strategy?: QueuingStrategy<T>,\n    ) {\n        let wrappedController!: ConsumableReadableStreamController<T>;\n\n        let wrappedStrategy: QueuingStrategy<Consumable<T>> | undefined;\n        if (strategy) {\n            wrappedStrategy = {};\n            if (\"highWaterMark\" in strategy) {\n                wrappedStrategy.highWaterMark = strategy.highWaterMark;\n            }\n            if (\"size\" in strategy) {\n                wrappedStrategy.size = (chunk) => {\n                    return strategy.size!(chunk.value);\n                };\n            }\n        }\n\n        super(\n            {\n                start(controller) {\n                    wrappedController = {\n                        enqueue(chunk) {\n                            return ConsumableReadableStream.enqueue(\n                                controller,\n                                chunk,\n                            );\n                        },\n                        close() {\n                            controller.close();\n                        },\n                        error(reason) {\n                            controller.error(reason);\n                        },\n                    };\n\n                    return source.start?.(wrappedController);\n                },\n                pull() {\n                    return source.pull?.(wrappedController);\n                },\n                cancel(reason) {\n                    return source.cancel?.(reason);\n                },\n            },\n            wrappedStrategy,\n        );\n    }\n}\n", "import type { Consumable } from \"../consumable.js\";\nimport { ReadableStream } from \"../stream.js\";\n\nimport { ConsumableReadableStream } from \"./readable.js\";\n\nexport class ConsumableWrapByteReadableStream extends ReadableStream<\n    Consumable<Uint8Array>\n> {\n    constructor(\n        stream: ReadableStream<Uint8Array>,\n        chunkSize: number,\n        min?: number,\n    ) {\n        const reader = stream.getReader({ mode: \"byob\" });\n        let array = new Uint8Array(chunkSize);\n        super({\n            async pull(controller) {\n                const { done, value } = await reader.read(array, { min });\n                if (done) {\n                    controller.close();\n                    return;\n                }\n\n                await ConsumableReadableStream.enqueue(controller, value);\n\n                array = new Uint8Array(value.buffer);\n            },\n            cancel(reason) {\n                return reader.cancel(reason);\n            },\n        });\n    }\n}\n", "import type { Consumable } from \"../consumable.js\";\nimport { WritableStream } from \"../stream.js\";\n\nexport class ConsumableWrapWritableStream<in T> extends WritableStream<\n    Consumable<T>\n> {\n    constructor(stream: WritableStream<T>) {\n        const writer = stream.getWriter();\n        super({\n            write(chunk) {\n                return chunk.tryConsume((chunk) => writer.write(chunk));\n            },\n            abort(reason) {\n                return writer.abort(reason);\n            },\n            close() {\n                return writer.close();\n            },\n        });\n    }\n}\n", "import { Consumable } from \"../consumable.js\";\nimport type {\n    QueuingStrategy,\n    WritableStreamDefaultController,\n    WritableStreamDefaultWriter,\n} from \"../stream.js\";\nimport { WritableStream } from \"../stream.js\";\n\nexport interface ConsumableWritableStreamSink<in T> {\n    start?(\n        controller: WritableStreamDefaultController,\n    ): void | PromiseLike<void>;\n    write?(\n        chunk: T,\n        controller: WritableStreamDefaultController,\n    ): void | PromiseLike<void>;\n    abort?(reason: unknown): void | PromiseLike<void>;\n    close?(): void | PromiseLike<void>;\n}\n\nexport class ConsumableWritableStream<in T> extends WritableStream<\n    Consumable<T>\n> {\n    static async write<T>(\n        writer: WritableStreamDefaultWriter<Consumable<T>>,\n        value: T,\n    ) {\n        const consumable = new Consumable(value);\n        await writer.write(consumable);\n        await consumable.consumed;\n    }\n\n    constructor(\n        sink: ConsumableWritableStreamSink<T>,\n        strategy?: QueuingStrategy<T>,\n    ) {\n        let wrappedStrategy: QueuingStrategy<Consumable<T>> | undefined;\n        if (strategy) {\n            wrappedStrategy = {};\n            if (\"highWaterMark\" in strategy) {\n                wrappedStrategy.highWaterMark = strategy.highWaterMark;\n            }\n            if (\"size\" in strategy) {\n                wrappedStrategy.size = (chunk) => {\n                    return strategy.size!(\n                        chunk instanceof Consumable ? chunk.value : chunk,\n                    );\n                };\n            }\n        }\n\n        super(\n            {\n                start(controller) {\n                    return sink.start?.(controller);\n                },\n                write(chunk, controller) {\n                    return chunk.tryConsume((chunk) =>\n                        sink.write?.(chunk, controller),\n                    );\n                },\n                abort(reason) {\n                    return sink.abort?.(reason);\n                },\n                close() {\n                    return sink.close?.();\n                },\n            },\n            wrappedStrategy,\n        );\n    }\n}\n", "export interface Task {\n    run<T>(callback: () => T): T;\n}\n\ninterface Console {\n    createTask(name: string): Task;\n}\n\ninterface GlobalExtension {\n    console?: Console;\n}\n\n// `createTask` allows browser DevTools to track the call stack across async boundaries.\nconst { console } = globalThis as unknown as GlobalExtension;\nexport const createTask: (name: string) => Task = /* #__PURE__ */ (() =>\n    console?.createTask?.bind(console) ??\n    (() => ({\n        run(callback) {\n            return callback();\n        },\n    })))();\n", "import { PromiseResolver, isPromiseLike } from \"@yume-chan/async\";\n\nimport type {\n    ConsumableReadableStreamController,\n    ConsumableReadableStreamSource,\n    ConsumableWritableStreamSink,\n} from \"./consumable/index.js\";\nimport {\n    ConsumableReadableStream,\n    ConsumableWrapByteReadableStream,\n    ConsumableWrapWritableStream,\n    ConsumableWritableStream,\n} from \"./consumable/index.js\";\nimport type { Task } from \"./task.js\";\nimport { createTask } from \"./task.js\";\n\nexport class Consumable<T> {\n    static readonly WritableStream = ConsumableWritableStream;\n    static readonly WrapWritableStream = ConsumableWrapWritableStream;\n    static readonly ReadableStream = ConsumableReadableStream;\n    static readonly WrapByteReadableStream = ConsumableWrapByteReadableStream;\n\n    readonly #task: Task;\n    readonly #resolver: PromiseResolver<void>;\n\n    readonly value: T;\n    readonly consumed: Promise<void>;\n\n    constructor(value: T) {\n        this.#task = createTask(\"Consumable\");\n        this.value = value;\n        this.#resolver = new PromiseResolver<void>();\n        this.consumed = this.#resolver.promise;\n    }\n\n    consume() {\n        this.#resolver.resolve();\n    }\n\n    error(error: unknown) {\n        this.#resolver.reject(error);\n    }\n\n    tryConsume<U>(callback: (value: T) => U) {\n        try {\n            let result = this.#task.run(() => callback(this.value));\n            if (isPromiseLike(result)) {\n                result = result.then(\n                    (value) => {\n                        this.#resolver.resolve();\n                        return value;\n                    },\n                    (e) => {\n                        this.#resolver.reject(e);\n                        throw e;\n                    },\n                ) as U;\n            } else {\n                this.#resolver.resolve();\n            }\n            return result;\n        } catch (e) {\n            this.#resolver.reject(e);\n            throw e;\n        }\n    }\n}\n\nexport namespace Consumable {\n    export type WritableStreamSink<T> = ConsumableWritableStreamSink<T>;\n    export type WritableStream<in T> = typeof ConsumableWritableStream<T>;\n\n    export type WrapWritableStream<in T> =\n        typeof ConsumableWrapWritableStream<T>;\n\n    export type ReadableStreamController<T> =\n        ConsumableReadableStreamController<T>;\n    export type ReadableStreamSource<T> = ConsumableReadableStreamSource<T>;\n    export type ReadableStream<T> = typeof ConsumableReadableStream<T>;\n\n    export type WrapByteReadableStream =\n        typeof ConsumableWrapByteReadableStream;\n}\n", "export * from \"./utils.js\";\nexport { MaybeConsumableWrapWritableStream as WrapWritableStream } from \"./wrap-writable.js\";\nexport { MaybeConsumableWritableStream as WritableStream } from \"./writable.js\";\nexport type { MaybeConsumableWritableStreamSink as WritableStreamSink } from \"./writable.js\";\n", "import { Consumable } from \"../consumable.js\";\nimport type { MaybeConsumable } from \"../maybe-consumable.js\";\n\nexport function getValue<T>(value: MaybeConsumable<T>): T {\n    return value instanceof Consumable ? value.value : value;\n}\n\nexport function tryConsume<T, R>(\n    value: T,\n    callback: (value: T extends Consumable<infer U> ? U : T) => R,\n): R {\n    if (value instanceof Consumable) {\n        return value.tryConsume(callback);\n    } else {\n        return callback(value as never);\n    }\n}\n", "import type { MaybeConsumable } from \"../maybe-consumable.js\";\nimport { WritableStream } from \"../stream.js\";\n\nimport { tryConsume } from \"./utils.js\";\n\nexport class MaybeConsumableWrapWritableStream<T> extends WritableStream<\n    MaybeConsumable<T>\n> {\n    constructor(stream: WritableStream<T>) {\n        const writer = stream.getWriter();\n        super({\n            write(chunk) {\n                return tryConsume(chunk, (chunk) => writer.write(chunk as T));\n            },\n            abort(reason) {\n                return writer.abort(reason);\n            },\n            close() {\n                return writer.close();\n            },\n        });\n    }\n}\n", "import { Consumable } from \"../consumable.js\";\nimport type { MaybeConsumable } from \"../maybe-consumable.js\";\nimport type {\n    QueuingStrategy,\n    WritableStreamDefaultController,\n} from \"../stream.js\";\nimport { WritableStream } from \"../stream.js\";\n\nimport { tryConsume } from \"./utils.js\";\n\nexport interface MaybeConsumableWritableStreamSink<in T> {\n    start?(\n        controller: WritableStreamDefaultController,\n    ): void | PromiseLike<void>;\n    write?(\n        chunk: T,\n        controller: WritableStreamDefaultController,\n    ): void | PromiseLike<void>;\n    abort?(reason: unknown): void | PromiseLike<void>;\n    close?(): void | PromiseLike<void>;\n}\n\nexport class MaybeConsumableWritableStream<in T> extends WritableStream<\n    MaybeConsumable<T>\n> {\n    constructor(\n        sink: MaybeConsumableWritableStreamSink<T>,\n        strategy?: QueuingStrategy<T>,\n    ) {\n        let wrappedStrategy: QueuingStrategy<MaybeConsumable<T>> | undefined;\n        if (strategy) {\n            wrappedStrategy = {};\n            if (\"highWaterMark\" in strategy) {\n                wrappedStrategy.highWaterMark = strategy.highWaterMark;\n            }\n            if (\"size\" in strategy) {\n                wrappedStrategy.size = (chunk) => {\n                    return strategy.size!(\n                        chunk instanceof Consumable ? chunk.value : chunk,\n                    );\n                };\n            }\n        }\n\n        super(\n            {\n                start(controller) {\n                    return sink.start?.(controller);\n                },\n                write(chunk, controller) {\n                    return tryConsume(chunk, (chunk) =>\n                        sink.write?.(chunk as T, controller),\n                    );\n                },\n                abort(reason) {\n                    return sink.abort?.(reason);\n                },\n                close() {\n                    return sink.close?.();\n                },\n            },\n            wrappedStrategy,\n        );\n    }\n}\n", "import { Consumable } from \"./consumable.js\";\nimport { MaybeConsumable } from \"./maybe-consumable.js\";\nimport { TransformStream } from \"./stream.js\";\n\n/**\n * Splits or combines buffers to specified size.\n */\nexport class BufferCombiner {\n    #capacity: number;\n    readonly #buffer: Uint8Array;\n    #offset: number;\n    #available: number;\n\n    constructor(size: number) {\n        this.#capacity = size;\n        this.#buffer = new Uint8Array(size);\n        this.#offset = 0;\n        this.#available = size;\n    }\n\n    /**\n     * Pushes data to the combiner.\n     * @param data The input data to be split or combined.\n     * @returns\n     * A generator that yields buffers of specified size.\n     * It may yield the same buffer multiple times, consume the data before calling `next`.\n     */\n    *push(data: Uint8Array): Generator<Uint8Array, void, void> {\n        let offset = 0;\n        let available = data.length;\n\n        if (this.#offset !== 0) {\n            if (available >= this.#available) {\n                this.#buffer.set(\n                    data.subarray(0, this.#available),\n                    this.#offset,\n                );\n                offset += this.#available;\n                available -= this.#available;\n\n                yield this.#buffer;\n                this.#offset = 0;\n                this.#available = this.#capacity;\n\n                if (available === 0) {\n                    return;\n                }\n            } else {\n                this.#buffer.set(data, this.#offset);\n                this.#offset += available;\n                this.#available -= available;\n                return;\n            }\n        }\n\n        while (available >= this.#capacity) {\n            const end = offset + this.#capacity;\n            yield data.subarray(offset, end);\n            offset = end;\n            available -= this.#capacity;\n        }\n\n        if (available > 0) {\n            this.#buffer.set(data.subarray(offset), this.#offset);\n            this.#offset += available;\n            this.#available -= available;\n        }\n    }\n\n    flush(): Uint8Array | undefined {\n        if (this.#offset === 0) {\n            return undefined;\n        }\n\n        const output = this.#buffer.subarray(0, this.#offset);\n        this.#offset = 0;\n        this.#available = this.#capacity;\n        return output;\n    }\n}\n\nexport class DistributionStream extends TransformStream<\n    MaybeConsumable<Uint8Array>,\n    MaybeConsumable<Uint8Array>\n> {\n    constructor(size: number, combine = false) {\n        const combiner = combine ? new BufferCombiner(size) : undefined;\n        super({\n            async transform(chunk, controller) {\n                await MaybeConsumable.tryConsume(chunk, async (chunk) => {\n                    if (combiner) {\n                        for (const buffer of combiner.push(chunk)) {\n                            await Consumable.ReadableStream.enqueue(\n                                controller,\n                                buffer,\n                            );\n                        }\n                    } else {\n                        let offset = 0;\n                        let available = chunk.length;\n                        while (available > 0) {\n                            const end = offset + size;\n                            await Consumable.ReadableStream.enqueue(\n                                controller,\n                                chunk.subarray(offset, end),\n                            );\n                            offset = end;\n                            available -= size;\n                        }\n                    }\n                });\n            },\n            flush(controller) {\n                if (combiner) {\n                    const data = combiner.flush();\n                    if (data) {\n                        controller.enqueue(data);\n                    }\n                }\n            },\n        });\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\n\nimport type {\n    QueuingStrategy,\n    ReadableStreamDefaultController,\n    ReadableStreamDefaultReader,\n} from \"./stream.js\";\nimport { ReadableStream } from \"./stream.js\";\n\nexport type WrapReadableStreamStart<T> = (\n    controller: ReadableStreamDefaultController<T>,\n) => MaybePromiseLike<ReadableStream<T>>;\n\nexport interface ReadableStreamWrapper<T> {\n    start: WrapReadableStreamStart<T>;\n    cancel?: (reason?: unknown) => MaybePromiseLike<void>;\n    close?: () => MaybePromiseLike<void>;\n    error?: (reason?: unknown) => MaybePromiseLike<void>;\n}\n\nfunction getWrappedReadableStream<T>(\n    wrapper:\n        | ReadableStream<T>\n        | WrapReadableStreamStart<T>\n        | ReadableStreamWrapper<T>,\n    controller: ReadableStreamDefaultController<T>,\n) {\n    if (\"start\" in wrapper) {\n        return wrapper.start(controller);\n    } else if (typeof wrapper === \"function\") {\n        return wrapper(controller);\n    } else {\n        // Can't use `wrapper instanceof ReadableStream`\n        // Because we want to be compatible with any ReadableStream-like objects\n        return wrapper;\n    }\n}\n\n/**\n * This class has multiple usages:\n *\n * 1. Get notified when the stream is cancelled or closed.\n * 2. Synchronously create a `ReadableStream` by asynchronously return another `ReadableStream`.\n * 3. Convert native `ReadableStream`s to polyfilled ones so they can `pipe` between.\n */\nexport class WrapReadableStream<T> extends ReadableStream<T> {\n    readable!: ReadableStream<T>;\n\n    #reader!: ReadableStreamDefaultReader<T>;\n\n    constructor(\n        wrapper:\n            | ReadableStream<T>\n            | WrapReadableStreamStart<T>\n            | ReadableStreamWrapper<T>,\n        strategy?: QueuingStrategy<T>,\n    ) {\n        super(\n            {\n                start: async (controller) => {\n                    const readable = await getWrappedReadableStream(\n                        wrapper,\n                        controller,\n                    );\n                    // `start` is called in `super()`, so can't use `this` synchronously.\n                    // but it's fine after the first `await`\n                    this.readable = readable;\n                    this.#reader = this.readable.getReader();\n                },\n                pull: async (controller) => {\n                    const { done, value } = await this.#reader\n                        .read()\n                        .catch((e) => {\n                            if (\"error\" in wrapper) {\n                                wrapper.error(e);\n                            }\n                            throw e;\n                        });\n\n                    if (done) {\n                        controller.close();\n                        if (\"close\" in wrapper) {\n                            await wrapper.close?.();\n                        }\n                    } else {\n                        controller.enqueue(value);\n                    }\n                },\n                cancel: async (reason) => {\n                    await this.#reader.cancel(reason);\n                    if (\"cancel\" in wrapper) {\n                        await wrapper.cancel?.(reason);\n                    }\n                },\n            },\n            strategy,\n        );\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport { PromiseResolver } from \"@yume-chan/async\";\n\nimport type {\n    QueuingStrategy,\n    ReadableStream,\n    ReadableStreamDefaultController,\n    WritableStreamDefaultWriter,\n} from \"./stream.js\";\nimport { WritableStream } from \"./stream.js\";\nimport { tryClose } from \"./try-close.js\";\nimport { WrapReadableStream } from \"./wrap-readable.js\";\n\nconst NOOP = () => {\n    // no-op\n};\n\nexport interface DuplexStreamFactoryOptions {\n    /**\n     * Callback when any `ReadableStream` is cancelled (the user doesn't need any more data),\n     * or `WritableStream` is ended (the user won't produce any more data),\n     * or `DuplexStreamFactory#close` is called.\n     *\n     * Usually you want to let the other peer know that the duplex stream should be closed.\n     *\n     * `dispose` will automatically be called after `close` completes,\n     * but if you want to wait another peer for a close confirmation and call\n     * `DuplexStreamFactory#dispose` yourself, you can return `false`\n     * (or a `Promise` that resolves to `false`) to disable the automatic call.\n     */\n    close?: (() => MaybePromiseLike<boolean | void>) | undefined;\n\n    /**\n     * Callback when any `ReadableStream` is closed (the other peer doesn't produce any more data),\n     * or `WritableStream` is aborted (the other peer can't receive any more data),\n     * or `DuplexStreamFactory#abort` is called.\n     *\n     * Usually indicates the other peer has closed the duplex stream. You can clean up\n     * any resources you have allocated now.\n     */\n    dispose?: (() => void | Promise<void>) | undefined;\n}\n\n/**\n * A factory for creating a duplex stream.\n *\n * It can create multiple `ReadableStream`s and `WritableStream`s,\n * when any of them is closed, all other streams will be closed as well.\n */\nexport class DuplexStreamFactory<R, W> {\n    #readableControllers: ReadableStreamDefaultController<R>[] = [];\n    #writers: WritableStreamDefaultWriter<W>[] = [];\n\n    #writableClosed = false;\n    get writableClosed() {\n        return this.#writableClosed;\n    }\n\n    #closed = new PromiseResolver<void>();\n    get closed() {\n        return this.#closed.promise;\n    }\n\n    readonly #options: DuplexStreamFactoryOptions;\n\n    constructor(options?: DuplexStreamFactoryOptions) {\n        this.#options = options ?? {};\n    }\n\n    wrapReadable(\n        readable: ReadableStream<R>,\n        strategy?: QueuingStrategy<R>,\n    ): WrapReadableStream<R> {\n        return new WrapReadableStream<R>(\n            {\n                start: (controller) => {\n                    this.#readableControllers.push(controller);\n                    return readable;\n                },\n                cancel: async () => {\n                    // cancel means the local peer wants to close the connection.\n                    await this.close();\n                },\n                close: async () => {\n                    // stream end means the remote peer closed the connection first.\n                    await this.dispose();\n                },\n            },\n            strategy,\n        );\n    }\n\n    createWritable(stream: WritableStream<W>): WritableStream<W> {\n        const writer = stream.getWriter();\n        this.#writers.push(writer);\n\n        // `WritableStream` has no way to tell if the remote peer has closed the connection.\n        // So it only triggers `close`.\n        return new WritableStream<W>({\n            write: async (chunk) => {\n                await writer.write(chunk);\n            },\n            abort: async (reason) => {\n                await writer.abort(reason);\n                await this.close();\n            },\n            close: async () => {\n                // NOOP: the writer is already closed\n                await writer.close().catch(NOOP);\n                await this.close();\n            },\n        });\n    }\n\n    async close() {\n        if (this.#writableClosed) {\n            return;\n        }\n        this.#writableClosed = true;\n\n        // Call `close` first, so it can still write data to `WritableStream`s.\n        if ((await this.#options.close?.()) !== false) {\n            // `close` can return `false` to disable automatic `dispose`.\n            await this.dispose();\n        }\n\n        for (const writer of this.#writers) {\n            // NOOP: the writer is already closed\n            writer.close().catch(NOOP);\n        }\n    }\n\n    async dispose() {\n        this.#writableClosed = true;\n        this.#closed.resolve();\n\n        for (const controller of this.#readableControllers) {\n            tryClose(controller);\n        }\n\n        await this.#options.dispose?.();\n    }\n}\n", "import type { TransformStream } from \"./stream.js\";\n\nexport interface TextDecoderOptions {\n    fatal?: boolean;\n    ignoreBOM?: boolean;\n}\n\ndeclare class TextDecoderStreamType extends TransformStream<\n    ArrayBufferView | ArrayBuffer,\n    string\n> {\n    constructor(label?: string, options?: TextDecoderOptions);\n\n    readonly encoding: string;\n    readonly fatal: boolean;\n    readonly ignoreBOM: boolean;\n}\n\ndeclare class TextEncoderStreamType extends TransformStream<\n    string,\n    Uint8Array\n> {\n    constructor();\n\n    readonly encoding: string;\n}\n\ninterface GlobalExtension {\n    TextDecoderStream: typeof TextDecoderStreamType;\n    TextEncoderStream: typeof TextEncoderStreamType;\n}\n\nconst Global = globalThis as unknown as GlobalExtension;\n\nexport const TextDecoderStream = Global.TextDecoderStream;\nexport type TextDecoderStream = TextDecoderStreamType;\n\nexport const TextEncoderStream = Global.TextEncoderStream;\nexport type TextEncoderStream = TextEncoderStreamType;\n", "import { TransformStream } from \"./stream.js\";\n\nexport class InspectStream<T> extends TransformStream<T, T> {\n    constructor(callback: (value: T) => void) {\n        super({\n            transform(chunk, controller) {\n                callback(chunk);\n                controller.enqueue(chunk);\n            },\n        });\n    }\n}\n", "import type { ReadableWritablePair } from \"./stream.js\";\nimport { WritableStream } from \"./stream.js\";\n\n/**\n * Pipe `pair.readable` to `writable`, then returns `pair.writable`.\n *\n * This is the opposite of `ReadableStream#pipeThrough()`.\n *\n * @param writable The `WritableStream` to write to.\n * @param pair A `TransformStream` that converts chunks.\n * @returns `pair`'s `writable` stream.\n */\nexport function pipeFrom<W, T>(\n    writable: WritableStream<W>,\n    pair: ReadableWritablePair<W, T>,\n) {\n    const writer = pair.writable.getWriter();\n    const pipe = pair.readable.pipeTo(writable);\n    return new WritableStream<T>({\n        async write(chunk) {\n            await writer.write(chunk);\n        },\n        async close() {\n            await writer.close();\n            await pipe;\n        },\n    });\n}\n", "import { TransformStream } from \"./stream.js\";\n\nexport class SplitStringStream extends TransformStream<string, string> {\n    constructor(separator: string) {\n        let remaining: string | undefined = undefined;\n\n        super({\n            transform(chunk, controller) {\n                if (remaining) {\n                    chunk = remaining + chunk;\n                    remaining = undefined;\n                }\n\n                let start = 0;\n                while (start < chunk.length) {\n                    const index = chunk.indexOf(separator, start);\n                    if (index === -1) {\n                        remaining = chunk.substring(start);\n                        break;\n                    }\n\n                    controller.enqueue(chunk.substring(start, index));\n                    start = index + 1;\n                }\n            },\n            flush(controller) {\n                if (remaining) {\n                    controller.enqueue(remaining);\n                }\n            },\n        });\n    }\n}\n", "import type { StructDeserializer } from \"@yume-chan/struct\";\n\nimport { BufferedTransformStream } from \"./buffered-transform.js\";\n\nexport class StructDeserializeStream<T> extends BufferedTransformStream<T> {\n    constructor(struct: StructDeserializer<T>) {\n        super((stream) => {\n            return struct.deserialize(stream) as never;\n        });\n    }\n}\n", "import type { StructInit, StructSerializer } from \"@yume-chan/struct\";\n\nimport { TransformStream } from \"./stream.js\";\n\nexport class StructSerializeStream<\n    T extends StructSerializer<unknown>,\n> extends TransformStream<StructInit<T>, Uint8Array> {\n    constructor(struct: T) {\n        super({\n            transform(chunk, controller) {\n                controller.enqueue(struct.serialize(chunk));\n            },\n        });\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\n\nimport type { TransformStream, WritableStreamDefaultWriter } from \"./stream.js\";\nimport { WritableStream } from \"./stream.js\";\n\nexport type WrapWritableStreamStart<T> = () => MaybePromiseLike<\n    WritableStream<T>\n>;\n\nexport interface WritableStreamWrapper<T> {\n    start: WrapWritableStreamStart<T>;\n    close?(): void | Promise<void>;\n}\n\nasync function getWrappedWritableStream<T>(\n    start:\n        | WritableStream<T>\n        | WrapWritableStreamStart<T>\n        | WritableStreamWrapper<T>,\n) {\n    if (\"start\" in start) {\n        return await start.start();\n    } else if (typeof start === \"function\") {\n        return await start();\n    } else {\n        // Can't use `wrapper instanceof WritableStream`\n        // Because we want to be compatible with any WritableStream-like objects\n        return start;\n    }\n}\n\nexport class WrapWritableStream<T> extends WritableStream<T> {\n    writable!: WritableStream<T>;\n\n    #writer!: WritableStreamDefaultWriter<T>;\n\n    constructor(\n        start:\n            | WritableStream<T>\n            | WrapWritableStreamStart<T>\n            | WritableStreamWrapper<T>,\n    ) {\n        super({\n            start: async () => {\n                const writable = await getWrappedWritableStream(start);\n                // `start` is called in `super()`, so can't use `this` synchronously.\n                // but it's fine after the first `await`\n                this.writable = writable;\n                this.#writer = this.writable.getWriter();\n            },\n            write: async (chunk) => {\n                await this.#writer.write(chunk);\n            },\n            abort: async (reason) => {\n                await this.#writer.abort(reason);\n                if (start !== this.writable && \"close\" in start) {\n                    await start.close?.();\n                }\n            },\n            close: async () => {\n                // Close the inner stream first.\n                // Usually the inner stream is a logical sub-stream over the outer stream,\n                // closing the outer stream first will make the inner stream incapable of\n                // sending data in its `close` handler.\n                await this.#writer.close();\n                if (start !== this.writable && \"close\" in start) {\n                    await start.close?.();\n                }\n            },\n        });\n    }\n\n    bePipedThroughFrom<U>(transformer: TransformStream<U, T>) {\n        let promise: Promise<void>;\n        return new WrapWritableStream<U>({\n            start: () => {\n                promise = transformer.readable.pipeTo(this);\n                return transformer.writable;\n            },\n            async close() {\n                await promise;\n            },\n        });\n    }\n}\n", "export interface Disposable {\n    dispose(): void;\n}\n\nexport class AutoDisposable implements Disposable {\n    #disposables: Disposable[] = [];\n\n    constructor() {\n        this.dispose = this.dispose.bind(this);\n    }\n\n    protected addDisposable<T extends Disposable>(disposable: T): T {\n        this.#disposables.push(disposable);\n        return disposable;\n    }\n\n    dispose() {\n        for (const disposable of this.#disposables) {\n            disposable.dispose();\n        }\n\n        this.#disposables = [];\n    }\n}\n\nexport class DisposableList extends AutoDisposable {\n    add<T extends Disposable>(disposable: T): T {\n        return this.addDisposable(disposable);\n    }\n}\n", "import type { Disposable } from \"./disposable.js\";\nimport type { Event, EventListener, RemoveEventListener } from \"./event.js\";\n\nexport interface EventListenerInfo<TEvent, TResult = unknown> {\n    listener: EventListener<TEvent, unknown, unknown[], TResult>;\n\n    thisArg: unknown;\n\n    args: unknown[];\n}\n\nexport class EventEmitter<TEvent, TResult = unknown> implements Disposable {\n    protected readonly listeners: EventListenerInfo<TEvent, TResult>[] = [];\n\n    constructor() {\n        this.event = this.event.bind(this);\n    }\n\n    protected addEventListener(\n        info: EventListenerInfo<TEvent, TResult>,\n    ): RemoveEventListener {\n        this.listeners.push(info);\n\n        const remove: RemoveEventListener = () => {\n            const index = this.listeners.indexOf(info);\n            if (index !== -1) {\n                this.listeners.splice(index, 1);\n            }\n        };\n        remove.dispose = remove;\n        return remove;\n    }\n\n    event: Event<TEvent, TResult> = <TThis, TArgs extends unknown[]>(\n        listener: EventListener<TEvent, TThis, TArgs, TResult>,\n        thisArg?: TThis,\n        ...args: TArgs\n    ) => {\n        const info: EventListenerInfo<TEvent, TResult> = {\n            listener: listener as EventListener<\n                TEvent,\n                unknown,\n                unknown[],\n                TResult\n            >,\n            thisArg,\n            args,\n        };\n        return this.addEventListener(info);\n    };\n\n    fire(e: TEvent) {\n        for (const info of this.listeners.slice()) {\n            info.listener.call(info.thisArg, e, ...info.args);\n        }\n    }\n\n    dispose() {\n        this.listeners.length = 0;\n    }\n}\n", "import type { EventListenerInfo } from \"./event-emitter.js\";\nimport { EventEmitter } from \"./event-emitter.js\";\nimport type { RemoveEventListener } from \"./event.js\";\n\nconst Undefined = Symbol(\"undefined\");\n\nexport class StickyEventEmitter<TEvent, TResult = unknown> extends EventEmitter<\n    TEvent,\n    TResult\n> {\n    #value: TEvent | typeof Undefined = Undefined;\n\n    protected override addEventListener(\n        info: EventListenerInfo<TEvent, TResult>,\n    ): RemoveEventListener {\n        if (this.#value !== Undefined) {\n            info.listener.call(info.thisArg, this.#value, ...info.args);\n        }\n        return super.addEventListener(info);\n    }\n\n    override fire(e: TEvent): void {\n        this.#value = e;\n        super.fire(e);\n    }\n}\n", "import { AutoDisposable } from \"@yume-chan/event\";\n\nimport type { Adb } from \"../adb.js\";\n\nexport class AdbServiceBase extends AutoDisposable {\n    readonly #adb: Adb;\n    get adb() {\n        return this.#adb;\n    }\n\n    constructor(adb: Adb) {\n        super();\n        this.#adb = adb;\n    }\n}\n", "import { BufferedReadableStream } from \"@yume-chan/stream-extra\";\nimport type { StructValue } from \"@yume-chan/struct\";\nimport { buffer, struct, StructEmptyError, u32 } from \"@yume-chan/struct\";\n\nimport type { Adb } from \"../adb.js\";\n\nconst Version = struct({ version: u32 }, { littleEndian: true });\n\nexport const AdbFrameBufferV1 = struct(\n    {\n        bpp: u32,\n        size: u32,\n        width: u32,\n        height: u32,\n        red_offset: u32,\n        red_length: u32,\n        blue_offset: u32,\n        blue_length: u32,\n        green_offset: u32,\n        green_length: u32,\n        alpha_offset: u32,\n        alpha_length: u32,\n        data: buffer(\"size\"),\n    },\n    { littleEndian: true },\n);\n\nexport type AdbFrameBufferV1 = StructValue<typeof AdbFrameBufferV1>;\n\nexport const AdbFrameBufferV2 = struct(\n    {\n        bpp: u32,\n        colorSpace: u32,\n        size: u32,\n        width: u32,\n        height: u32,\n        red_offset: u32,\n        red_length: u32,\n        blue_offset: u32,\n        blue_length: u32,\n        green_offset: u32,\n        green_length: u32,\n        alpha_offset: u32,\n        alpha_length: u32,\n        data: buffer(\"size\"),\n    },\n    { littleEndian: true },\n);\n\nexport type AdbFrameBufferV2 = StructValue<typeof AdbFrameBufferV2>;\n\n/**\n * ADB uses 8 int32 fields to describe bit depths\n *\n * The only combination I have seen is RGBA8888, which is\n *\n *   red_offset:   0\n *   red_length:   8\n *   blue_offset:  16\n *   blue_length:  8\n *   green_offset: 8\n *   green_length: 8\n *   alpha_offset: 24\n *   alpha_length: 8\n *\n * But it doesn't mean that other combinations are not possible.\n */\nexport type AdbFrameBuffer = AdbFrameBufferV1 | AdbFrameBufferV2;\n\nexport abstract class AdbFrameBufferError extends Error {\n    constructor(message: string, options?: ErrorOptions) {\n        super(message, options);\n    }\n}\n\nexport class AdbFrameBufferUnsupportedVersionError extends AdbFrameBufferError {\n    constructor(version: number) {\n        super(`Unsupported FrameBuffer version ${version}`);\n    }\n}\n\nexport class AdbFrameBufferForbiddenError extends AdbFrameBufferError {\n    constructor() {\n        super(\"FrameBuffer is disabled by current app\");\n    }\n}\n\nexport async function framebuffer(adb: Adb): Promise<AdbFrameBuffer> {\n    const socket = await adb.createSocket(\"framebuffer:\");\n    const stream = new BufferedReadableStream(socket.readable);\n\n    let version: number;\n    try {\n        ({ version } = await Version.deserialize(stream));\n    } catch (e) {\n        if (e instanceof StructEmptyError) {\n            throw new AdbFrameBufferForbiddenError();\n        }\n        throw e;\n    }\n\n    switch (version) {\n        case 1:\n            // TODO: AdbFrameBuffer: does all v1 responses uses the same color space? Add it so the command returns same format for all versions.\n            return await AdbFrameBufferV1.deserialize(stream);\n        case 2:\n            return await AdbFrameBufferV2.deserialize(stream);\n        default:\n            throw new AdbFrameBufferUnsupportedVersionError(version);\n    }\n}\n", "// cspell: ignore bootloader\n// cspell: ignore fastboot\n// cspell: ignore keyevent\n// cspell: ignore longpress\n\nimport { AdbServiceBase } from \"./base.js\";\n\nexport class AdbPower extends AdbServiceBase {\n    reboot(mode = \"\") {\n        return this.adb.createSocketAndWait(`reboot:${mode}`);\n    }\n\n    bootloader() {\n        return this.reboot(\"bootloader\");\n    }\n\n    fastboot() {\n        return this.reboot(\"fastboot\");\n    }\n\n    recovery() {\n        return this.reboot(\"recovery\");\n    }\n\n    sideload() {\n        return this.reboot(\"sideload\");\n    }\n\n    /**\n     * Reboot to Qualcomm Emergency Download (EDL) Mode.\n     *\n     * Only works on some Qualcomm devices.\n     */\n    qualcommEdlMode() {\n        return this.reboot(\"edl\");\n    }\n\n    powerOff(): Promise<string> {\n        return this.adb.subprocess.noneProtocol.spawnWaitText([\"reboot\", \"-p\"]);\n    }\n\n    powerButton(longPress = false): Promise<string> {\n        const args = [\"input\", \"keyevent\"];\n        if (longPress) {\n            args.push(\"--longpress\");\n        }\n        args.push(\"POWER\");\n\n        return this.adb.subprocess.noneProtocol.spawnWaitText(args);\n    }\n\n    /**\n     * Reboot to Samsung Odin download mode.\n     *\n     * Only works on Samsung devices.\n     */\n    samsungOdin() {\n        return this.reboot(\"download\");\n    }\n}\n", "export function toLocalUint8Array(value: Uint8Array): Uint8Array<ArrayBuffer> {\n    if (value.buffer instanceof ArrayBuffer) {\n        return value as Uint8Array<ArrayBuffer>;\n    }\n\n    const copy = new Uint8Array(value.length);\n    copy.set(value);\n    return copy;\n}\n", "import { PromiseResolver } from \"@yume-chan/async\";\nimport type { Disposable } from \"@yume-chan/event\";\n\nexport class AutoResetEvent implements Disposable {\n    #set: boolean;\n    readonly #queue: PromiseResolver<void>[] = [];\n\n    constructor(initialSet = false) {\n        this.#set = initialSet;\n    }\n\n    wait(): Promise<void> {\n        if (!this.#set) {\n            this.#set = true;\n\n            if (this.#queue.length === 0) {\n                return Promise.resolve();\n            }\n        }\n\n        const resolver = new PromiseResolver<void>();\n        this.#queue.push(resolver);\n        return resolver.promise;\n    }\n\n    notifyOne() {\n        if (this.#queue.length !== 0) {\n            this.#queue.pop()!.resolve();\n        } else {\n            this.#set = false;\n        }\n    }\n\n    dispose() {\n        for (const item of this.#queue) {\n            item.reject(new Error(\"The AutoResetEvent has been disposed\"));\n        }\n        this.#queue.length = 0;\n    }\n}\n", "const [charToIndex, indexToChar, paddingChar] = /* #__PURE__ */ (() => {\n    // Array is faster than object literal or `Map`\n    const charToIndex: number[] = [];\n    const indexToChar: number[] = [];\n    const paddingChar = \"=\".charCodeAt(0);\n\n    function addRange(start: string, end: string) {\n        const charCodeStart = start.charCodeAt(0);\n        const charCodeEnd = end.charCodeAt(0);\n\n        for (\n            let charCode = charCodeStart;\n            charCode <= charCodeEnd;\n            charCode += 1\n        ) {\n            charToIndex[charCode] = indexToChar.length;\n            indexToChar.push(charCode);\n        }\n    }\n\n    addRange(\"A\", \"Z\");\n    addRange(\"a\", \"z\");\n    addRange(\"0\", \"9\");\n    addRange(\"+\", \"+\");\n    addRange(\"/\", \"/\");\n\n    return [charToIndex, indexToChar, paddingChar];\n})();\n\n/**\n * Calculate the required length of the output buffer for the given input length.\n *\n * @param inputLength Length of the input in bytes\n * @returns Length of the output in bytes\n */\nexport function calculateBase64EncodedLength(\n    inputLength: number,\n): [outputLength: number, paddingLength: number] {\n    const remainder = inputLength % 3;\n    const paddingLength = remainder !== 0 ? 3 - remainder : 0;\n    return [((inputLength + paddingLength) / 3) * 4, paddingLength];\n}\n\n/**\n * Encode the given input buffer into base64.\n *\n * @param input The input buffer\n * @returns The encoded output buffer\n */\nexport function encodeBase64(input: Uint8Array): Uint8Array<ArrayBuffer>;\n/**\n * Encode the given input into base64 and write it to the output buffer.\n *\n * The output buffer must be at least as long as the value returned by `calculateBase64EncodedLength`.\n * It can points to the same buffer as the input, as long as `output.offset <= input.offset - input.length / 3`,\n * or `output.offset >= input.offset - 1`\n *\n * @param input The input buffer\n * @param output The output buffer\n * @returns The number of bytes written to the output buffer\n */\nexport function encodeBase64(input: Uint8Array, output: Uint8Array): number;\nexport function encodeBase64(\n    input: Uint8Array,\n    output?: Uint8Array,\n): Uint8Array | number {\n    const [outputLength, paddingLength] = calculateBase64EncodedLength(\n        input.length,\n    );\n\n    if (!output) {\n        output = new Uint8Array(outputLength);\n        encodeForward(input, output, paddingLength);\n        return output;\n    } else {\n        if (output.length < outputLength) {\n            throw new TypeError(\"output buffer is too small\");\n        }\n\n        output = output.subarray(0, outputLength);\n\n        // When input and output are on same ArrayBuffer,\n        // we check if it's possible to encode in-place.\n        if (input.buffer !== output.buffer) {\n            encodeForward(input, output, paddingLength);\n        } else if (\n            output.byteOffset + output.length - (paddingLength + 1) <=\n            input.byteOffset + input.length\n        ) {\n            // Output ends before input ends.\n            // Can encode forwards, because writing output won't catch up with reading input.\n\n            // The output end is subtracted by `(paddingLength + 1)` because\n            // depending on padding length, it's possible to write 1-3 extra bytes after input ends.\n            //\n            // The following diagrams show how the last read from input and the last write to output\n            // are not conflicting.\n            //\n            // spell: disable\n            //\n            // `paddingLength === 2` can write 3 extra bytes:\n            //\n            //   input:  | aaaaaabb |          |          |          |\n            //   output: |  aaaaaa  |  bb0000  |    =     |    =     |\n            //\n            // `paddingLength === 1` can write 2 extra bytes:\n            //\n            //   input:  | aaaaaabb | bbbbcccc |          |          |\n            //   output: |  aaaaaa  |  bbbbbb  |  cccc00  |    =     |\n            //\n            // `paddingLength === 0` can write 1 extra byte:\n            //\n            //   input:  | aaaaaabb | bbbbcccc | ccdddddd |          |\n            //   output: |  aaaaaa  |  bbbbbb  |  cccccc  |  dddddd  |\n            //\n            // spell: enable\n\n            encodeForward(input, output, paddingLength);\n        } else if (output.byteOffset >= input.byteOffset - 1) {\n            // Output starts after input starts\n            // So in backwards, writing output won't catch up with reading input.\n\n            // The input start is subtracted by `1`, Because as the first 3 bytes becomes 4 bytes,\n            // it's possible to write 1 extra byte before input starts.\n            // spell: disable-next-line\n            //   input:  |          | aaaaaabb | bbbbcccc | ccdddddd |\n            //   output: |  aaaaaa  |  bbbbbb  |  cccccc  |  dddddd  |\n\n            // Must encode backwards.\n            encodeBackward(input, output, paddingLength);\n        } else {\n            // Input is in the middle of output,\n            // It's not possible to read either the first or the last three bytes\n            // before they are overwritten by the output.\n            throw new TypeError(\"input and output cannot overlap\");\n        }\n\n        return outputLength;\n    }\n}\n\nfunction encodeForward(\n    input: Uint8Array,\n    output: Uint8Array,\n    paddingLength: number,\n) {\n    let inputIndex = 0;\n    let outputIndex = 0;\n\n    while (inputIndex < input.length - 2) {\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex]!;\n        inputIndex += 1;\n\n        /* cspell: disable-next-line */\n        // bbbbcccc\n        const y = input[inputIndex]!;\n        inputIndex += 1;\n\n        /* cspell: disable-next-line */\n        // ccdddddd\n        const z = input[inputIndex]!;\n        inputIndex += 1;\n\n        output[outputIndex] = indexToChar[x >> 2]!;\n        outputIndex += 1;\n\n        output[outputIndex] = indexToChar[((x & 0b11) << 4) | (y >> 4)]!;\n        outputIndex += 1;\n\n        output[outputIndex] = indexToChar[((y & 0b1111) << 2) | (z >> 6)]!;\n        outputIndex += 1;\n\n        output[outputIndex] = indexToChar[z & 0b111111]!;\n        outputIndex += 1;\n    }\n\n    if (paddingLength === 2) {\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex]!;\n        inputIndex += 1;\n\n        output[outputIndex] = indexToChar[x >> 2]!;\n        outputIndex += 1;\n\n        output[outputIndex] = indexToChar[(x & 0b11) << 4]!;\n        outputIndex += 1;\n\n        output[outputIndex] = paddingChar;\n        outputIndex += 1;\n\n        output[outputIndex] = paddingChar;\n    } else if (paddingLength === 1) {\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex]!;\n        inputIndex += 1;\n\n        /* cspell: disable-next-line */\n        // bbbbcccc\n        const y = input[inputIndex]!;\n        inputIndex += 1;\n\n        output[outputIndex] = indexToChar[x >> 2]!;\n        outputIndex += 1;\n\n        output[outputIndex] = indexToChar[((x & 0b11) << 4) | (y >> 4)]!;\n        outputIndex += 1;\n\n        output[outputIndex] = indexToChar[(y & 0b1111) << 2]!;\n        outputIndex += 1;\n\n        output[outputIndex] = paddingChar;\n    }\n}\n\nfunction encodeBackward(\n    input: Uint8Array,\n    output: Uint8Array,\n    paddingLength: number,\n) {\n    let inputIndex = input.length - 1;\n    let outputIndex = output.length - 1;\n\n    if (paddingLength === 2) {\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex]!;\n        inputIndex -= 1;\n\n        output[outputIndex] = paddingChar;\n        outputIndex -= 1;\n\n        output[outputIndex] = paddingChar;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[(x & 0b11) << 4]!;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[x >> 2]!;\n        outputIndex -= 1;\n    } else if (paddingLength === 1) {\n        /* cspell: disable-next-line */\n        // bbbbcccc\n        const y = input[inputIndex]!;\n        inputIndex -= 1;\n\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex]!;\n        inputIndex -= 1;\n\n        output[outputIndex] = paddingChar;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[(y & 0b1111) << 2]!;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[((x & 0b11) << 4) | (y >> 4)]!;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[x >> 2]!;\n        outputIndex -= 1;\n    }\n\n    while (inputIndex >= 0) {\n        /* cspell: disable-next-line */\n        // ccdddddd\n        const z = input[inputIndex]!;\n        inputIndex -= 1;\n\n        /* cspell: disable-next-line */\n        // bbbbcccc\n        const y = input[inputIndex]!;\n        inputIndex -= 1;\n\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex]!;\n        inputIndex -= 1;\n\n        output[outputIndex] = indexToChar[z & 0b111111]!;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[((y & 0b1111) << 2) | (z >> 6)]!;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[((x & 0b11) << 4) | (y >> 4)]!;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[x >> 2]!;\n        outputIndex -= 1;\n    }\n}\n\nexport function decodeBase64(input: string): Uint8Array<ArrayBuffer> {\n    let padding: number;\n    if (input[input.length - 2] === \"=\") {\n        padding = 2;\n    } else if (input[input.length - 1] === \"=\") {\n        padding = 1;\n    } else {\n        padding = 0;\n    }\n\n    const result = new Uint8Array((input.length / 4) * 3 - padding);\n    let sIndex = 0;\n    let dIndex = 0;\n\n    while (sIndex < input.length - (padding !== 0 ? 4 : 0)) {\n        const a = charToIndex[input.charCodeAt(sIndex)]!;\n        sIndex += 1;\n\n        const b = charToIndex[input.charCodeAt(sIndex)]!;\n        sIndex += 1;\n\n        const c = charToIndex[input.charCodeAt(sIndex)]!;\n        sIndex += 1;\n\n        const d = charToIndex[input.charCodeAt(sIndex)]!;\n        sIndex += 1;\n\n        result[dIndex] = (a << 2) | ((b & 0b11_0000) >> 4);\n        dIndex += 1;\n\n        result[dIndex] = ((b & 0b1111) << 4) | ((c & 0b11_1100) >> 2);\n        dIndex += 1;\n\n        result[dIndex] = ((c & 0b11) << 6) | d;\n        dIndex += 1;\n    }\n\n    if (padding === 1) {\n        const a = charToIndex[input.charCodeAt(sIndex)]!;\n        sIndex += 1;\n\n        const b = charToIndex[input.charCodeAt(sIndex)]!;\n        sIndex += 1;\n\n        const c = charToIndex[input.charCodeAt(sIndex)]!;\n\n        result[dIndex] = (a << 2) | ((b & 0b11_0000) >> 4);\n        dIndex += 1;\n\n        result[dIndex] = ((b & 0b1111) << 4) | ((c & 0b11_1100) >> 2);\n    } else if (padding === 2) {\n        const a = charToIndex[input.charCodeAt(sIndex)]!;\n        sIndex += 1;\n\n        const b = charToIndex[input.charCodeAt(sIndex)]!;\n\n        result[dIndex] = (a << 2) | ((b & 0b11_0000) >> 4);\n    }\n\n    return result;\n}\n", "function hexCharToNumber(char: number) {\n    if (char < 48) {\n        throw new TypeError(`Invalid hex char ${char}`);\n    }\n    if (char < 58) {\n        // 0-9\n        return char - 48;\n    }\n\n    if (char < 65) {\n        throw new TypeError(`Invalid hex char ${char}`);\n    }\n    if (char < 71) {\n        // A-F\n        return char - 55;\n    }\n\n    if (char < 97) {\n        throw new TypeError(`Invalid hex char ${char}`);\n    }\n    if (char < 103) {\n        // a-f\n        return char - 87;\n    }\n\n    throw new TypeError(`Invalid hex char ${char}`);\n}\n\n// It's 22x faster than converting `data` to string then `Number.parseInt`\n// https://jsbench.me/dglha94ozl/1\nexport function hexToNumber(data: Uint8Array): number {\n    let result = 0;\n    for (let i = 0; i < data.length; i += 1) {\n        result = (result << 4) | hexCharToNumber(data[i]!);\n    }\n    return result;\n}\n\nexport function write4HexDigits(\n    buffer: Uint8Array,\n    index: number,\n    value: number,\n) {\n    const start = index;\n    index += 3;\n    while (index >= start && value > 0) {\n        const digit = value & 0xf;\n        value >>= 4;\n        if (digit < 10) {\n            buffer[index] = digit + 48; // '0'\n        } else {\n            buffer[index] = digit + 87; // 'a' - 10\n        }\n        index -= 1;\n    }\n    while (index >= start) {\n        buffer[index] = 48; // '0'\n        index -= 1;\n    }\n}\n", "/* #__NO_SIDE_EFFECTS__ */\nexport const NOOP = () => {\n    // no-op\n};\n\n/**\n * When used in `Promise#catch`, means the promise should never throw errors.\n * An explicit way to suppress ESLint floating promise warnings.\n */\nexport function unreachable(...args: unknown[]): never {\n    // Trigger runtime's unhandled rejection event.\n    throw new Error(\"Unreachable. Arguments:\\n\" + args.join(\"\\n\"));\n}\n", "interface GlobalExtension {\n    setInterval: (callback: () => void, delay: number) => number;\n    clearInterval: (id: number) => void;\n}\n\nconst { setInterval, clearInterval } = globalThis as unknown as GlobalExtension;\n\n/**\n * An object to keep current Node.js process alive even when no code is running.\n *\n * Does nothing in Web environments.\n *\n * Note that it does't have reference counting. Calling `unref` will\n * remove the ref no matter how many times `ref` has been previously called, and vice versa.\n * This is the same as how Node.js works.\n */\nexport class Ref {\n    #intervalId: number | undefined;\n\n    constructor(options?: { unref?: boolean | undefined }) {\n        if (!options?.unref) {\n            this.ref();\n        }\n    }\n\n    ref() {\n        // `setInterval` can keep current Node.js alive, the delay value doesn't matter\n        this.#intervalId = setInterval(() => {}, 60 * 1000);\n    }\n\n    unref() {\n        if (this.#intervalId) {\n            clearInterval(this.#intervalId);\n            this.#intervalId = undefined;\n        }\n    }\n}\n", "export function sequenceEqual(a: Uint8Array, b: Uint8Array): boolean {\n    if (a.length !== b.length) {\n        return false;\n    }\n\n    for (let i = 0; i < a.length; i += 1) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n", "// cspell: ignore killforward\n\nimport { BufferedReadableStream } from \"@yume-chan/stream-extra\";\nimport {\n    encodeUtf8,\n    ExactReadableEndedError,\n    extend,\n    string,\n    struct,\n} from \"@yume-chan/struct\";\n\nimport type { AdbIncomingSocketHandler } from \"../adb.js\";\nimport { hexToNumber, sequenceEqual } from \"../utils/index.js\";\n\nimport { AdbServiceBase } from \"./base.js\";\n\nexport interface AdbForwardListener {\n    deviceSerial: string;\n\n    localName: string;\n\n    remoteName: string;\n}\n\nconst AdbReverseStringResponse = struct(\n    {\n        length: string(4),\n        content: string({\n            field: \"length\",\n            convert(value: string) {\n                return Number.parseInt(value, 16);\n            },\n            back(value) {\n                return value.toString(16).padStart(4, \"0\");\n            },\n        }),\n    },\n    { littleEndian: true },\n);\n\nexport class AdbReverseError extends Error {\n    constructor(message: string) {\n        super(message);\n    }\n}\n\nexport class AdbReverseNotSupportedError extends AdbReverseError {\n    constructor() {\n        super(\n            \"ADB reverse tunnel is not supported on this device when connected wirelessly.\",\n        );\n    }\n}\n\nexport const AdbReverseErrorResponse = extend(\n    AdbReverseStringResponse,\n    {},\n    {\n        postDeserialize(value) {\n            // https://issuetracker.google.com/issues/37066218\n            // ADB on Android <9 can't create reverse tunnels when connected wirelessly (ADB over Wi-Fi),\n            // and returns this confusing \"more than one device/emulator\" error.\n            if (value.content === \"more than one device/emulator\") {\n                throw new AdbReverseNotSupportedError();\n            } else {\n                throw new AdbReverseError(value.content);\n            }\n        },\n    },\n);\n\n// Like `hexToNumber`, it's much faster than first converting `buffer` to a string\nfunction decimalToNumber(buffer: Uint8Array) {\n    let value = 0;\n    for (const byte of buffer) {\n        // Like `parseInt`, return when it encounters a non-digit character\n        if (byte < 48 || byte > 57) {\n            return value;\n        }\n        value = value * 10 + byte - 48;\n    }\n    return value;\n}\n\nconst OKAY = encodeUtf8(\"OKAY\");\n\nexport class AdbReverseService extends AdbServiceBase {\n    readonly #deviceAddressToLocalAddress = new Map<string, string>();\n\n    protected async createBufferedStream(service: string) {\n        const socket = await this.adb.createSocket(service);\n        return new BufferedReadableStream(socket.readable);\n    }\n\n    protected async sendRequest(service: string) {\n        const stream = await this.createBufferedStream(service);\n\n        const response = await stream.readExactly(4);\n        if (!sequenceEqual(response, OKAY)) {\n            await AdbReverseErrorResponse.deserialize(stream);\n        }\n\n        return stream;\n    }\n\n    /**\n     * Get a list of all reverse port forwarding on the device.\n     */\n    async list(): Promise<AdbForwardListener[]> {\n        const stream = await this.createBufferedStream(\"reverse:list-forward\");\n\n        const response = await AdbReverseStringResponse.deserialize(stream);\n        return response.content\n            .split(\"\\n\")\n            .filter((line) => !!line)\n            .map((line) => {\n                const [deviceSerial, localName, remoteName] = line.split(\n                    \" \",\n                ) as [string, string, string];\n                return { deviceSerial, localName, remoteName };\n            });\n\n        // No need to close the stream, device will close it\n    }\n\n    /**\n     * Add a reverse port forwarding for a program that already listens on a port.\n     */\n    async addExternal(deviceAddress: string, localAddress: string) {\n        const stream = await this.sendRequest(\n            `reverse:forward:${deviceAddress};${localAddress}`,\n        );\n\n        // `tcp:0` tells the device to pick an available port.\n        // On Android >=8, device will respond with the selected port for all `tcp:` requests.\n        if (deviceAddress.startsWith(\"tcp:\")) {\n            const position = stream.position;\n            try {\n                const length = hexToNumber(await stream.readExactly(4));\n                const port = decimalToNumber(await stream.readExactly(length));\n                deviceAddress = `tcp:${port}`;\n            } catch (e) {\n                if (\n                    e instanceof ExactReadableEndedError &&\n                    stream.position === position\n                ) {\n                    // Android <8 doesn't have this response.\n                    // (the stream is closed now)\n                    // Can be safely ignored.\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        return deviceAddress;\n    }\n\n    /**\n     * Add a reverse port forwarding.\n     */\n    async add(\n        deviceAddress: string,\n        handler: AdbIncomingSocketHandler,\n        localAddress?: string,\n    ): Promise<string> {\n        localAddress = await this.adb.transport.addReverseTunnel(\n            handler,\n            localAddress,\n        );\n\n        try {\n            deviceAddress = await this.addExternal(deviceAddress, localAddress);\n            this.#deviceAddressToLocalAddress.set(deviceAddress, localAddress);\n            return deviceAddress;\n        } catch (e) {\n            await this.adb.transport.removeReverseTunnel(localAddress);\n            throw e;\n        }\n    }\n\n    /**\n     * Remove a reverse port forwarding.\n     */\n    async remove(deviceAddress: string): Promise<void> {\n        const localAddress =\n            this.#deviceAddressToLocalAddress.get(deviceAddress);\n        if (localAddress) {\n            await this.adb.transport.removeReverseTunnel(localAddress);\n        }\n\n        await this.sendRequest(`reverse:killforward:${deviceAddress}`);\n\n        // No need to close the stream, device will close it\n    }\n\n    /**\n     * Remove all reverse port forwarding, including the ones added by other programs.\n     */\n    async removeAll(): Promise<void> {\n        await this.adb.transport.clearReverseTunnels();\n        this.#deviceAddressToLocalAddress.clear();\n\n        await this.sendRequest(`reverse:killforward-all`);\n\n        // No need to close the stream, device will close it\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport { PromiseResolver } from \"@yume-chan/async\";\nimport type {\n    AbortSignal,\n    MaybeConsumable,\n    ReadableStream,\n    WritableStream,\n} from \"@yume-chan/stream-extra\";\n\nimport type { AdbSocket } from \"../../../adb.js\";\n\nimport type { AdbNoneProtocolProcess } from \"./spawner.js\";\n\nexport class AdbNoneProtocolProcessImpl implements AdbNoneProtocolProcess {\n    readonly #socket: AdbSocket;\n\n    get stdin(): WritableStream<MaybeConsumable<Uint8Array>> {\n        return this.#socket.writable;\n    }\n\n    get output(): ReadableStream<Uint8Array> {\n        return this.#socket.readable;\n    }\n\n    readonly #exited: Promise<undefined>;\n    get exited(): Promise<undefined> {\n        return this.#exited;\n    }\n\n    constructor(socket: AdbSocket, signal?: AbortSignal) {\n        this.#socket = socket;\n\n        if (signal) {\n            // `signal` won't affect `this.output`\n            // So remaining data can still be read\n            // (call `controller.error` will discard all pending data)\n\n            const exited = new PromiseResolver<undefined>();\n            this.#socket.closed.then(\n                () => exited.resolve(undefined),\n                (e) => exited.reject(e),\n            );\n            signal.addEventListener(\"abort\", () => {\n                exited.reject(signal.reason);\n                this.#socket.close();\n            });\n            this.#exited = exited.promise;\n        } else {\n            this.#exited = this.#socket.closed;\n        }\n    }\n\n    kill(): MaybePromiseLike<void> {\n        return this.#socket.close();\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport type {\n    ReadableStream,\n    WritableStream,\n    WritableStreamDefaultWriter,\n} from \"@yume-chan/stream-extra\";\nimport { MaybeConsumable } from \"@yume-chan/stream-extra\";\n\nimport type { AdbSocket } from \"../../../adb.js\";\nimport type { AdbPtyProcess } from \"../pty.js\";\n\nexport class AdbNoneProtocolPtyProcess implements AdbPtyProcess<undefined> {\n    readonly #socket: AdbSocket;\n    readonly #writer: WritableStreamDefaultWriter<MaybeConsumable<Uint8Array>>;\n\n    readonly #input: MaybeConsumable.WritableStream<Uint8Array>;\n    get input(): WritableStream<MaybeConsumable<Uint8Array>> {\n        return this.#input;\n    }\n\n    get output(): ReadableStream<Uint8Array> {\n        return this.#socket.readable;\n    }\n\n    get exited(): Promise<undefined> {\n        return this.#socket.closed;\n    }\n\n    constructor(socket: AdbSocket) {\n        this.#socket = socket;\n\n        this.#writer = this.#socket.writable.getWriter();\n        this.#input = new MaybeConsumable.WritableStream<Uint8Array>({\n            write: (chunk) => this.#writer.write(chunk),\n        });\n    }\n\n    sigint() {\n        return this.#writer.write(new Uint8Array([0x03]));\n    }\n\n    kill(): MaybePromiseLike<void> {\n        return this.#socket.close();\n    }\n}\n", "export function escapeArg(s: string) {\n    let result = \"\";\n    result += `'`;\n\n    let base = 0;\n    while (true) {\n        const found = s.indexOf(`'`, base);\n        if (found === -1) {\n            result += s.substring(base);\n            break;\n        }\n        result += s.substring(base, found);\n        // a'b becomes a'\\'b (the backslash is not a escape character)\n        result += String.raw`'\\''`;\n        base = found + 1;\n    }\n\n    result += `'`;\n    return result;\n}\n\nexport function splitCommand(command: string): string[] {\n    const result: string[] = [];\n    let quote: string | undefined;\n    let isEscaped = false;\n    let start = 0;\n\n    for (let i = 0, len = command.length; i < len; i += 1) {\n        if (isEscaped) {\n            isEscaped = false;\n            continue;\n        }\n\n        const char = command.charAt(i);\n        switch (char) {\n            case \" \":\n                if (!quote && i !== start) {\n                    result.push(command.substring(start, i));\n                    start = i + 1;\n                }\n                break;\n            case \"'\":\n            case '\"':\n                if (!quote) {\n                    quote = char;\n                } else if (char === quote) {\n                    quote = undefined;\n                }\n                break;\n            case \"\\\\\":\n                isEscaped = true;\n                break;\n        }\n    }\n\n    if (start < command.length) {\n        result.push(command.substring(start));\n    }\n\n    return result;\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport type {\n    AbortSignal,\n    MaybeConsumable,\n    ReadableStream,\n    WritableStream,\n} from \"@yume-chan/stream-extra\";\nimport {\n    ConcatBufferStream,\n    ConcatStringStream,\n    TextDecoderStream,\n} from \"@yume-chan/stream-extra\";\n\nimport { splitCommand } from \"../utils.js\";\n\nexport interface AdbNoneProtocolProcess {\n    get stdin(): WritableStream<MaybeConsumable<Uint8Array>>;\n\n    /**\n     * Mix of stdout and stderr\n     */\n    get output(): ReadableStream<Uint8Array>;\n\n    get exited(): Promise<void>;\n\n    kill(): MaybePromiseLike<void>;\n}\n\nexport class AdbNoneProtocolSpawner {\n    readonly #spawn: (\n        command: readonly string[],\n        signal: AbortSignal | undefined,\n    ) => Promise<AdbNoneProtocolProcess>;\n\n    constructor(\n        spawn: (\n            command: readonly string[],\n            signal: AbortSignal | undefined,\n        ) => Promise<AdbNoneProtocolProcess>,\n    ) {\n        this.#spawn = spawn;\n    }\n\n    spawn(\n        command: string | readonly string[],\n        signal?: AbortSignal,\n    ): Promise<AdbNoneProtocolProcess> {\n        signal?.throwIfAborted();\n\n        if (typeof command === \"string\") {\n            command = splitCommand(command);\n        }\n\n        return this.#spawn(command, signal);\n    }\n\n    async spawnWait(command: string | readonly string[]): Promise<Uint8Array> {\n        const process = await this.spawn(command);\n        return await process.output.pipeThrough(new ConcatBufferStream());\n    }\n\n    async spawnWaitText(command: string | readonly string[]): Promise<string> {\n        const process = await this.spawn(command);\n        return await process.output\n            .pipeThrough(new TextDecoderStream())\n            .pipeThrough(new ConcatStringStream());\n    }\n}\n", "import type { Adb } from \"../../../adb.js\";\n\nimport { AdbNoneProtocolProcessImpl } from \"./process.js\";\nimport { AdbNoneProtocolPtyProcess } from \"./pty.js\";\nimport { AdbNoneProtocolSpawner } from \"./spawner.js\";\n\nexport class AdbNoneProtocolSubprocessService extends AdbNoneProtocolSpawner {\n    readonly #adb: Adb;\n    get adb(): Adb {\n        return this.#adb;\n    }\n\n    constructor(adb: Adb) {\n        super(async (command, signal) => {\n            // `shell,raw:${command}` also triggers raw mode,\n            // But is not supported on Android version <7.\n            const socket = await this.#adb.createSocket(\n                `exec:${command.join(\" \")}`,\n            );\n\n            if (signal?.aborted) {\n                await socket.close();\n                throw signal.reason;\n            }\n\n            return new AdbNoneProtocolProcessImpl(socket, signal);\n        });\n        this.#adb = adb;\n    }\n\n    async pty(\n        command?: string | readonly string[],\n    ): Promise<AdbNoneProtocolPtyProcess> {\n        if (command === undefined) {\n            command = \"\";\n        } else if (Array.isArray(command)) {\n            command = command.join(\" \");\n        }\n\n        return new AdbNoneProtocolPtyProcess(\n            // https://github.com/microsoft/typescript/issues/17002\n            await this.#adb.createSocket(`shell:${command as string}`),\n        );\n    }\n}\n", "// The order follows\n// https://cs.android.com/android/platform/superproject/+/master:packages/modules/adb/transport.cpp;l=77;drc=6d14d35d0241f6fee145f8e54ffd77252e8d29fd\nexport const AdbFeature = {\n    ShellV2: \"shell_v2\",\n    Cmd: \"cmd\",\n    StatV2: \"stat_v2\",\n    ListV2: \"ls_v2\",\n    FixedPushMkdir: \"fixed_push_mkdir\",\n    Abb: \"abb\",\n    AbbExec: \"abb_exec\",\n    SendReceiveV2: \"sendrecv_v2\",\n    DelayedAck: \"delayed_ack\",\n} as const;\n\nexport type AdbFeature = (typeof AdbFeature)[keyof typeof AdbFeature];\n", "import type { StructValue } from \"@yume-chan/struct\";\nimport { buffer, struct, u32, u8 } from \"@yume-chan/struct\";\n\nexport const AdbShellProtocolId = {\n    Stdin: 0,\n    Stdout: 1,\n    Stderr: 2,\n    Exit: 3,\n    CloseStdin: 4,\n    WindowSizeChange: 5,\n} as const;\n\nexport type AdbShellProtocolId =\n    (typeof AdbShellProtocolId)[keyof typeof AdbShellProtocolId];\n\n// This packet format is used in both directions.\nexport const AdbShellProtocolPacket = struct(\n    {\n        id: u8<AdbShellProtocolId>(),\n        data: buffer(u32),\n    },\n    { littleEndian: true },\n);\n\nexport type AdbShellProtocolPacket = StructValue<typeof AdbShellProtocolPacket>;\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport { PromiseResolver } from \"@yume-chan/async\";\nimport type {\n    AbortSignal,\n    PushReadableStreamController,\n    ReadableStream,\n    WritableStreamDefaultWriter,\n} from \"@yume-chan/stream-extra\";\nimport {\n    MaybeConsumable,\n    PushReadableStream,\n    StructDeserializeStream,\n    WritableStream,\n} from \"@yume-chan/stream-extra\";\nimport { EmptyUint8Array } from \"@yume-chan/struct\";\n\nimport type { AdbSocket } from \"../../../adb.js\";\n\nimport { AdbShellProtocolId, AdbShellProtocolPacket } from \"./shared.js\";\nimport type { AdbShellProtocolProcess } from \"./spawner.js\";\n\nexport class AdbShellProtocolProcessImpl implements AdbShellProtocolProcess {\n    readonly #socket: AdbSocket;\n    readonly #writer: WritableStreamDefaultWriter<MaybeConsumable<Uint8Array>>;\n\n    readonly #stdin: WritableStream<MaybeConsumable<Uint8Array>>;\n    get stdin() {\n        return this.#stdin;\n    }\n\n    readonly #stdout: ReadableStream<Uint8Array>;\n    get stdout() {\n        return this.#stdout;\n    }\n\n    readonly #stderr: ReadableStream<Uint8Array>;\n    get stderr() {\n        return this.#stderr;\n    }\n\n    readonly #exited: Promise<number>;\n    get exited() {\n        return this.#exited;\n    }\n\n    constructor(socket: AdbSocket, signal?: AbortSignal) {\n        this.#socket = socket;\n\n        let stdoutController!: PushReadableStreamController<Uint8Array>;\n        let stderrController!: PushReadableStreamController<Uint8Array>;\n        this.#stdout = new PushReadableStream<Uint8Array>((controller) => {\n            stdoutController = controller;\n        });\n        this.#stderr = new PushReadableStream<Uint8Array>((controller) => {\n            stderrController = controller;\n        });\n\n        const exited = new PromiseResolver<number>();\n        this.#exited = exited.promise;\n\n        socket.readable\n            .pipeThrough(new StructDeserializeStream(AdbShellProtocolPacket))\n            .pipeTo(\n                new WritableStream<AdbShellProtocolPacket>({\n                    write: async (chunk) => {\n                        switch (chunk.id) {\n                            case AdbShellProtocolId.Exit:\n                                exited.resolve(chunk.data[0]!);\n                                break;\n                            case AdbShellProtocolId.Stdout:\n                                await stdoutController.enqueue(chunk.data);\n                                break;\n                            case AdbShellProtocolId.Stderr:\n                                await stderrController.enqueue(chunk.data);\n                                break;\n                            default:\n                                // Ignore unknown messages like Google ADB does\n                                // https://cs.android.com/android/platform/superproject/main/+/main:packages/modules/adb/daemon/shell_service.cpp;l=684;drc=61197364367c9e404c7da6900658f1b16c42d0da\n                                break;\n                        }\n                    },\n                }),\n            )\n            .then(\n                () => {\n                    stdoutController.close();\n                    stderrController.close();\n                    // If `exited` has already settled, this will be a no-op\n                    exited.reject(\n                        new Error(\"Socket ended without exit message\"),\n                    );\n                },\n                (e) => {\n                    stdoutController.error(e);\n                    stderrController.error(e);\n                    // If `exited` has already settled, this will be a no-op\n                    exited.reject(e);\n                },\n            );\n\n        if (signal) {\n            // `signal` won't affect `this.stdout` and `this.stderr`\n            // So remaining data can still be read\n            // (call `controller.error` will discard all pending data)\n\n            signal.addEventListener(\"abort\", () => {\n                exited.reject(signal.reason);\n                this.#socket.close();\n            });\n        }\n\n        this.#writer = this.#socket.writable.getWriter();\n        this.#stdin = new MaybeConsumable.WritableStream<Uint8Array>({\n            write: async (chunk) => {\n                await this.#writer.write(\n                    AdbShellProtocolPacket.serialize({\n                        id: AdbShellProtocolId.Stdin,\n                        data: chunk,\n                    }),\n                );\n            },\n            close: () =>\n                // Only shell protocol + raw mode supports closing stdin\n                this.#writer.write(\n                    AdbShellProtocolPacket.serialize({\n                        id: AdbShellProtocolId.CloseStdin,\n                        data: EmptyUint8Array,\n                    }),\n                ),\n        });\n    }\n\n    kill(): MaybePromiseLike<void> {\n        return this.#socket.close();\n    }\n}\n", "import { PromiseResolver } from \"@yume-chan/async\";\nimport type {\n    PushReadableStreamController,\n    ReadableStream,\n    WritableStreamDefaultWriter,\n} from \"@yume-chan/stream-extra\";\nimport {\n    MaybeConsumable,\n    PushReadableStream,\n    StructDeserializeStream,\n    WritableStream,\n} from \"@yume-chan/stream-extra\";\nimport { encodeUtf8 } from \"@yume-chan/struct\";\n\nimport type { AdbSocket } from \"../../../adb.js\";\nimport type { AdbPtyProcess } from \"../pty.js\";\n\nimport { AdbShellProtocolId, AdbShellProtocolPacket } from \"./shared.js\";\n\nexport class AdbShellProtocolPtyProcess implements AdbPtyProcess<number> {\n    readonly #socket: AdbSocket;\n    readonly #writer: WritableStreamDefaultWriter<MaybeConsumable<Uint8Array>>;\n\n    readonly #input: WritableStream<MaybeConsumable<Uint8Array>>;\n    get input() {\n        return this.#input;\n    }\n\n    readonly #stdout: ReadableStream<Uint8Array>;\n    get output() {\n        return this.#stdout;\n    }\n\n    readonly #exited = new PromiseResolver<number>();\n    get exited() {\n        return this.#exited.promise;\n    }\n\n    constructor(socket: AdbSocket) {\n        this.#socket = socket;\n\n        let stdoutController!: PushReadableStreamController<Uint8Array>;\n        this.#stdout = new PushReadableStream<Uint8Array>((controller) => {\n            stdoutController = controller;\n        });\n\n        socket.readable\n            .pipeThrough(new StructDeserializeStream(AdbShellProtocolPacket))\n            .pipeTo(\n                new WritableStream<AdbShellProtocolPacket>({\n                    write: async (chunk) => {\n                        switch (chunk.id) {\n                            case AdbShellProtocolId.Exit:\n                                this.#exited.resolve(chunk.data[0]!);\n                                break;\n                            case AdbShellProtocolId.Stdout:\n                                await stdoutController.enqueue(chunk.data);\n                                break;\n                        }\n                    },\n                }),\n            )\n            .then(\n                () => {\n                    stdoutController.close();\n                    // If `#exit` has already resolved, this will be a no-op\n                    this.#exited.reject(\n                        new Error(\"Socket ended without exit message\"),\n                    );\n                },\n                (e) => {\n                    stdoutController.error(e);\n                    // If `#exit` has already resolved, this will be a no-op\n                    this.#exited.reject(e);\n                },\n            );\n\n        this.#writer = this.#socket.writable.getWriter();\n        this.#input = new MaybeConsumable.WritableStream<Uint8Array>({\n            write: (chunk) => this.#writeStdin(chunk),\n        });\n    }\n\n    #writeStdin(chunk: Uint8Array) {\n        return this.#writer.write(\n            AdbShellProtocolPacket.serialize({\n                id: AdbShellProtocolId.Stdin,\n                data: chunk,\n            }),\n        );\n    }\n\n    async resize(rows: number, cols: number) {\n        await this.#writer.write(\n            AdbShellProtocolPacket.serialize({\n                id: AdbShellProtocolId.WindowSizeChange,\n                // The \"correct\" format is `${rows}x${cols},${x_pixels}x${y_pixels}`\n                // However, according to https://linux.die.net/man/4/tty_ioctl\n                // `x_pixels` and `y_pixels` are unused, so always sending `0` should be fine.\n                data: encodeUtf8(`${rows}x${cols},0x0\\0`),\n            }),\n        );\n    }\n\n    sigint() {\n        return this.#writeStdin(new Uint8Array([0x03]));\n    }\n\n    kill() {\n        return this.#socket.close();\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport type {\n    AbortSignal,\n    MaybeConsumable,\n    ReadableStream,\n    WritableStream,\n} from \"@yume-chan/stream-extra\";\nimport {\n    ConcatBufferStream,\n    ConcatStringStream,\n    TextDecoderStream,\n} from \"@yume-chan/stream-extra\";\n\nimport { splitCommand } from \"../utils.js\";\n\nexport interface AdbShellProtocolProcess {\n    get stdin(): WritableStream<MaybeConsumable<Uint8Array>>;\n\n    get stdout(): ReadableStream<Uint8Array>;\n    get stderr(): ReadableStream<Uint8Array>;\n\n    get exited(): Promise<number>;\n\n    kill(): MaybePromiseLike<void>;\n}\n\nexport class AdbShellProtocolSpawner {\n    readonly #spawn: (\n        command: readonly string[],\n        signal: AbortSignal | undefined,\n    ) => Promise<AdbShellProtocolProcess>;\n\n    constructor(\n        spawn: (\n            command: readonly string[],\n            signal: AbortSignal | undefined,\n        ) => Promise<AdbShellProtocolProcess>,\n    ) {\n        this.#spawn = spawn;\n    }\n\n    spawn(\n        command: string | readonly string[],\n        signal?: AbortSignal,\n    ): Promise<AdbShellProtocolProcess> {\n        signal?.throwIfAborted();\n\n        if (typeof command === \"string\") {\n            command = splitCommand(command);\n        }\n\n        return this.#spawn(command, signal);\n    }\n\n    async spawnWait(\n        command: string | readonly string[],\n    ): Promise<AdbShellProtocolSpawner.WaitResult<Uint8Array>> {\n        const process = await this.spawn(command);\n        const [stdout, stderr, exitCode] = await Promise.all([\n            process.stdout.pipeThrough(new ConcatBufferStream()),\n            process.stderr.pipeThrough(new ConcatBufferStream()),\n            process.exited,\n        ]);\n        return { stdout, stderr, exitCode };\n    }\n\n    async spawnWaitText(\n        command: string | readonly string[],\n    ): Promise<AdbShellProtocolSpawner.WaitResult<string>> {\n        const process = await this.spawn(command);\n        const [stdout, stderr, exitCode] = await Promise.all([\n            process.stdout\n                .pipeThrough(new TextDecoderStream())\n                .pipeThrough(new ConcatStringStream()),\n            process.stderr\n                .pipeThrough(new TextDecoderStream())\n                .pipeThrough(new ConcatStringStream()),\n            process.exited,\n        ]);\n        return { stdout, stderr, exitCode };\n    }\n}\n\nexport namespace AdbShellProtocolSpawner {\n    export interface WaitResult<T> {\n        stdout: T;\n        stderr: T;\n        exitCode: number;\n    }\n}\n", "import type { Adb } from \"../../../adb.js\";\nimport { AdbFeature } from \"../../../features.js\";\n\nimport { AdbShellProtocolProcessImpl } from \"./process.js\";\nimport { AdbShellProtocolPtyProcess } from \"./pty.js\";\nimport { AdbShellProtocolSpawner } from \"./spawner.js\";\n\nexport class AdbShellProtocolSubprocessService extends AdbShellProtocolSpawner {\n    readonly #adb: Adb;\n    get adb() {\n        return this.#adb;\n    }\n\n    get isSupported() {\n        return this.#adb.canUseFeature(AdbFeature.ShellV2);\n    }\n\n    constructor(adb: Adb) {\n        super(async (command, signal) => {\n            const socket = await this.#adb.createSocket(\n                `shell,v2,raw:${command.join(\" \")}`,\n            );\n\n            if (signal?.aborted) {\n                await socket.close();\n                throw signal.reason;\n            }\n\n            return new AdbShellProtocolProcessImpl(socket, signal);\n        });\n        this.#adb = adb;\n    }\n\n    async pty(options?: {\n        command?: string | readonly string[] | undefined;\n        terminalType?: string;\n    }): Promise<AdbShellProtocolPtyProcess> {\n        let service = \"shell,v2,pty\";\n\n        if (options?.terminalType) {\n            service += `,TERM=` + options.terminalType;\n        }\n\n        service += \":\";\n\n        if (options) {\n            if (typeof options.command === \"string\") {\n                service += options.command;\n            } else if (Array.isArray(options.command)) {\n                service += options.command.join(\" \");\n            }\n        }\n\n        return new AdbShellProtocolPtyProcess(\n            await this.#adb.createSocket(service),\n        );\n    }\n}\n", "import type { Adb } from \"../../adb.js\";\nimport { AdbFeature } from \"../../features.js\";\n\nimport { AdbNoneProtocolSubprocessService } from \"./none/index.js\";\nimport { AdbShellProtocolSubprocessService } from \"./shell/index.js\";\n\nexport class AdbSubprocessService {\n    readonly #adb: Adb;\n    get adb() {\n        return this.#adb;\n    }\n\n    readonly #noneProtocol: AdbNoneProtocolSubprocessService;\n    get noneProtocol(): AdbNoneProtocolSubprocessService {\n        return this.#noneProtocol;\n    }\n\n    readonly #shellProtocol?: AdbShellProtocolSubprocessService;\n    get shellProtocol(): AdbShellProtocolSubprocessService | undefined {\n        return this.#shellProtocol;\n    }\n\n    constructor(adb: Adb) {\n        this.#adb = adb;\n\n        this.#noneProtocol = new AdbNoneProtocolSubprocessService(adb);\n\n        if (adb.canUseFeature(AdbFeature.ShellV2)) {\n            this.#shellProtocol = new AdbShellProtocolSubprocessService(adb);\n        }\n    }\n}\n", "import { getUint32LittleEndian } from \"@yume-chan/no-data-view\";\nimport type { AsyncExactReadable, StructDeserializer } from \"@yume-chan/struct\";\nimport { decodeUtf8, string, struct, u32 } from \"@yume-chan/struct\";\n\nimport { unreachable } from \"../../utils/no-op.js\";\n\nfunction encodeAsciiUnchecked(value: string): Uint8Array<ArrayBuffer> {\n    const result = new Uint8Array(value.length);\n    for (let i = 0; i < value.length; i += 1) {\n        result[i] = value.charCodeAt(i);\n    }\n    return result;\n}\n\n/**\n * Encode ID to numbers for faster comparison\n * @param value A 4-character string\n * @returns A 32-bit integer by encoding the string as little-endian\n *\n * #__NO_SIDE_EFFECTS__\n */\nexport function adbSyncEncodeId(value: string): number {\n    const buffer = encodeAsciiUnchecked(value);\n    return getUint32LittleEndian(buffer, 0);\n}\n\nexport const AdbSyncResponseId = {\n    Entry: adbSyncEncodeId(\"DENT\"),\n    Entry2: adbSyncEncodeId(\"DNT2\"),\n    Lstat: adbSyncEncodeId(\"STAT\"),\n    Stat: adbSyncEncodeId(\"STA2\"),\n    Lstat2: adbSyncEncodeId(\"LST2\"),\n    Done: adbSyncEncodeId(\"DONE\"),\n    Data: adbSyncEncodeId(\"DATA\"),\n    Ok: adbSyncEncodeId(\"OKAY\"),\n    Fail: adbSyncEncodeId(\"FAIL\"),\n};\n\nexport class AdbSyncError extends Error {}\n\nexport const AdbSyncFailResponse = struct(\n    { message: string(u32) },\n    {\n        littleEndian: true,\n        postDeserialize(value) {\n            throw new AdbSyncError(value.message);\n        },\n    },\n);\n\nexport async function adbSyncReadResponse<T>(\n    stream: AsyncExactReadable,\n    id: number | string,\n    type: StructDeserializer<T>,\n): Promise<T> {\n    if (typeof id === \"string\") {\n        id = adbSyncEncodeId(id);\n    }\n\n    const buffer = await stream.readExactly(4);\n    switch (getUint32LittleEndian(buffer, 0)) {\n        case AdbSyncResponseId.Fail:\n            await AdbSyncFailResponse.deserialize(stream);\n            throw new Error(\"Unreachable\");\n        case id:\n            return await type.deserialize(stream);\n        default:\n            throw new Error(\n                `Expected '${id}', but got '${decodeUtf8(buffer)}'`,\n            );\n    }\n}\n\nexport async function* adbSyncReadResponses<T>(\n    stream: AsyncExactReadable,\n    id: number | string,\n    type: StructDeserializer<T>,\n): AsyncGenerator<T, void, void> {\n    if (typeof id === \"string\") {\n        id = adbSyncEncodeId(id);\n    }\n\n    while (true) {\n        const buffer = await stream.readExactly(4);\n        switch (getUint32LittleEndian(buffer, 0)) {\n            case AdbSyncResponseId.Fail:\n                await AdbSyncFailResponse.deserialize(stream);\n                unreachable();\n            case AdbSyncResponseId.Done:\n                // `DONE` responses' size are always same as the request's normal response.\n                //\n                // For example, `DONE` responses for `LIST` requests are 16 bytes (same as `DENT` responses),\n                // but `DONE` responses for `STAT` requests are 12 bytes (same as `STAT` responses).\n                await stream.readExactly(type.size);\n                return;\n            case id:\n                yield await type.deserialize(stream);\n                break;\n            default:\n                throw new Error(\n                    `Expected '${id}' or '${AdbSyncResponseId.Done}', but got '${decodeUtf8(buffer)}'`,\n                );\n        }\n    }\n}\n", "import { encodeUtf8, struct, u32 } from \"@yume-chan/struct\";\n\nimport { adbSyncEncodeId } from \"./response.js\";\n\nexport const AdbSyncRequestId = {\n    List: adbSyncEncodeId(\"LIST\"),\n    ListV2: adbSyncEncodeId(\"LIS2\"),\n    Send: adbSyncEncodeId(\"SEND\"),\n    SendV2: adbSyncEncodeId(\"SND2\"),\n    Lstat: adbSyncEncodeId(\"STAT\"),\n    Stat: adbSyncEncodeId(\"STA2\"),\n    LstatV2: adbSyncEncodeId(\"LST2\"),\n    Data: adbSyncEncodeId(\"DATA\"),\n    Done: adbSyncEncodeId(\"DONE\"),\n    Receive: adbSyncEncodeId(\"RECV\"),\n} as const;\n\nexport const AdbSyncNumberRequest = struct(\n    { id: u32, arg: u32 },\n    { littleEndian: true },\n);\n\nexport interface AdbSyncWritable {\n    write(buffer: Uint8Array): Promise<void>;\n}\n\nexport async function adbSyncWriteRequest(\n    writable: AdbSyncWritable,\n    id: number | string,\n    value: number | string | Uint8Array,\n): Promise<void> {\n    if (typeof id === \"string\") {\n        id = adbSyncEncodeId(id);\n    }\n\n    if (typeof value === \"number\") {\n        await writable.write(\n            AdbSyncNumberRequest.serialize({ id, arg: value }),\n        );\n        return;\n    }\n\n    if (typeof value === \"string\") {\n        value = encodeUtf8(value);\n    }\n\n    // `writable` is buffered, it copies inputs to an internal buffer,\n    // so don't concatenate headers and data here, that will be an unnecessary copy.\n    await writable.write(\n        AdbSyncNumberRequest.serialize({ id, arg: value.length }),\n    );\n    await writable.write(value);\n}\n", "import type { StructValue } from \"@yume-chan/struct\";\nimport { struct, u32, u64 } from \"@yume-chan/struct\";\n\nimport { AdbSyncRequestId, adbSyncWriteRequest } from \"./request.js\";\nimport { AdbSyncResponseId, adbSyncReadResponse } from \"./response.js\";\nimport type { AdbSyncSocket } from \"./socket.js\";\n\n// https://github.com/python/cpython/blob/4e581d64b8aff3e2eda99b12f080c877bb78dfca/Lib/stat.py#L36\nexport const LinuxFileType = {\n    Directory: 0o04,\n    File: 0o10,\n    Link: 0o12,\n} as const;\n\nexport type LinuxFileType = (typeof LinuxFileType)[keyof typeof LinuxFileType];\n\nexport interface AdbSyncStat {\n    mode: number;\n    size: bigint;\n    mtime: bigint;\n    get type(): LinuxFileType;\n    get permission(): number;\n\n    uid?: number;\n    gid?: number;\n    atime?: bigint;\n    ctime?: bigint;\n}\n\nexport const AdbSyncLstatResponse = struct(\n    { mode: u32, size: u32, mtime: u32 },\n    {\n        littleEndian: true,\n        extra: {\n            get type(): LinuxFileType {\n                return (this.mode >> 12) as LinuxFileType;\n            },\n            get permission(): number {\n                return this.mode & 0b00001111_11111111;\n            },\n        },\n        postDeserialize(value) {\n            if (value.mode === 0 && value.size === 0 && value.mtime === 0) {\n                throw new Error(\"lstat error\");\n            }\n            return value;\n        },\n    },\n);\n\nexport type AdbSyncLstatResponse = StructValue<typeof AdbSyncLstatResponse>;\n\nexport const AdbSyncStatErrorCode = {\n    SUCCESS: 0,\n    EACCES: 13,\n    EEXIST: 17,\n    EFAULT: 14,\n    EFBIG: 27,\n    EINTR: 4,\n    EINVAL: 22,\n    EIO: 5,\n    EISDIR: 21,\n    ELOOP: 40,\n    EMFILE: 24,\n    ENAMETOOLONG: 36,\n    ENFILE: 23,\n    ENOENT: 2,\n    ENOMEM: 12,\n    ENOSPC: 28,\n    ENOTDIR: 20,\n    EOVERFLOW: 75,\n    EPERM: 1,\n    EROFS: 30,\n    ETXTBSY: 26,\n} as const;\n\nexport type AdbSyncStatErrorCode =\n    (typeof AdbSyncStatErrorCode)[keyof typeof AdbSyncStatErrorCode];\n\nconst AdbSyncStatErrorName = /* #__PURE__ */ (() =>\n    Object.fromEntries(\n        Object.entries(AdbSyncStatErrorCode).map(([key, value]) => [\n            value,\n            key,\n        ]),\n    ))();\n\nexport const AdbSyncStatResponse = struct(\n    {\n        error: u32<AdbSyncStatErrorCode>(),\n        dev: u64,\n        ino: u64,\n        mode: u32,\n        nlink: u32,\n        uid: u32,\n        gid: u32,\n        size: u64,\n        atime: u64,\n        mtime: u64,\n        ctime: u64,\n    },\n    {\n        littleEndian: true,\n        extra: {\n            get type(): LinuxFileType {\n                return (this.mode >> 12) as LinuxFileType;\n            },\n            get permission(): number {\n                return this.mode & 0b00001111_11111111;\n            },\n        },\n        postDeserialize(value) {\n            if (value.error) {\n                throw new Error(AdbSyncStatErrorName[value.error]);\n            }\n            return value;\n        },\n    },\n);\n\nexport type AdbSyncStatResponse = StructValue<typeof AdbSyncStatResponse>;\n\nexport async function adbSyncLstat(\n    socket: AdbSyncSocket,\n    path: string,\n    v2: boolean,\n): Promise<AdbSyncStat> {\n    const locked = await socket.lock();\n    try {\n        if (v2) {\n            await adbSyncWriteRequest(locked, AdbSyncRequestId.LstatV2, path);\n            return await adbSyncReadResponse(\n                locked,\n                AdbSyncResponseId.Lstat2,\n                AdbSyncStatResponse,\n            );\n        } else {\n            await adbSyncWriteRequest(locked, AdbSyncRequestId.Lstat, path);\n            const response = await adbSyncReadResponse(\n                locked,\n                AdbSyncResponseId.Lstat,\n                AdbSyncLstatResponse,\n            );\n            return {\n                mode: response.mode,\n                // Convert to `BigInt` to make it compatible with `AdbSyncStatResponse`\n                size: BigInt(response.size),\n                mtime: BigInt(response.mtime),\n                get type() {\n                    return response.type;\n                },\n                get permission() {\n                    return response.permission;\n                },\n            };\n        }\n    } finally {\n        locked.release();\n    }\n}\n\nexport async function adbSyncStat(\n    socket: AdbSyncSocket,\n    path: string,\n): Promise<AdbSyncStatResponse> {\n    const locked = await socket.lock();\n    try {\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.Stat, path);\n        return await adbSyncReadResponse(\n            locked,\n            AdbSyncResponseId.Stat,\n            AdbSyncStatResponse,\n        );\n    } finally {\n        locked.release();\n    }\n}\n", "import type { StructValue } from \"@yume-chan/struct\";\nimport { extend, string, u32 } from \"@yume-chan/struct\";\n\nimport { AdbSyncRequestId, adbSyncWriteRequest } from \"./request.js\";\nimport { AdbSyncResponseId, adbSyncReadResponses } from \"./response.js\";\nimport type { AdbSyncSocket } from \"./socket.js\";\nimport type { AdbSyncStat } from \"./stat.js\";\nimport {\n    AdbSyncLstatResponse,\n    AdbSyncStatErrorCode,\n    AdbSyncStatResponse,\n} from \"./stat.js\";\n\nexport interface AdbSyncEntry extends AdbSyncStat {\n    name: string;\n}\n\nexport const AdbSyncEntryResponse = extend(AdbSyncLstatResponse, {\n    name: string(u32),\n});\n\nexport type AdbSyncEntryResponse = StructValue<typeof AdbSyncEntryResponse>;\n\nexport const AdbSyncEntry2Response = extend(AdbSyncStatResponse, {\n    name: string(u32),\n});\n\nexport type AdbSyncEntry2Response = StructValue<typeof AdbSyncEntry2Response>;\n\nexport async function* adbSyncOpenDirV2(\n    socket: AdbSyncSocket,\n    path: string,\n): AsyncGenerator<AdbSyncEntry2Response, void, void> {\n    const locked = await socket.lock();\n    try {\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.ListV2, path);\n        for await (const item of adbSyncReadResponses(\n            locked,\n            AdbSyncResponseId.Entry2,\n            AdbSyncEntry2Response,\n        )) {\n            // `LST2` can return error codes for failed `lstat` calls.\n            // `LIST` just ignores them.\n            // But they only contain `name` so still pretty useless.\n            if (item.error !== AdbSyncStatErrorCode.SUCCESS) {\n                continue;\n            }\n            yield item;\n        }\n    } finally {\n        locked.release();\n    }\n}\n\nexport async function* adbSyncOpenDirV1(\n    socket: AdbSyncSocket,\n    path: string,\n): AsyncGenerator<AdbSyncEntryResponse, void, void> {\n    const locked = await socket.lock();\n    try {\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.List, path);\n        for await (const item of adbSyncReadResponses(\n            locked,\n            AdbSyncResponseId.Entry,\n            AdbSyncEntryResponse,\n        )) {\n            yield item;\n        }\n    } finally {\n        locked.release();\n    }\n}\n\nexport async function* adbSyncOpenDir(\n    socket: AdbSyncSocket,\n    path: string,\n    v2: boolean,\n): AsyncGenerator<AdbSyncEntry, void, void> {\n    if (v2) {\n        yield* adbSyncOpenDirV2(socket, path);\n    } else {\n        for await (const item of adbSyncOpenDirV1(socket, path)) {\n            // Convert to same format as `AdbSyncEntry2Response` for easier consumption.\n            // However it will add some overhead.\n            yield {\n                mode: item.mode,\n                size: BigInt(item.size),\n                mtime: BigInt(item.mtime),\n                get type() {\n                    return item.type;\n                },\n                get permission() {\n                    return item.permission;\n                },\n                name: item.name,\n            };\n        }\n    }\n}\n", "import { ReadableStream } from \"@yume-chan/stream-extra\";\nimport type { StructValue } from \"@yume-chan/struct\";\nimport { buffer, struct, u32 } from \"@yume-chan/struct\";\n\nimport { AdbSyncRequestId, adbSyncWriteRequest } from \"./request.js\";\nimport { adbSyncReadResponses, AdbSyncResponseId } from \"./response.js\";\nimport type { AdbSyncSocket } from \"./socket.js\";\n\nexport const AdbSyncDataResponse = struct(\n    { data: buffer(u32) },\n    { littleEndian: true },\n);\n\nexport type AdbSyncDataResponse = StructValue<typeof AdbSyncDataResponse>;\n\nexport async function* adbSyncPullGenerator(\n    socket: AdbSyncSocket,\n    path: string,\n): AsyncGenerator<Uint8Array, void, void> {\n    const locked = await socket.lock();\n    let done = false;\n    try {\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.Receive, path);\n        for await (const packet of adbSyncReadResponses(\n            locked,\n            AdbSyncResponseId.Data,\n            AdbSyncDataResponse,\n        )) {\n            yield packet.data;\n        }\n        done = true;\n    } catch (e) {\n        done = true;\n        throw e;\n    } finally {\n        if (!done) {\n            // sync pull can't be cancelled, so we have to read all data\n            for await (const packet of adbSyncReadResponses(\n                locked,\n                AdbSyncResponseId.Data,\n                AdbSyncDataResponse,\n            )) {\n                void packet;\n            }\n        }\n        locked.release();\n    }\n}\n\nexport function adbSyncPull(\n    socket: AdbSyncSocket,\n    path: string,\n): ReadableStream<Uint8Array> {\n    return ReadableStream.from(adbSyncPullGenerator(socket, path));\n}\n", "import type { ReadableStream } from \"@yume-chan/stream-extra\";\nimport {\n    AbortController,\n    DistributionStream,\n    MaybeConsumable,\n} from \"@yume-chan/stream-extra\";\nimport { struct, u32 } from \"@yume-chan/struct\";\n\nimport { NOOP } from \"../../utils/index.js\";\n\nimport { AdbSyncRequestId, adbSyncWriteRequest } from \"./request.js\";\nimport { AdbSyncResponseId, adbSyncReadResponse } from \"./response.js\";\nimport type { AdbSyncSocket, AdbSyncSocketLocked } from \"./socket.js\";\nimport { LinuxFileType } from \"./stat.js\";\n\nexport const ADB_SYNC_MAX_PACKET_SIZE = 64 * 1024;\n\nexport interface AdbSyncPushV1Options {\n    socket: AdbSyncSocket;\n    filename: string;\n    file: ReadableStream<MaybeConsumable<Uint8Array>>;\n    type?: LinuxFileType;\n    permission?: number;\n    mtime?: number;\n    packetSize?: number;\n}\n\nexport const AdbSyncOkResponse = struct(\n    { unused: u32 },\n    { littleEndian: true },\n);\n\nasync function pipeFileData(\n    locked: AdbSyncSocketLocked,\n    file: ReadableStream<MaybeConsumable<Uint8Array>>,\n    packetSize: number,\n    mtime: number,\n) {\n    // Read and write in parallel,\n    // allow error response to abort the write.\n    const abortController = new AbortController();\n    file.pipeThrough(new DistributionStream(packetSize, true))\n        .pipeTo(\n            new MaybeConsumable.WritableStream({\n                write(chunk) {\n                    return adbSyncWriteRequest(\n                        locked,\n                        AdbSyncRequestId.Data,\n                        chunk,\n                    );\n                },\n            }),\n            { signal: abortController.signal },\n        )\n        .then(async () => {\n            await adbSyncWriteRequest(locked, AdbSyncRequestId.Done, mtime);\n            await locked.flush();\n        }, NOOP);\n\n    await adbSyncReadResponse(\n        locked,\n        AdbSyncResponseId.Ok,\n        AdbSyncOkResponse,\n    ).catch((e) => {\n        abortController.abort();\n        throw e;\n    });\n}\n\nexport async function adbSyncPushV1({\n    socket,\n    filename,\n    file,\n    type = LinuxFileType.File,\n    permission = 0o666,\n    mtime = (Date.now() / 1000) | 0,\n    packetSize = ADB_SYNC_MAX_PACKET_SIZE,\n}: AdbSyncPushV1Options) {\n    const locked = await socket.lock();\n    try {\n        const mode = (type << 12) | permission;\n        const pathAndMode = `${filename},${mode.toString()}`;\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.Send, pathAndMode);\n        await pipeFileData(locked, file, packetSize, mtime);\n    } finally {\n        locked.release();\n    }\n}\n\nexport const AdbSyncSendV2Flags = {\n    None: 0,\n    Brotli: 1,\n    /**\n     * 2\n     */\n    Lz4: 1 << 1,\n    /**\n     * 4\n     */\n    Zstd: 1 << 2,\n    DryRun: 0x80000000,\n} as const;\n\nexport type AdbSyncSendV2Flags =\n    (typeof AdbSyncSendV2Flags)[keyof typeof AdbSyncSendV2Flags];\n\nexport interface AdbSyncPushV2Options extends AdbSyncPushV1Options {\n    /**\n     * Don't write the file to disk. Requires the `sendrecv_v2` feature.\n     *\n     * It was used during ADB development to benchmark the performance of\n     * compression algorithms.\n     */\n    dryRun?: boolean;\n}\n\nexport const AdbSyncSendV2Request = struct(\n    { id: u32, mode: u32, flags: u32<AdbSyncSendV2Flags>() },\n    { littleEndian: true },\n);\n\nexport async function adbSyncPushV2({\n    socket,\n    filename,\n    file,\n    type = LinuxFileType.File,\n    permission = 0o666,\n    mtime = (Date.now() / 1000) | 0,\n    packetSize = ADB_SYNC_MAX_PACKET_SIZE,\n    dryRun = false,\n}: AdbSyncPushV2Options) {\n    const locked = await socket.lock();\n    try {\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.SendV2, filename);\n\n        const mode = (type << 12) | permission;\n        let flags: AdbSyncSendV2Flags = AdbSyncSendV2Flags.None;\n        if (dryRun) {\n            flags |= AdbSyncSendV2Flags.DryRun;\n        }\n        await locked.write(\n            AdbSyncSendV2Request.serialize({\n                id: AdbSyncRequestId.SendV2,\n                mode,\n                flags,\n            }),\n        );\n\n        await pipeFileData(locked, file, packetSize, mtime);\n    } finally {\n        locked.release();\n    }\n}\n\nexport interface AdbSyncPushOptions extends AdbSyncPushV2Options {\n    /**\n     * Whether to use the v2 protocol. Requires the `sendrecv_v2` feature.\n     */\n    v2: boolean;\n}\n\nexport function adbSyncPush(options: AdbSyncPushOptions) {\n    if (options.v2) {\n        return adbSyncPushV2(options);\n    }\n\n    if (options.dryRun) {\n        throw new Error(\"dryRun is not supported in v1\");\n    }\n\n    return adbSyncPushV1(options);\n}\n", "import type {\n    MaybeConsumable,\n    WritableStreamDefaultWriter,\n} from \"@yume-chan/stream-extra\";\nimport {\n    BufferCombiner,\n    BufferedReadableStream,\n    Consumable,\n} from \"@yume-chan/stream-extra\";\nimport type { AsyncExactReadable } from \"@yume-chan/struct\";\n\nimport type { AdbSocket } from \"../../adb.js\";\nimport { AutoResetEvent } from \"../../utils/index.js\";\n\nexport class AdbSyncSocketLocked implements AsyncExactReadable {\n    readonly #writer: WritableStreamDefaultWriter<MaybeConsumable<Uint8Array>>;\n    readonly #readable: BufferedReadableStream;\n    readonly #socketLock: AutoResetEvent;\n    readonly #writeLock = new AutoResetEvent();\n    readonly #combiner: BufferCombiner;\n\n    get position() {\n        return this.#readable.position;\n    }\n\n    constructor(\n        writer: WritableStreamDefaultWriter<MaybeConsumable<Uint8Array>>,\n        readable: BufferedReadableStream,\n        bufferSize: number,\n        lock: AutoResetEvent,\n    ) {\n        this.#writer = writer;\n        this.#readable = readable;\n        this.#socketLock = lock;\n        this.#combiner = new BufferCombiner(bufferSize);\n    }\n\n    #write(buffer: Uint8Array) {\n        // `#combiner` will reuse the buffer, so we need to use the Consumable pattern\n        return Consumable.WritableStream.write(this.#writer, buffer);\n    }\n\n    async flush() {\n        try {\n            await this.#writeLock.wait();\n            const buffer = this.#combiner.flush();\n            if (buffer) {\n                await this.#write(buffer);\n            }\n        } finally {\n            this.#writeLock.notifyOne();\n        }\n    }\n\n    async write(data: Uint8Array) {\n        try {\n            await this.#writeLock.wait();\n            for (const buffer of this.#combiner.push(data)) {\n                await this.#write(buffer);\n            }\n        } finally {\n            this.#writeLock.notifyOne();\n        }\n    }\n\n    async readExactly(length: number) {\n        // The request may still be in the internal buffer.\n        // Call `flush` to send it before starting reading\n        await this.flush();\n        return await this.#readable.readExactly(length);\n    }\n\n    release(): void {\n        // In theory, the writer shouldn't leave anything in the buffer,\n        // but to be safe, call `flush` to throw away any remaining data.\n        this.#combiner.flush();\n        this.#socketLock.notifyOne();\n    }\n\n    async close() {\n        await this.#readable.cancel();\n    }\n}\n\nexport class AdbSyncSocket {\n    readonly #lock = new AutoResetEvent();\n    readonly #socket: AdbSocket;\n    readonly #locked: AdbSyncSocketLocked;\n\n    constructor(socket: AdbSocket, bufferSize: number) {\n        this.#socket = socket;\n        this.#locked = new AdbSyncSocketLocked(\n            socket.writable.getWriter(),\n            new BufferedReadableStream(socket.readable),\n            bufferSize,\n            this.#lock,\n        );\n    }\n\n    async lock() {\n        await this.#lock.wait();\n        return this.#locked;\n    }\n\n    async close() {\n        await this.#locked.close();\n        await this.#socket.close();\n    }\n}\n", "import type { MaybeConsumable, ReadableStream } from \"@yume-chan/stream-extra\";\n\nimport type { Adb, AdbSocket } from \"../../adb.js\";\nimport { AdbFeature } from \"../../features.js\";\nimport { escapeArg } from \"../subprocess/index.js\";\n\nimport type { AdbSyncEntry } from \"./list.js\";\nimport { adbSyncOpenDir } from \"./list.js\";\nimport { adbSyncPull } from \"./pull.js\";\nimport { adbSyncPush } from \"./push.js\";\nimport type { AdbSyncSocketLocked } from \"./socket.js\";\nimport { AdbSyncSocket } from \"./socket.js\";\nimport type { AdbSyncStat, LinuxFileType } from \"./stat.js\";\nimport { adbSyncLstat, adbSyncStat } from \"./stat.js\";\n\n/**\n * A simplified `dirname` function that only handles absolute unix paths.\n * @param path an absolute unix path\n * @returns the directory name of the input path\n */\nexport function dirname(path: string): string {\n    const end = path.lastIndexOf(\"/\");\n    if (end === -1) {\n        throw new Error(`Invalid path`);\n    }\n    if (end === 0) {\n        return \"/\";\n    }\n    return path.substring(0, end);\n}\n\nexport interface AdbSyncWriteOptions {\n    filename: string;\n    file: ReadableStream<MaybeConsumable<Uint8Array>>;\n    type?: LinuxFileType;\n    permission?: number;\n    mtime?: number;\n    dryRun?: boolean;\n}\n\nexport class AdbSync {\n    protected _adb: Adb;\n    protected _socket: AdbSyncSocket;\n\n    readonly #supportsStat: boolean;\n    readonly #supportsListV2: boolean;\n    readonly #fixedPushMkdir: boolean;\n    readonly #supportsSendReceiveV2: boolean;\n    readonly #needPushMkdirWorkaround: boolean;\n\n    get supportsStat(): boolean {\n        return this.#supportsStat;\n    }\n\n    get supportsListV2(): boolean {\n        return this.#supportsListV2;\n    }\n\n    get fixedPushMkdir(): boolean {\n        return this.#fixedPushMkdir;\n    }\n\n    get supportsSendReceiveV2(): boolean {\n        return this.#supportsSendReceiveV2;\n    }\n\n    get needPushMkdirWorkaround(): boolean {\n        return this.#needPushMkdirWorkaround;\n    }\n\n    constructor(adb: Adb, socket: AdbSocket) {\n        this._adb = adb;\n        this._socket = new AdbSyncSocket(socket, adb.maxPayloadSize);\n\n        this.#supportsStat = adb.canUseFeature(AdbFeature.StatV2);\n        this.#supportsListV2 = adb.canUseFeature(AdbFeature.ListV2);\n        this.#fixedPushMkdir = adb.canUseFeature(AdbFeature.FixedPushMkdir);\n        this.#supportsSendReceiveV2 = adb.canUseFeature(\n            AdbFeature.SendReceiveV2,\n        );\n        // https://android.googlesource.com/platform/packages/modules/adb/+/91768a57b7138166e0a3d11f79cd55909dda7014/client/file_sync_client.cpp#1361\n        this.#needPushMkdirWorkaround =\n            this._adb.canUseFeature(AdbFeature.ShellV2) && !this.fixedPushMkdir;\n    }\n\n    /**\n     * Gets information of a file or folder.\n     *\n     * If `path` points to a symbolic link, the returned information is about the link itself (with `type` being `LinuxFileType.Link`).\n     */\n    async lstat(path: string): Promise<AdbSyncStat> {\n        return await adbSyncLstat(this._socket, path, this.#supportsStat);\n    }\n\n    /**\n     * Gets the information of a file or folder.\n     *\n     * If `path` points to a symbolic link, it will be resolved and the returned information is about the target (with `type` being `LinuxFileType.File` or `LinuxFileType.Directory`).\n     */\n    async stat(path: string) {\n        if (!this.#supportsStat) {\n            throw new Error(\"Not supported\");\n        }\n\n        return await adbSyncStat(this._socket, path);\n    }\n\n    /**\n     * Checks if `path` is a directory, or a symbolic link to a directory.\n     *\n     * This uses `lstat` internally, thus works on all Android versions.\n     */\n    async isDirectory(path: string): Promise<boolean> {\n        try {\n            await this.lstat(path + \"/\");\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    opendir(path: string): AsyncGenerator<AdbSyncEntry, void, void> {\n        return adbSyncOpenDir(this._socket, path, this.supportsListV2);\n    }\n\n    async readdir(path: string) {\n        const results: AdbSyncEntry[] = [];\n        for await (const entry of this.opendir(path)) {\n            results.push(entry);\n        }\n        return results;\n    }\n\n    /**\n     * Reads the content of a file on device.\n     *\n     * @param filename The full path of the file on device to read.\n     * @returns A `ReadableStream` that contains the file content.\n     */\n    read(filename: string): ReadableStream<Uint8Array> {\n        return adbSyncPull(this._socket, filename);\n    }\n\n    /**\n     * Writes a file on device. If the file name already exists, it will be overwritten.\n     *\n     * @param options The content and options of the file to write.\n     */\n    async write(options: AdbSyncWriteOptions): Promise<void> {\n        if (this.needPushMkdirWorkaround) {\n            // It may fail if `filename` already exists.\n            // Ignore the result.\n            // TODO: sync: test push mkdir workaround (need an Android 8 device)\n            await this._adb.subprocess.noneProtocol.spawnWait([\n                \"mkdir\",\n                \"-p\",\n                escapeArg(dirname(options.filename)),\n            ]);\n        }\n\n        await adbSyncPush({\n            v2: this.supportsSendReceiveV2,\n            socket: this._socket,\n            ...options,\n        });\n    }\n\n    lockSocket(): Promise<AdbSyncSocketLocked> {\n        return this._socket.lock();\n    }\n\n    dispose() {\n        return this._socket.close();\n    }\n}\n", "import { AdbServiceBase } from \"./base.js\";\n\n/**\n * ADB daemon checks for the following properties in the order of\n *\n * * `serviceListenAddresses` (`service.adb.listen_addrs`)\n * * `servicePort` (`service.adb.tcp.port`)\n * * `persistPort` (`persist.adb.tcp.port`)\n *\n * Once it finds a non-empty value, it will use it and ignore the rest.\n *\n * `serviceListenAddresses` and `persistPort` are fixed at build time,\n * only `servicePort` can be changed using `setPort` and `disable`.\n * This means if either `serviceListenAddresses` or `persistPort` is non-empty,\n * ADB over WiFi is always enabled.\n */\nexport interface AdbTcpIpListenAddresses {\n    serviceListenAddresses: string[];\n    servicePort: number | undefined;\n    persistPort: number | undefined;\n}\n\nfunction parsePort(value: string): number | undefined {\n    if (!value || value === \"0\") {\n        return undefined;\n    }\n    return Number.parseInt(value, 10);\n}\n\nexport class AdbTcpIpService extends AdbServiceBase {\n    async getListenAddresses(): Promise<AdbTcpIpListenAddresses> {\n        const serviceListenAddresses = await this.adb.getProp(\n            \"service.adb.listen_addrs\",\n        );\n        const servicePort = await this.adb.getProp(\"service.adb.tcp.port\");\n        const persistPort = await this.adb.getProp(\"persist.adb.tcp.port\");\n\n        return {\n            serviceListenAddresses:\n                serviceListenAddresses != \"\"\n                    ? serviceListenAddresses.split(\",\")\n                    : [],\n            servicePort: parsePort(servicePort),\n            persistPort: parsePort(persistPort),\n        };\n    }\n\n    async setPort(port: number): Promise<string> {\n        if (port <= 0) {\n            throw new TypeError(`Invalid port ${port}`);\n        }\n\n        const output = await this.adb.createSocketAndWait(`tcpip:${port}`);\n        if (output !== `restarting in TCP mode port: ${port}\\n`) {\n            throw new Error(output);\n        }\n        return output;\n    }\n\n    async disable(): Promise<string> {\n        const output = await this.adb.createSocketAndWait(\"usb:\");\n        if (output !== \"restarting in USB mode\\n\") {\n            throw new Error(output);\n        }\n        return output;\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport type {\n    MaybeConsumable,\n    ReadableWritablePair,\n} from \"@yume-chan/stream-extra\";\nimport { ConcatStringStream, TextDecoderStream } from \"@yume-chan/stream-extra\";\n\nimport type { AdbBanner } from \"./banner.js\";\nimport type { AdbFrameBuffer } from \"./commands/index.js\";\nimport {\n    AdbPower,\n    AdbReverseService,\n    AdbSubprocessService,\n    AdbSync,\n    AdbTcpIpService,\n    escapeArg,\n    framebuffer,\n} from \"./commands/index.js\";\nimport type { AdbFeature } from \"./features.js\";\n\nexport interface Closeable {\n    close(): MaybePromiseLike<void>;\n}\n\n/**\n * Represents an ADB socket.\n */\nexport interface AdbSocket\n    extends ReadableWritablePair<Uint8Array, MaybeConsumable<Uint8Array>>,\n        Closeable {\n    get service(): string;\n\n    get closed(): Promise<undefined>;\n}\n\nexport type AdbIncomingSocketHandler = (\n    socket: AdbSocket,\n) => MaybePromiseLike<void>;\n\nexport interface AdbTransport extends Closeable {\n    readonly serial: string;\n\n    readonly maxPayloadSize: number;\n\n    readonly banner: AdbBanner;\n\n    readonly disconnected: Promise<void>;\n\n    readonly clientFeatures: readonly AdbFeature[];\n\n    connect(service: string): MaybePromiseLike<AdbSocket>;\n\n    addReverseTunnel(\n        handler: AdbIncomingSocketHandler,\n        address?: string,\n    ): MaybePromiseLike<string>;\n\n    removeReverseTunnel(address: string): MaybePromiseLike<void>;\n\n    clearReverseTunnels(): MaybePromiseLike<void>;\n}\n\nexport class Adb implements Closeable {\n    readonly #transport: AdbTransport;\n    get transport(): AdbTransport {\n        return this.#transport;\n    }\n\n    get serial() {\n        return this.#transport.serial;\n    }\n\n    get maxPayloadSize() {\n        return this.#transport.maxPayloadSize;\n    }\n\n    get banner() {\n        return this.#transport.banner;\n    }\n\n    get disconnected() {\n        return this.#transport.disconnected;\n    }\n\n    public get clientFeatures() {\n        return this.#transport.clientFeatures;\n    }\n\n    public get deviceFeatures() {\n        return this.banner.features;\n    }\n\n    readonly subprocess: AdbSubprocessService;\n    readonly power: AdbPower;\n    readonly reverse: AdbReverseService;\n    readonly tcpip: AdbTcpIpService;\n\n    constructor(transport: AdbTransport) {\n        this.#transport = transport;\n\n        this.subprocess = new AdbSubprocessService(this);\n        this.power = new AdbPower(this);\n        this.reverse = new AdbReverseService(this);\n        this.tcpip = new AdbTcpIpService(this);\n    }\n\n    canUseFeature(feature: AdbFeature): boolean {\n        return (\n            this.clientFeatures.includes(feature) &&\n            this.deviceFeatures.includes(feature)\n        );\n    }\n\n    /**\n     * Creates a new ADB Socket to the specified service or socket address.\n     */\n    async createSocket(service: string): Promise<AdbSocket> {\n        return this.#transport.connect(service);\n    }\n\n    async createSocketAndWait(service: string): Promise<string> {\n        const socket = await this.createSocket(service);\n        return await socket.readable\n            .pipeThrough(new TextDecoderStream())\n            .pipeThrough(new ConcatStringStream());\n    }\n\n    getProp(key: string): Promise<string> {\n        return this.subprocess.noneProtocol\n            .spawnWaitText([\"getprop\", key])\n            .then((output) => output.trim());\n    }\n\n    rm(\n        filenames: string | readonly string[],\n        options?: { recursive?: boolean; force?: boolean },\n    ): Promise<string> {\n        const args = [\"rm\"];\n        if (options?.recursive) {\n            args.push(\"-r\");\n        }\n        if (options?.force) {\n            args.push(\"-f\");\n        }\n        if (Array.isArray(filenames)) {\n            for (const filename of filenames) {\n                // https://github.com/microsoft/typescript/issues/17002\n                args.push(escapeArg(filename as string));\n            }\n        } else {\n            // https://github.com/microsoft/typescript/issues/17002\n            args.push(escapeArg(filenames as string));\n        }\n        // https://android.googlesource.com/platform/packages/modules/adb/+/1a0fb8846d4e6b671c8aa7f137a8c21d7b248716/client/adb_install.cpp#984\n        args.push(\"</dev/null\");\n\n        return this.subprocess.noneProtocol.spawnWaitText(args);\n    }\n\n    async sync(): Promise<AdbSync> {\n        const socket = await this.createSocket(\"sync:\");\n        return new AdbSync(this, socket);\n    }\n\n    async framebuffer(): Promise<AdbFrameBuffer> {\n        return framebuffer(this);\n    }\n\n    async close(): Promise<void> {\n        await this.#transport.close();\n    }\n}\n", "import type { AdbFeature } from \"./features.js\";\n\nexport const AdbBannerKey = {\n    Product: \"ro.product.name\",\n    Model: \"ro.product.model\",\n    Device: \"ro.product.device\",\n    Features: \"features\",\n} as const;\n\nexport type AdbBannerKey = (typeof AdbBannerKey)[keyof typeof AdbBannerKey];\n\nexport class AdbBanner {\n    static parse(banner: string) {\n        let product: string | undefined;\n        let model: string | undefined;\n        let device: string | undefined;\n        let features: AdbFeature[] = [];\n\n        const pieces = banner.split(\"::\");\n        if (pieces.length > 1) {\n            const props = pieces[1]!;\n            for (const prop of props.split(\";\")) {\n                // istanbul ignore if\n                if (!prop) {\n                    continue;\n                }\n\n                const keyValue = prop.split(\"=\");\n                if (keyValue.length !== 2) {\n                    continue;\n                }\n\n                const [key, value] = keyValue;\n                switch (key) {\n                    case AdbBannerKey.Product:\n                        product = value;\n                        break;\n                    case AdbBannerKey.Model:\n                        model = value;\n                        break;\n                    case AdbBannerKey.Device:\n                        device = value;\n                        break;\n                    case AdbBannerKey.Features:\n                        features = value!.split(\",\") as AdbFeature[];\n                        break;\n                }\n            }\n        }\n\n        return new AdbBanner(product, model, device, features);\n    }\n\n    readonly #product: string | undefined;\n    get product() {\n        return this.#product;\n    }\n\n    readonly #model: string | undefined;\n    get model() {\n        return this.#model;\n    }\n\n    readonly #device: string | undefined;\n    get device() {\n        return this.#device;\n    }\n\n    readonly #features: readonly AdbFeature[] = [];\n    get features() {\n        return this.#features;\n    }\n\n    constructor(\n        product: string | undefined,\n        model: string | undefined,\n        device: string | undefined,\n        features: readonly AdbFeature[],\n    ) {\n        this.#product = product;\n        this.#model = model;\n        this.#device = device;\n        this.#features = features;\n    }\n}\n", "import {\n    getUint64BigEndian,\n    setInt64BigEndian,\n    setInt64LittleEndian,\n} from \"@yume-chan/no-data-view\";\n\n/**\n * Gets the `BigInt` value at the specified byte offset and length from the start of the view. There is\n * no alignment constraint; multi-byte values may be fetched from any offset.\n *\n * Only supports Big-Endian, because that's what ADB uses.\n * @param byteOffset The place in the buffer at which the value should be retrieved.\n */\nexport function getBigUint(\n    array: Uint8Array,\n    byteOffset: number,\n    length: number,\n): bigint {\n    let result = 0n;\n\n    // Currently `length` must be a multiplication of 8\n    // Support for arbitrary length can be easily added\n\n    for (let i = byteOffset; i < byteOffset + length; i += 8) {\n        result <<= 64n;\n        const value = getUint64BigEndian(array, i);\n        result |= value;\n    }\n\n    return result;\n}\n\n/**\n * Stores an arbitrary-precision positive `BigInt` value at the specified byte offset from the start of the view.\n * @param byteOffset The place in the buffer at which the value should be set.\n * @param length The number of bytes to set.\n * @param value The value to set.\n * @param littleEndian If `false` or `undefined`, a big-endian value should be written,\n * otherwise a little-endian value should be written.\n */\n\n// eslint-disable-next-line @typescript-eslint/max-params\nexport function setBigUint(\n    array: Uint8Array,\n    byteOffset: number,\n    length: number,\n    value: bigint,\n    littleEndian?: boolean,\n) {\n    if (littleEndian) {\n        while (value > 0n) {\n            setInt64LittleEndian(array, byteOffset, value);\n            byteOffset += 8;\n            value >>= 64n;\n        }\n    } else {\n        let position = byteOffset + length - 8;\n        while (value > 0n) {\n            setInt64BigEndian(array, position, value);\n            position -= 8;\n            value >>= 64n;\n        }\n    }\n}\n\n// These values are correct only if\n// modulus length is 2048 and\n// public exponent (e) is 65537\n// Anyway, that's how this library generates keys\n\n// To support other parameters,\n// a proper ASN.1 parser can be used\n\n// References:\n//\n//   https://tools.ietf.org/html/rfc8017#appendix-A.1.2\n//   PKCS #1: RSA Cryptography Specifications Version 2.2\n//     A.1.2.  RSA Private Key Syntax\n//\n//   https://lapo.it/asn1js/\n//   https://github.com/lapo-luchini/asn1js\n//   ASN.1 JavaScript decoder\n//\n//   https://www.itu.int/rec/T-REC-X.690-201508-I/en\n//   X.690: Specification of Distinguished Encoding Rules (DER)\n\nconst RsaPrivateKeyNOffset = 38;\nconst RsaPrivateKeyNLength = 2048 / 8;\nconst RsaPrivateKeyDOffset = 303;\nconst RsaPrivateKeyDLength = 2048 / 8;\n\nexport function rsaParsePrivateKey(key: Uint8Array): [n: bigint, d: bigint] {\n    const n = getBigUint(key, RsaPrivateKeyNOffset, RsaPrivateKeyNLength);\n    const d = getBigUint(key, RsaPrivateKeyDOffset, RsaPrivateKeyDLength);\n    return [n, d];\n}\n\nfunction nonNegativeMod(m: number, d: number) {\n    const r = m % d;\n    if (r > 0) {\n        return r;\n    }\n    return r + (d > 0 ? d : -d);\n}\n\n// https://en.wikipedia.org/wiki/Modular_multiplicative_inverse\n// Solve for the smallest positive `x` in the equation `a * x \u2261 1 (mod m)`,\n// or in other words, `a * x % m = 1`\n// Taken from https://stackoverflow.com/a/51562038\n// Only used with numbers smaller than 2^32 so doesn't need BigInt\nexport function modInverse(a: number, m: number) {\n    a = nonNegativeMod(a, m);\n    if (!a || m < 2) {\n        return NaN; // invalid input\n    }\n    // find the gcd\n    const s = [];\n    let b = m;\n    while (b) {\n        [a, b] = [b, a % b];\n        s.push({ a, b });\n    }\n    /* istanbul ignore next */\n    if (a !== 1) {\n        return NaN; // inverse does not exists\n    }\n    // find the inverse\n    let x = 1;\n    let y = 0;\n    for (let i = s.length - 2; i >= 0; i -= 1) {\n        [x, y] = [y, x - y * Math.floor(s[i]!.a / s[i]!.b)];\n    }\n    return nonNegativeMod(y, m);\n}\n\nconst ModulusLengthInBytes = 2048 / 8;\nconst ModulusLengthInWords = ModulusLengthInBytes / 4;\n\nexport function adbGetPublicKeySize() {\n    return 4 + 4 + ModulusLengthInBytes + ModulusLengthInBytes + 4;\n}\n\nexport function adbGeneratePublicKey(\n    privateKey: Uint8Array,\n): Uint8Array<ArrayBuffer>;\nexport function adbGeneratePublicKey(\n    privateKey: Uint8Array,\n    output: Uint8Array,\n): number;\nexport function adbGeneratePublicKey(\n    privateKey: Uint8Array,\n    output?: Uint8Array,\n): Uint8Array | number {\n    // cspell: ignore: mincrypt\n    // Android 6 and earlier has its own encryption library called mincrypt\n    // This is the RSA public key format used by mincrypt:\n    // https://android.googlesource.com/platform/system/core/+/bb0c180e62703c2068a1b2c9f8ba6d634bf1553c/include/mincrypt/rsa.h#46\n    // `n0inv` and `rr` are pre-calculated to speed up RSA operations\n\n    // Android 7 switched its encryption library to BoringSSL, but still keeps the key format:\n    // https://android.googlesource.com/platform/system/core.git/+/91784040db2b9273687f88d8b95f729d4a61ecc2/libcrypto_utils/android_pubkey.cpp#38\n    // Except when reading a key, `n0inv` and `rr` are ignored (they are still populated when generating a key):\n    // https://android.googlesource.com/platform/system/core.git/+/91784040db2b9273687f88d8b95f729d4a61ecc2/libcrypto_utils/android_pubkey.cpp#55\n\n    // The public key is a struct (in little endian) of:\n    //\n    // [\n    //   modulusLengthInWords, // 32-bit integer, a \"word\" is 32-bit so it must be 2048 / 8 / 4\n    //                         // (the comment in Android source code is incorrect saying \"This must be ANDROID_PUBKEY_MODULUS_SIZE\")\n    //   n0inv,                // 32-bit integer, the modular inverse of (lower 32 bits of `n`)\n    //   modulus,              // `n`\n    //   rr,                   // Montgomery parameter R^2\n    //   exponent,             // 32-bit integer, must be 3 or 65537\n    // ]\n\n    let outputType: \"Uint8Array\" | \"number\";\n    const outputLength = adbGetPublicKeySize();\n    if (!output) {\n        output = new Uint8Array(outputLength);\n        outputType = \"Uint8Array\";\n    } else {\n        if (output.length < outputLength) {\n            throw new TypeError(\"output buffer is too small\");\n        }\n\n        outputType = \"number\";\n    }\n\n    const outputView = new DataView(\n        output.buffer,\n        output.byteOffset,\n        output.length,\n    );\n    let outputOffset = 0;\n\n    // modulusLengthInWords\n    outputView.setUint32(outputOffset, ModulusLengthInWords, true);\n    outputOffset += 4;\n\n    // extract `n` from private key\n    const [n] = rsaParsePrivateKey(privateKey);\n\n    // Calculate `n0inv`\n    const n0inv = -modInverse(Number(n % 2n ** 32n), 2 ** 32);\n    outputView.setInt32(outputOffset, n0inv, true);\n    outputOffset += 4;\n\n    // Write `n` (a.k.a. `modulus`)\n    setBigUint(output, outputOffset, ModulusLengthInBytes, n, true);\n    outputOffset += ModulusLengthInBytes;\n\n    // Calculate rr = (2 ** (rsa_size)) ** 2 % n\n    const rr = 2n ** 4096n % n;\n    setBigUint(output, outputOffset, ModulusLengthInBytes, rr, true);\n    outputOffset += ModulusLengthInBytes;\n\n    // exponent\n    outputView.setUint32(outputOffset, 65537, true);\n    outputOffset += 4;\n\n    if (outputType === \"Uint8Array\") {\n        return output;\n    } else {\n        return outputLength;\n    }\n}\n\n/**\n * Modular exponentiation.\n *\n * Calculate `(base ** exponent) % modulus` without actually calculating `(base ** exponent)`.\n *\n * See https://en.wikipedia.org/wiki/Modular_exponentiation#Implementation_in_Lua\n */\nexport function powMod(\n    base: bigint,\n    exponent: bigint,\n    modulus: bigint,\n): bigint {\n    if (modulus === 1n) {\n        return 0n;\n    }\n\n    let r = 1n;\n    base = base % modulus;\n\n    while (exponent > 0n) {\n        if (BigInt.asUintN(1, exponent) === 1n) {\n            r = (r * base) % modulus;\n        }\n\n        base = (base * base) % modulus;\n        exponent >>= 1n;\n    }\n\n    return r;\n}\n\nexport const SHA1_DIGEST_LENGTH = 20;\n\nexport const ASN1_SEQUENCE = 0x30;\nexport const ASN1_OCTET_STRING = 0x04;\nexport const ASN1_NULL = 0x05;\nexport const ASN1_OID = 0x06;\n\n// PKCS#1 SHA-1 hash digest info\nexport const SHA1_DIGEST_INFO = new Uint8Array([\n    ASN1_SEQUENCE,\n    0x0d + SHA1_DIGEST_LENGTH,\n    ASN1_SEQUENCE,\n    0x09,\n    // SHA-1 (1 3 14 3 2 26)\n    ASN1_OID,\n    0x05,\n    1 * 40 + 3,\n    14,\n    3,\n    2,\n    26,\n    ASN1_NULL,\n    0x00,\n    ASN1_OCTET_STRING,\n    SHA1_DIGEST_LENGTH,\n]);\n\n// SubtleCrypto.sign() will hash the given data and sign the hash\n// But we don't need the hashing step\n// (In another word, ADB just requires the client to\n// encrypt the given data with its private key)\n// However SubtileCrypto.encrypt() doesn't accept 'RSASSA-PKCS1-v1_5' algorithm\n// So we need to implement the encryption by ourself\nexport function rsaSign(\n    privateKey: Uint8Array,\n    data: Uint8Array,\n): Uint8Array<ArrayBuffer> {\n    const [n, d] = rsaParsePrivateKey(privateKey);\n\n    // PKCS#1 padding\n    const padded = new Uint8Array(256);\n    let index = 0;\n\n    padded[index] = 0;\n    index += 1;\n\n    padded[index] = 1;\n    index += 1;\n\n    const fillLength =\n        padded.length - SHA1_DIGEST_INFO.length - data.length - 1;\n    while (index < fillLength) {\n        padded[index] = 0xff;\n        index += 1;\n    }\n\n    padded[index] = 0;\n    index += 1;\n\n    padded.set(SHA1_DIGEST_INFO, index);\n    index += SHA1_DIGEST_INFO.length;\n\n    padded.set(data, index);\n\n    // Encryption\n    // signature = padded ** d % n\n    const signature = powMod(getBigUint(padded, 0, padded.length), d, n);\n\n    // `padded` is not used anymore,\n    // re-use the buffer to store the result\n    setBigUint(padded, 0, padded.length, signature, false);\n\n    return padded;\n}\n", "import { Consumable, TransformStream } from \"@yume-chan/stream-extra\";\nimport type { StructInit, StructValue } from \"@yume-chan/struct\";\nimport { buffer, extend, s32, struct, u32 } from \"@yume-chan/struct\";\n\nexport const AdbCommand = {\n    Auth: 0x48545541, // 'AUTH'\n    Close: 0x45534c43, // 'CLSE'\n    Connect: 0x4e584e43, // 'CNXN'\n    Okay: 0x59414b4f, // 'OKAY'\n    Open: 0x4e45504f, // 'OPEN'\n    Write: 0x45545257, // 'WRTE'\n} as const;\n\nexport type AdbCommand = (typeof AdbCommand)[keyof typeof AdbCommand];\n\nexport const AdbPacketHeader = struct(\n    {\n        command: u32,\n        arg0: u32,\n        arg1: u32,\n        payloadLength: u32,\n        checksum: u32,\n        magic: s32,\n    },\n    { littleEndian: true },\n);\n\nexport type AdbPacketHeader = StructValue<typeof AdbPacketHeader>;\n\ntype AdbPacketHeaderInit = StructInit<typeof AdbPacketHeader>;\n\nexport const AdbPacket = extend(AdbPacketHeader, {\n    payload: buffer(\"payloadLength\"),\n});\n\nexport type AdbPacket = StructValue<typeof AdbPacket>;\n\n/**\n * `AdbPacketData` contains all the useful fields of `AdbPacket`.\n *\n * `AdvDaemonConnection#connect` will return a `ReadableStream<AdbPacketData>`,\n * allow each connection to encode `AdbPacket` in different methods.\n *\n * `AdbDaemonConnection#connect` will return a `WritableStream<AdbPacketInit>`,\n * however, `AdbDaemonTransport` will transform `AdbPacketData` to `AdbPacketInit` for you,\n * so `AdbSocket#writable#write` only needs `AdbPacketData`.\n */\nexport type AdbPacketData = Omit<\n    StructInit<typeof AdbPacket>,\n    \"checksum\" | \"magic\"\n>;\n\nexport type AdbPacketInit = StructInit<typeof AdbPacket>;\n\nexport function calculateChecksum(payload: Uint8Array): number {\n    return payload.reduce((result, item) => result + item, 0);\n}\n\nexport class AdbPacketSerializeStream extends TransformStream<\n    Consumable<AdbPacketInit>,\n    Consumable<Uint8Array>\n> {\n    constructor() {\n        const headerBuffer = new Uint8Array(AdbPacketHeader.size);\n        super({\n            transform: async (chunk, controller) => {\n                await chunk.tryConsume(async (chunk) => {\n                    const init = chunk as AdbPacketInit & AdbPacketHeaderInit;\n                    init.payloadLength = init.payload.length;\n\n                    AdbPacketHeader.serialize(init, headerBuffer);\n                    await Consumable.ReadableStream.enqueue(\n                        controller,\n                        headerBuffer,\n                    );\n\n                    if (init.payloadLength) {\n                        // USB protocol preserves packet boundaries,\n                        // so we must write payload separately as native ADB does,\n                        // otherwise the read operation on device will fail.\n                        await Consumable.ReadableStream.enqueue(\n                            controller,\n                            init.payload,\n                        );\n                    }\n                });\n            },\n        });\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport { PromiseResolver } from \"@yume-chan/async\";\nimport type { Disposable } from \"@yume-chan/event\";\nimport { EmptyUint8Array } from \"@yume-chan/struct\";\n\nimport {\n    calculateBase64EncodedLength,\n    encodeBase64,\n    encodeUtf8,\n} from \"../utils/index.js\";\n\nimport {\n    adbGeneratePublicKey,\n    adbGetPublicKeySize,\n    rsaSign,\n} from \"./crypto.js\";\nimport type { AdbPacketData } from \"./packet.js\";\nimport { AdbCommand } from \"./packet.js\";\n\nexport interface AdbPrivateKey {\n    /**\n     * The private key in PKCS #8 format.\n     */\n    buffer: Uint8Array;\n    name?: string | undefined;\n}\n\nexport type AdbKeyIterable =\n    | Iterable<AdbPrivateKey>\n    | AsyncIterable<AdbPrivateKey>;\n\nexport interface AdbCredentialStore {\n    /**\n     * Generates and stores a RSA private key with modulus length `2048` and public exponent `65537`.\n     */\n    generateKey(): MaybePromiseLike<AdbPrivateKey>;\n\n    /**\n     * Synchronously or asynchronously iterates through all stored RSA private keys.\n     *\n     * Each call to `iterateKeys` must return a different iterator that iterate through all stored keys.\n     */\n    iterateKeys(): AdbKeyIterable;\n}\n\nexport const AdbAuthType = {\n    Token: 1,\n    Signature: 2,\n    PublicKey: 3,\n} as const;\n\nexport type AdbAuthType = (typeof AdbAuthType)[keyof typeof AdbAuthType];\n\nexport interface AdbAuthenticator {\n    /**\n     * @param getNextRequest\n     *\n     * Call this function to get the next authentication request packet from device.\n     *\n     * After calling `getNextRequest`, authenticator can `yield` a packet as response, or `return` to indicate its incapability of handling the request.\n     *\n     * After `return`, the `AdbAuthenticatorHandler` will move on to next authenticator and never go back.\n     *\n     * Calling `getNextRequest` multiple times without `yield` or `return` will always return the same request.\n     */\n    (\n        credentialStore: AdbCredentialStore,\n        getNextRequest: () => Promise<AdbPacketData>,\n    ): AsyncIterable<AdbPacketData>;\n}\n\nexport const AdbSignatureAuthenticator: AdbAuthenticator = async function* (\n    credentialStore: AdbCredentialStore,\n    getNextRequest: () => Promise<AdbPacketData>,\n): AsyncIterable<AdbPacketData> {\n    for await (const key of credentialStore.iterateKeys()) {\n        const packet = await getNextRequest();\n\n        if (packet.arg0 !== AdbAuthType.Token) {\n            return;\n        }\n\n        const signature = rsaSign(key.buffer, packet.payload);\n        yield {\n            command: AdbCommand.Auth,\n            arg0: AdbAuthType.Signature,\n            arg1: 0,\n            payload: signature,\n        };\n    }\n};\n\nexport const AdbPublicKeyAuthenticator: AdbAuthenticator = async function* (\n    credentialStore: AdbCredentialStore,\n    getNextRequest: () => Promise<AdbPacketData>,\n): AsyncIterable<AdbPacketData> {\n    const packet = await getNextRequest();\n\n    if (packet.arg0 !== AdbAuthType.Token) {\n        return;\n    }\n\n    let privateKey: AdbPrivateKey | undefined;\n    for await (const key of credentialStore.iterateKeys()) {\n        privateKey = key;\n        break;\n    }\n\n    if (!privateKey) {\n        privateKey = await credentialStore.generateKey();\n    }\n\n    const publicKeyLength = adbGetPublicKeySize();\n    const [publicKeyBase64Length] =\n        calculateBase64EncodedLength(publicKeyLength);\n\n    const nameBuffer = privateKey.name?.length\n        ? encodeUtf8(privateKey.name)\n        : EmptyUint8Array;\n    const publicKeyBuffer = new Uint8Array(\n        publicKeyBase64Length +\n            (nameBuffer.length ? nameBuffer.length + 1 : 0) + // Space character + name\n            1, // Null character\n    );\n\n    adbGeneratePublicKey(privateKey.buffer, publicKeyBuffer);\n    encodeBase64(publicKeyBuffer.subarray(0, publicKeyLength), publicKeyBuffer);\n\n    if (nameBuffer.length) {\n        publicKeyBuffer[publicKeyBase64Length] = 0x20;\n        publicKeyBuffer.set(nameBuffer, publicKeyBase64Length + 1);\n    }\n\n    yield {\n        command: AdbCommand.Auth,\n        arg0: AdbAuthType.PublicKey,\n        arg1: 0,\n        payload: publicKeyBuffer,\n    };\n};\n\nexport const ADB_DEFAULT_AUTHENTICATORS: readonly AdbAuthenticator[] = [\n    AdbSignatureAuthenticator,\n    AdbPublicKeyAuthenticator,\n];\n\nexport class AdbAuthenticationProcessor implements Disposable {\n    readonly authenticators: readonly AdbAuthenticator[];\n\n    readonly #credentialStore: AdbCredentialStore;\n\n    #pendingRequest = new PromiseResolver<AdbPacketData>();\n    #iterator: AsyncIterator<AdbPacketData, void, void> | undefined;\n\n    constructor(\n        authenticators: readonly AdbAuthenticator[],\n        credentialStore: AdbCredentialStore,\n    ) {\n        this.authenticators = authenticators;\n        this.#credentialStore = credentialStore;\n    }\n\n    #getNextRequest = (): Promise<AdbPacketData> => {\n        return this.#pendingRequest.promise;\n    };\n\n    async *#invokeAuthenticator(): AsyncGenerator<AdbPacketData, void, void> {\n        for (const authenticator of this.authenticators) {\n            for await (const packet of authenticator(\n                this.#credentialStore,\n                this.#getNextRequest,\n            )) {\n                // If the authenticator yielded a response\n                // Prepare `nextRequest` for next authentication request\n                this.#pendingRequest = new PromiseResolver();\n\n                // Yield the response to outer layer\n                yield packet;\n            }\n\n            // If the authenticator returned,\n            // Next authenticator will be given the same `pendingRequest`\n        }\n    }\n\n    async process(packet: AdbPacketData): Promise<AdbPacketData> {\n        if (!this.#iterator) {\n            this.#iterator = this.#invokeAuthenticator();\n        }\n\n        this.#pendingRequest.resolve(packet);\n\n        const result = await this.#iterator.next();\n        if (result.done) {\n            throw new Error(\"No authenticator can handle the request\");\n        }\n\n        return result.value;\n    }\n\n    dispose() {\n        void this.#iterator?.return?.();\n    }\n}\n", "import { PromiseResolver } from \"@yume-chan/async\";\nimport type { Disposable } from \"@yume-chan/event\";\nimport type {\n    PushReadableStreamController,\n    ReadableStream,\n    WritableStream,\n    WritableStreamDefaultController,\n} from \"@yume-chan/stream-extra\";\nimport { MaybeConsumable, PushReadableStream } from \"@yume-chan/stream-extra\";\nimport { EmptyUint8Array } from \"@yume-chan/struct\";\n\nimport type { AdbSocket } from \"../adb.js\";\n\nimport type { AdbPacketDispatcher } from \"./dispatcher.js\";\nimport { AdbCommand } from \"./packet.js\";\n\nexport interface AdbDaemonSocketInfo {\n    localId: number;\n    remoteId: number;\n\n    localCreated: boolean;\n    service: string;\n}\n\nexport interface AdbDaemonSocketInit extends AdbDaemonSocketInfo {\n    dispatcher: AdbPacketDispatcher;\n\n    highWaterMark?: number | undefined;\n\n    /**\n     * The initial delayed ack byte count, or `Infinity` if delayed ack is disabled.\n     */\n    availableWriteBytes: number;\n}\n\nexport class AdbDaemonSocketController\n    implements AdbDaemonSocketInfo, AdbSocket, Disposable\n{\n    readonly #dispatcher!: AdbPacketDispatcher;\n\n    readonly localId!: number;\n    readonly remoteId!: number;\n    readonly localCreated!: boolean;\n    readonly service!: string;\n\n    readonly #readable: ReadableStream<Uint8Array>;\n    #readableController!: PushReadableStreamController<Uint8Array>;\n    get readable() {\n        return this.#readable;\n    }\n\n    #writableController!: WritableStreamDefaultController;\n    readonly writable: WritableStream<MaybeConsumable<Uint8Array>>;\n\n    #closed = false;\n\n    readonly #closedPromise = new PromiseResolver<undefined>();\n    get closed() {\n        return this.#closedPromise.promise;\n    }\n\n    readonly #socket: AdbDaemonSocket;\n    get socket() {\n        return this.#socket;\n    }\n\n    #availableWriteBytesChanged: PromiseResolver<void> | undefined;\n    /**\n     * When delayed ack is disabled, returns `Infinity` if the socket is ready to write\n     * (exactly one packet can be written no matter how large it is), or `-1` if the socket\n     * is waiting for ack message.\n     *\n     * When delayed ack is enabled, returns a non-negative finite number indicates the number of\n     * bytes that can be written to the socket before waiting for ack message.\n     */\n    #availableWriteBytes = 0;\n\n    constructor(options: AdbDaemonSocketInit) {\n        this.#dispatcher = options.dispatcher;\n        this.localId = options.localId;\n        this.remoteId = options.remoteId;\n        this.localCreated = options.localCreated;\n        this.service = options.service;\n\n        this.#readable = new PushReadableStream((controller) => {\n            this.#readableController = controller;\n        });\n\n        this.writable = new MaybeConsumable.WritableStream<Uint8Array>({\n            start: (controller) => {\n                this.#writableController = controller;\n                controller.signal.addEventListener(\"abort\", () => {\n                    this.#availableWriteBytesChanged?.reject(\n                        controller.signal.reason,\n                    );\n                });\n            },\n            write: async (data) => {\n                const size = data.length;\n                const chunkSize = this.#dispatcher.options.maxPayloadSize;\n                for (\n                    let start = 0, end = chunkSize;\n                    start < size;\n                    start = end, end += chunkSize\n                ) {\n                    const chunk = data.subarray(start, end);\n                    await this.#writeChunk(chunk);\n                }\n            },\n        });\n\n        this.#socket = new AdbDaemonSocket(this);\n        this.#availableWriteBytes = options.availableWriteBytes;\n    }\n\n    async #writeChunk(data: Uint8Array) {\n        const length = data.length;\n        while (this.#availableWriteBytes < length) {\n            // Only one lock is required because Web Streams API guarantees\n            // that `write` is not reentrant.\n            const resolver = new PromiseResolver<void>();\n            this.#availableWriteBytesChanged = resolver;\n            await resolver.promise;\n        }\n\n        if (this.#availableWriteBytes === Infinity) {\n            this.#availableWriteBytes = -1;\n        } else {\n            this.#availableWriteBytes -= length;\n        }\n\n        await this.#dispatcher.sendPacket(\n            AdbCommand.Write,\n            this.localId,\n            this.remoteId,\n            data,\n        );\n    }\n\n    async enqueue(data: Uint8Array) {\n        await this.#readableController.enqueue(data);\n    }\n\n    public ack(bytes: number) {\n        this.#availableWriteBytes += bytes;\n        this.#availableWriteBytesChanged?.resolve();\n    }\n\n    async close(): Promise<void> {\n        if (this.#closed) {\n            return;\n        }\n        this.#closed = true;\n\n        this.#availableWriteBytesChanged?.reject(new Error(\"Socket closed\"));\n\n        try {\n            this.#writableController.error(new Error(\"Socket closed\"));\n        } catch {\n            // ignore\n        }\n\n        await this.#dispatcher.sendPacket(\n            AdbCommand.Close,\n            this.localId,\n            this.remoteId,\n            EmptyUint8Array,\n        );\n    }\n\n    dispose() {\n        this.#readableController.close();\n        this.#closedPromise.resolve(undefined);\n    }\n}\n\n/**\n * A duplex stream representing a socket to ADB daemon.\n */\nexport class AdbDaemonSocket implements AdbDaemonSocketInfo, AdbSocket {\n    readonly #controller: AdbDaemonSocketController;\n\n    get localId(): number {\n        return this.#controller.localId;\n    }\n    get remoteId(): number {\n        return this.#controller.remoteId;\n    }\n    get localCreated(): boolean {\n        return this.#controller.localCreated;\n    }\n    get service(): string {\n        return this.#controller.service;\n    }\n\n    get readable(): ReadableStream<Uint8Array> {\n        return this.#controller.readable;\n    }\n    get writable(): WritableStream<MaybeConsumable<Uint8Array>> {\n        return this.#controller.writable;\n    }\n\n    get closed(): Promise<undefined> {\n        return this.#controller.closed;\n    }\n\n    constructor(controller: AdbDaemonSocketController) {\n        this.#controller = controller;\n    }\n\n    close() {\n        return this.#controller.close();\n    }\n}\n", "import {\n    AsyncOperationManager,\n    PromiseResolver,\n    delay,\n} from \"@yume-chan/async\";\nimport {\n    getUint32LittleEndian,\n    setUint32LittleEndian,\n} from \"@yume-chan/no-data-view\";\nimport type {\n    ReadableWritablePair,\n    WritableStreamDefaultController,\n    WritableStreamDefaultWriter,\n} from \"@yume-chan/stream-extra\";\nimport {\n    AbortController,\n    Consumable,\n    WritableStream,\n} from \"@yume-chan/stream-extra\";\nimport { EmptyUint8Array, decodeUtf8, encodeUtf8 } from \"@yume-chan/struct\";\n\nimport type { AdbIncomingSocketHandler, AdbSocket, Closeable } from \"../adb.js\";\n\nimport type { AdbPacketData, AdbPacketInit } from \"./packet.js\";\nimport { AdbCommand, calculateChecksum } from \"./packet.js\";\nimport { AdbDaemonSocketController } from \"./socket.js\";\n\nexport interface AdbPacketDispatcherOptions {\n    /**\n     * From Android 9.0, ADB stopped checking the checksum in packet header to improve performance.\n     *\n     * The value should be inferred from the device's ADB protocol version.\n     */\n    calculateChecksum: boolean;\n\n    /**\n     * Before Android 9.0, ADB uses `char*` to parse service strings,\n     * thus requires a null character to terminate.\n     *\n     * The value should be inferred from the device's ADB protocol version.\n     * Usually it should have the same value as `calculateChecksum`, since they both changed\n     * in Android 9.0.\n     */\n    appendNullToServiceString: boolean;\n\n    maxPayloadSize: number;\n\n    /**\n     * Whether to keep the `connection` open (don't call `writable.close` and `readable.cancel`)\n     * when `AdbPacketDispatcher.close` is called.\n     *\n     * @default false\n     */\n    preserveConnection?: boolean | undefined;\n\n    /**\n     * The number of bytes the device can send before receiving an ack packet.\n     * Using delayed ack can improve the throughput,\n     * especially when the device is connected over Wi-Fi (so the latency is higher).\n     *\n     * This must be the negotiated value between the client and device. If the device enabled\n     * delayed ack but the client didn't, the device will throw an error when the client sends\n     * the first `WRTE` packet. And vice versa.\n     */\n    initialDelayedAckBytes: number;\n\n    /**\n     * When set, the dispatcher will throw an error when\n     * one of the socket readable stalls for this amount of milliseconds.\n     *\n     * Because ADB is a multiplexed protocol, blocking one socket will also block all other sockets.\n     * It's important to always read from all sockets to prevent stalling.\n     *\n     * This option is helpful to detect bugs in the client code.\n     *\n     * @default false\n     */\n    readTimeLimit?: number | undefined;\n}\n\ninterface SocketOpenResult {\n    remoteId: number;\n    availableWriteBytes: number;\n}\n\n/**\n * The dispatcher is the \"dumb\" part of the connection handling logic.\n *\n * Except some options to change some minor behaviors,\n * its only job is forwarding packets between authenticated underlying streams\n * and abstracted socket objects.\n *\n * The `Adb` class is responsible for doing the authentication,\n * negotiating the options, and has shortcuts to high-level services.\n */\nexport class AdbPacketDispatcher implements Closeable {\n    // ADB socket id starts from 1\n    // (0 means open failed)\n    readonly #initializers = new AsyncOperationManager(1);\n    /**\n     * Socket local ID to the socket controller.\n     */\n    readonly #sockets = new Map<number, AdbDaemonSocketController>();\n\n    readonly #writer: WritableStreamDefaultWriter<Consumable<AdbPacketInit>>;\n\n    readonly options: AdbPacketDispatcherOptions;\n\n    #closed = false;\n    readonly #disconnected = new PromiseResolver<void>();\n    get disconnected() {\n        return this.#disconnected.promise;\n    }\n\n    readonly #incomingSocketHandlers = new Map<\n        string,\n        AdbIncomingSocketHandler\n    >();\n    readonly #readAbortController = new AbortController();\n\n    constructor(\n        connection: ReadableWritablePair<\n            AdbPacketData,\n            Consumable<AdbPacketInit>\n        >,\n        options: AdbPacketDispatcherOptions,\n    ) {\n        this.options = options;\n        // Don't allow negative values in dispatcher\n        if (this.options.initialDelayedAckBytes < 0) {\n            this.options.initialDelayedAckBytes = 0;\n        }\n\n        connection.readable\n            .pipeTo(\n                new WritableStream<AdbPacketData>({\n                    write: async (\n                        packet: AdbPacketData,\n                        controller: WritableStreamDefaultController,\n                    ) => {\n                        switch (packet.command) {\n                            case AdbCommand.Close:\n                                await this.#handleClose(packet);\n                                break;\n                            case AdbCommand.Okay:\n                                this.#handleOkay(packet);\n                                break;\n                            case AdbCommand.Open:\n                                await this.#handleOpen(packet);\n                                break;\n                            case AdbCommand.Write:\n                                // Don't await - let each socket handle its own backpressure\n                                // without blocking other sockets' packet processing.\n                                // Fatal errors are propagated via WritableStream's controller.\n                                this.#handleWrite(packet).catch((e) => {\n                                    controller.error(e);\n                                });\n                                break;\n                            default:\n                                // Junk data may only appear in the authentication phase,\n                                // since the dispatcher only works after authentication,\n                                // all packets should have a valid command.\n                                // (although it's possible that Adb added new commands in the future)\n                                throw new Error(\n                                    `Unknown command: ${packet.command.toString(\n                                        16,\n                                    )}`,\n                                );\n                        }\n                    },\n                }),\n                {\n                    preventCancel: options.preserveConnection ?? false,\n                    signal: this.#readAbortController.signal,\n                },\n            )\n            .then(\n                () => {\n                    this.#dispose();\n                },\n                (e) => {\n                    if (!this.#closed) {\n                        this.#disconnected.reject(e);\n                    }\n                    this.#dispose();\n                },\n            );\n\n        this.#writer = connection.writable.getWriter();\n    }\n\n    async #handleClose(packet: AdbPacketData) {\n        // If the socket is still pending\n        if (\n            packet.arg0 === 0 &&\n            this.#initializers.reject(\n                packet.arg1,\n                new Error(\"Socket open failed\"),\n            )\n        ) {\n            // Device failed to create the socket\n            // (unknown service string, failed to execute command, etc.)\n            // it doesn't break the connection,\n            // so only reject the socket creation promise,\n            // don't throw an error here.\n            return;\n        }\n\n        // From https://android.googlesource.com/platform/packages/modules/adb/+/65d18e2c1cc48b585811954892311b28a4c3d188/adb.cpp#459\n        /* According to protocol.txt, p->msg.arg0 might be 0 to indicate\n         * a failed OPEN only. However, due to a bug in previous ADB\n         * versions, CLOSE(0, remote-id, \"\") was also used for normal\n         * CLOSE() operations.\n         */\n\n        // Ignore `arg0` and search for the socket\n        const socket = this.#sockets.get(packet.arg1);\n        if (socket) {\n            await socket.close();\n            socket.dispose();\n            this.#sockets.delete(packet.arg1);\n            return;\n        }\n\n        // TODO: adb: is double closing an socket a catastrophic error?\n        // If the client sends two `CLSE` packets for one socket,\n        // the device may also respond with two `CLSE` packets.\n    }\n\n    #handleOkay(packet: AdbPacketData) {\n        let ackBytes: number;\n        if (this.options.initialDelayedAckBytes !== 0) {\n            if (packet.payload.length !== 4) {\n                throw new Error(\n                    \"Invalid OKAY packet. Payload size should be 4\",\n                );\n            }\n            ackBytes = getUint32LittleEndian(packet.payload, 0);\n        } else {\n            if (packet.payload.length !== 0) {\n                throw new Error(\n                    \"Invalid OKAY packet. Payload size should be 0\",\n                );\n            }\n            ackBytes = Infinity;\n        }\n\n        if (\n            this.#initializers.resolve(packet.arg1, {\n                remoteId: packet.arg0,\n                availableWriteBytes: ackBytes,\n            } satisfies SocketOpenResult)\n        ) {\n            // Device successfully created the socket\n            return;\n        }\n\n        const socket = this.#sockets.get(packet.arg1);\n        if (socket) {\n            // When delayed ack is enabled, `ackBytes` is a positive number represents\n            // how many bytes the device has received from this socket.\n            // When delayed ack is disabled, `ackBytes` is always `Infinity` represents\n            // the device has received last `WRTE` packet from the socket.\n            socket.ack(ackBytes);\n            return;\n        }\n\n        // Maybe the device is responding to a packet of last connection\n        // Tell the device to close the socket\n        void this.sendPacket(\n            AdbCommand.Close,\n            packet.arg1,\n            packet.arg0,\n            EmptyUint8Array,\n        );\n    }\n\n    #sendOkay(localId: number, remoteId: number, ackBytes: number) {\n        let payload: Uint8Array;\n        if (this.options.initialDelayedAckBytes !== 0) {\n            // TODO: try reusing this buffer to reduce memory allocation\n            // However, that requires blocking reentrance of `sendOkay`, which might be more expensive\n            payload = new Uint8Array(4);\n            setUint32LittleEndian(payload, 0, ackBytes);\n        } else {\n            payload = EmptyUint8Array;\n        }\n\n        return this.sendPacket(AdbCommand.Okay, localId, remoteId, payload);\n    }\n\n    async #handleOpen(packet: AdbPacketData) {\n        // Allocate a local ID for the socket from `#initializers`.\n        // `AsyncOperationManager` doesn't directly support returning the next ID,\n        // so use `add` + `resolve` to simulate this\n        const [localId] = this.#initializers.add<number>();\n        this.#initializers.resolve(localId, undefined);\n\n        const remoteId = packet.arg0;\n        let availableWriteBytes = packet.arg1;\n        let service = decodeUtf8(packet.payload);\n        // ADB Daemon still adds a null character to the service string\n        if (service.endsWith(\"\\0\")) {\n            service = service.substring(0, service.length - 1);\n        }\n\n        // Check remote delayed ack enablement is consistent with local\n        if (this.options.initialDelayedAckBytes === 0) {\n            if (availableWriteBytes !== 0) {\n                throw new Error(\"Invalid OPEN packet. arg1 should be 0\");\n            }\n            availableWriteBytes = Infinity;\n        } else {\n            if (availableWriteBytes === 0) {\n                throw new Error(\n                    \"Invalid OPEN packet. arg1 should be greater than 0\",\n                );\n            }\n        }\n\n        const handler = this.#incomingSocketHandlers.get(service);\n        if (!handler) {\n            await this.sendPacket(\n                AdbCommand.Close,\n                0,\n                remoteId,\n                EmptyUint8Array,\n            );\n            return;\n        }\n\n        const controller = new AdbDaemonSocketController({\n            dispatcher: this,\n            localId,\n            remoteId,\n            localCreated: false,\n            service,\n            availableWriteBytes,\n        });\n\n        try {\n            await handler(controller.socket);\n            this.#sockets.set(localId, controller);\n            await this.#sendOkay(\n                localId,\n                remoteId,\n                this.options.initialDelayedAckBytes,\n            );\n        } catch {\n            await this.sendPacket(\n                AdbCommand.Close,\n                0,\n                remoteId,\n                EmptyUint8Array,\n            );\n        }\n    }\n\n    async #handleWrite(packet: AdbPacketData) {\n        const socket = this.#sockets.get(packet.arg1);\n        if (!socket) {\n            throw new Error(`Unknown local socket id: ${packet.arg1}`);\n        }\n\n        let handled = false;\n\n        const promises: Promise<void>[] = [\n            (async () => {\n                await socket.enqueue(packet.payload);\n                await this.#sendOkay(\n                    packet.arg1,\n                    packet.arg0,\n                    packet.payload.length,\n                );\n                handled = true;\n            })(),\n        ];\n\n        if (this.options.readTimeLimit) {\n            promises.push(\n                (async () => {\n                    await delay(this.options.readTimeLimit!);\n                    if (!handled) {\n                        throw new Error(\n                            `readable of \\`${socket.service}\\` has stalled for ${this.options.readTimeLimit} milliseconds`,\n                        );\n                    }\n                })(),\n            );\n        }\n\n        await Promise.race(promises);\n    }\n\n    async createSocket(service: string): Promise<AdbSocket> {\n        if (this.options.appendNullToServiceString) {\n            service += \"\\0\";\n        }\n\n        const [localId, initializer] =\n            this.#initializers.add<SocketOpenResult>();\n        await this.sendPacket(\n            AdbCommand.Open,\n            localId,\n            this.options.initialDelayedAckBytes,\n            service,\n        );\n\n        // Fulfilled by `handleOkay`\n        const { remoteId, availableWriteBytes } = await initializer;\n        const controller = new AdbDaemonSocketController({\n            dispatcher: this,\n            localId,\n            remoteId,\n            localCreated: true,\n            service,\n            availableWriteBytes,\n        });\n        this.#sockets.set(localId, controller);\n\n        return controller.socket;\n    }\n\n    addReverseTunnel(service: string, handler: AdbIncomingSocketHandler) {\n        this.#incomingSocketHandlers.set(service, handler);\n    }\n\n    removeReverseTunnel(address: string) {\n        this.#incomingSocketHandlers.delete(address);\n    }\n\n    clearReverseTunnels() {\n        this.#incomingSocketHandlers.clear();\n    }\n\n    async sendPacket(\n        command: AdbCommand,\n        arg0: number,\n        arg1: number,\n        // PERF: It's slightly faster to not use default parameter values\n        payload: string | Uint8Array,\n    ): Promise<void> {\n        if (typeof payload === \"string\") {\n            payload = encodeUtf8(payload);\n        }\n\n        if (payload.length > this.options.maxPayloadSize) {\n            throw new TypeError(\"payload too large\");\n        }\n\n        await Consumable.WritableStream.write(this.#writer, {\n            command,\n            arg0,\n            arg1,\n            payload,\n            checksum: this.options.calculateChecksum\n                ? calculateChecksum(payload)\n                : 0,\n            magic: command ^ 0xffffffff,\n        });\n    }\n\n    async close() {\n        // Send `CLSE` packets for all sockets\n        await Promise.all(\n            Array.from(this.#sockets.values(), (socket) => socket.close()),\n        );\n\n        // Stop receiving\n        // It's possible that we haven't received all `CLSE` confirm packets,\n        // but it doesn't matter, the next connection can cope with them.\n        this.#closed = true;\n\n        this.#readAbortController.abort();\n        if (this.options.preserveConnection) {\n            this.#writer.releaseLock();\n        } else {\n            await this.#writer.close();\n        }\n\n        // `pipe().then()` will call `dispose`\n    }\n\n    #dispose() {\n        for (const socket of this.#sockets.values()) {\n            socket.dispose();\n        }\n\n        this.#disconnected.resolve();\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport { PromiseResolver } from \"@yume-chan/async\";\nimport type { ReadableWritablePair } from \"@yume-chan/stream-extra\";\nimport {\n    AbortController,\n    Consumable,\n    WritableStream,\n} from \"@yume-chan/stream-extra\";\nimport { decodeUtf8, encodeUtf8 } from \"@yume-chan/struct\";\n\nimport type {\n    AdbIncomingSocketHandler,\n    AdbSocket,\n    AdbTransport,\n} from \"../adb.js\";\nimport { AdbBanner } from \"../banner.js\";\nimport { AdbFeature } from \"../features.js\";\n\nimport type { AdbAuthenticator, AdbCredentialStore } from \"./auth.js\";\nimport {\n    ADB_DEFAULT_AUTHENTICATORS,\n    AdbAuthenticationProcessor,\n} from \"./auth.js\";\nimport { AdbPacketDispatcher } from \"./dispatcher.js\";\nimport type { AdbPacketData, AdbPacketInit } from \"./packet.js\";\nimport { AdbCommand, calculateChecksum } from \"./packet.js\";\n\nexport const ADB_DAEMON_VERSION_OMIT_CHECKSUM = 0x01000001;\n// https://android.googlesource.com/platform/packages/modules/adb/+/79010dc6d5ca7490c493df800d4421730f5466ca/transport.cpp#1252\n// There are some other feature constants, but some of them are only used by ADB server, not devices (daemons).\nexport const ADB_DAEMON_DEFAULT_FEATURES = /* #__PURE__ */ (() =>\n    [\n        AdbFeature.ShellV2,\n        AdbFeature.Cmd,\n        AdbFeature.StatV2,\n        AdbFeature.ListV2,\n        AdbFeature.FixedPushMkdir,\n        \"apex\",\n        AdbFeature.Abb,\n        // only tells the client the symlink timestamp issue in `adb push --sync` has been fixed.\n        // No special handling required.\n        \"fixed_push_symlink_timestamp\",\n        AdbFeature.AbbExec,\n        \"remount_shell\",\n        \"track_app\",\n        AdbFeature.SendReceiveV2,\n        \"sendrecv_v2_brotli\",\n        \"sendrecv_v2_lz4\",\n        \"sendrecv_v2_zstd\",\n        \"sendrecv_v2_dry_run_send\",\n        AdbFeature.DelayedAck,\n    ] as readonly AdbFeature[])();\nexport const ADB_DAEMON_DEFAULT_INITIAL_PAYLOAD_SIZE = 32 * 1024 * 1024;\n\nexport type AdbDaemonConnection = ReadableWritablePair<\n    AdbPacketData,\n    Consumable<AdbPacketInit>\n>;\n\nexport interface AdbDaemonAuthenticationOptions {\n    serial: string;\n    connection: AdbDaemonConnection;\n    credentialStore: AdbCredentialStore;\n    authenticators?: readonly AdbAuthenticator[];\n    features?: readonly AdbFeature[];\n\n    /**\n     * The number of bytes the device can send before receiving an ack packet.\n     * Using delayed ack can improve the throughput,\n     * especially when the device is connected over Wi-Fi (so the latency is higher).\n     *\n     * Set to 0 or any negative value to disable delayed ack in handshake.\n     * Otherwise the value must be in the range of unsigned 32-bit integer.\n     *\n     * Delayed ack was added in Android 14,\n     * this option will be ignored when the device doesn't support it.\n     *\n     * @default ADB_DAEMON_DEFAULT_INITIAL_PAYLOAD_SIZE\n     */\n    initialDelayedAckBytes?: number;\n\n    /**\n     * Whether to keep the `connection` open (don't call `writable.close` and `readable.cancel`)\n     * when `AdbDaemonTransport.close` is called.\n     *\n     * Note that when `authenticate` fails,\n     * no matter which value this option has,\n     * the `connection` is always kept open, so it can be used in another `authenticate` call.\n     *\n     * @default false\n     */\n    preserveConnection?: boolean | undefined;\n\n    /**\n     * When set, the transport will throw an error when\n     * one of the socket readable stalls for this amount of milliseconds.\n     *\n     * Because ADB is a multiplexed protocol, blocking one socket will also block all other sockets.\n     * It's important to always read from all sockets to prevent stalling.\n     *\n     * This option is helpful to detect bugs in the client code.\n     *\n     * @default undefined\n     */\n    readTimeLimit?: number | undefined;\n}\n\ninterface AdbDaemonSocketConnectorConstructionOptions {\n    serial: string;\n    connection: AdbDaemonConnection;\n    version: number;\n    maxPayloadSize: number;\n    banner: string;\n    features?: readonly AdbFeature[];\n\n    /**\n     * The number of bytes the device can send before receiving an ack packet.\n     *\n     * On Android 14 and newer, the Delayed Acknowledgement feature is added to\n     * improve performance, especially for high-latency connections like ADB over Wi-Fi.\n     *\n     * When `features` doesn't include `AdbFeature.DelayedAck`, it must be set to 0. Otherwise,\n     * the value must be in the range of unsigned 32-bit integer.\n     *\n     * If the device enabled delayed ack but the client didn't, the device will throw an error\n     * when the client sends the first data packet. And vice versa.\n     */\n    initialDelayedAckBytes: number;\n\n    /**\n     * Whether to keep the `connection` open (don't call `writable.close` and `readable.cancel`)\n     * when `AdbDaemonTransport.close` is called.\n     *\n     * @default false\n     */\n    preserveConnection?: boolean | undefined;\n\n    /**\n     * When set, the transport will throw an error when\n     * one of the socket readable stalls for this amount of milliseconds.\n     *\n     * Because ADB is a multiplexed protocol, blocking one socket will also block all other sockets.\n     * It's important to always read from all sockets to prevent stalling.\n     *\n     * This option is helpful to detect bugs in the client code.\n     *\n     * @default undefined\n     */\n    readTimeLimit?: number | undefined;\n}\n\n/**\n * An ADB Transport that connects to ADB Daemons directly.\n */\nexport class AdbDaemonTransport implements AdbTransport {\n    /**\n     * Authenticate with the ADB Daemon and create a new transport.\n     */\n    static async authenticate({\n        serial,\n        connection,\n        credentialStore,\n        authenticators = ADB_DEFAULT_AUTHENTICATORS,\n        features = ADB_DAEMON_DEFAULT_FEATURES,\n        initialDelayedAckBytes = ADB_DAEMON_DEFAULT_INITIAL_PAYLOAD_SIZE,\n        ...options\n    }: AdbDaemonAuthenticationOptions): Promise<AdbDaemonTransport> {\n        // Initially, set to highest-supported version and payload size.\n        let version = 0x01000001;\n        // Android 4: 4K, Android 7: 256K, Android 9: 1M\n        let maxPayloadSize = 1024 * 1024;\n\n        const resolver = new PromiseResolver<string>();\n        const authProcessor = new AdbAuthenticationProcessor(\n            authenticators,\n            credentialStore,\n        );\n\n        // Here is similar to `AdbPacketDispatcher`,\n        // But the received packet types and send packet processing are different.\n        const abortController = new AbortController();\n        const pipe = connection.readable\n            .pipeTo(\n                new WritableStream({\n                    async write(packet) {\n                        switch (packet.command) {\n                            case AdbCommand.Connect:\n                                version = Math.min(version, packet.arg0);\n                                maxPayloadSize = Math.min(\n                                    maxPayloadSize,\n                                    packet.arg1,\n                                );\n                                resolver.resolve(decodeUtf8(packet.payload));\n                                break;\n                            case AdbCommand.Auth: {\n                                const response =\n                                    await authProcessor.process(packet);\n                                await sendPacket(response);\n                                break;\n                            }\n                            default:\n                                // Maybe the previous ADB client exited without reading all packets,\n                                // so they are still waiting in OS internal buffer.\n                                // Just ignore them.\n                                // Because a `Connect` packet will reset the device,\n                                // Eventually there will be `Connect` and `Auth` response packets.\n                                break;\n                        }\n                    },\n                }),\n                {\n                    // Don't cancel the source ReadableStream on AbortSignal abort.\n                    preventCancel: true,\n                    signal: abortController.signal,\n                },\n            )\n            .then(\n                () => {\n                    // If `resolver` is already settled, call `reject` won't do anything.\n                    resolver.reject(\n                        new Error(\"Connection closed unexpectedly\"),\n                    );\n                },\n                (e) => {\n                    resolver.reject(e);\n                },\n            );\n\n        const writer = connection.writable.getWriter();\n        async function sendPacket(init: AdbPacketData) {\n            // Always send checksum in auth steps\n            // Because we don't know if the device needs it or not.\n            (init as AdbPacketInit).checksum = calculateChecksum(init.payload);\n            (init as AdbPacketInit).magic = init.command ^ 0xffffffff;\n            await Consumable.WritableStream.write(\n                writer,\n                init as AdbPacketInit,\n            );\n        }\n\n        const actualFeatures = features.slice();\n        if (initialDelayedAckBytes <= 0) {\n            const index = features.indexOf(AdbFeature.DelayedAck);\n            if (index !== -1) {\n                actualFeatures.splice(index, 1);\n            }\n        }\n\n        let banner: string;\n        try {\n            await sendPacket({\n                command: AdbCommand.Connect,\n                arg0: version,\n                arg1: maxPayloadSize,\n                // The terminating `;` is required in formal definition\n                // But ADB daemon (all versions) can still work without it\n                payload: encodeUtf8(\n                    `host::features=${actualFeatures.join(\",\")}`,\n                ),\n            });\n\n            banner = await resolver.promise;\n        } finally {\n            // When failed, release locks on `connection` so the caller can try again.\n            // When success, also release locks so `AdbPacketDispatcher` can use them.\n            abortController.abort();\n            writer.releaseLock();\n\n            // Wait until pipe stops (`ReadableStream` lock released)\n            await pipe;\n        }\n\n        return new AdbDaemonTransport({\n            serial,\n            connection,\n            version,\n            maxPayloadSize,\n            banner,\n            features: actualFeatures,\n            initialDelayedAckBytes,\n            ...options,\n        });\n    }\n\n    #connection: AdbDaemonConnection;\n    get connection() {\n        return this.#connection;\n    }\n\n    readonly #dispatcher: AdbPacketDispatcher;\n\n    #serial: string;\n    get serial() {\n        return this.#serial;\n    }\n\n    #protocolVersion: number;\n    get protocolVersion() {\n        return this.#protocolVersion;\n    }\n\n    get maxPayloadSize() {\n        return this.#dispatcher.options.maxPayloadSize;\n    }\n\n    #banner: AdbBanner;\n    get banner() {\n        return this.#banner;\n    }\n\n    get disconnected() {\n        return this.#dispatcher.disconnected;\n    }\n\n    #clientFeatures: readonly AdbFeature[];\n    get clientFeatures() {\n        return this.#clientFeatures;\n    }\n\n    constructor({\n        serial,\n        connection,\n        version,\n        banner,\n        features = ADB_DAEMON_DEFAULT_FEATURES,\n        initialDelayedAckBytes,\n        ...options\n    }: AdbDaemonSocketConnectorConstructionOptions) {\n        this.#serial = serial;\n        this.#connection = connection;\n        this.#banner = AdbBanner.parse(banner);\n        this.#clientFeatures = features;\n\n        if (features.includes(AdbFeature.DelayedAck)) {\n            if (initialDelayedAckBytes <= 0) {\n                throw new TypeError(\n                    \"`initialDelayedAckBytes` must be greater than 0 when DelayedAck feature is enabled.\",\n                );\n            }\n\n            if (!this.#banner.features.includes(AdbFeature.DelayedAck)) {\n                initialDelayedAckBytes = 0;\n            }\n        } else {\n            initialDelayedAckBytes = 0;\n        }\n\n        let calculateChecksum: boolean;\n        let appendNullToServiceString: boolean;\n        if (version >= ADB_DAEMON_VERSION_OMIT_CHECKSUM) {\n            calculateChecksum = false;\n            appendNullToServiceString = false;\n        } else {\n            calculateChecksum = true;\n            appendNullToServiceString = true;\n        }\n\n        this.#dispatcher = new AdbPacketDispatcher(connection, {\n            calculateChecksum,\n            appendNullToServiceString,\n            initialDelayedAckBytes,\n            ...options,\n        });\n\n        this.#protocolVersion = version;\n    }\n\n    connect(service: string): MaybePromiseLike<AdbSocket> {\n        return this.#dispatcher.createSocket(service);\n    }\n\n    addReverseTunnel(\n        handler: AdbIncomingSocketHandler,\n        address?: string,\n    ): string {\n        if (!address) {\n            const id = Math.random().toString().substring(2);\n            address = `localabstract:reverse_${id}`;\n        }\n        this.#dispatcher.addReverseTunnel(address, handler);\n        return address;\n    }\n\n    removeReverseTunnel(address: string): void {\n        this.#dispatcher.removeReverseTunnel(address);\n    }\n\n    clearReverseTunnels(): void {\n        this.#dispatcher.clearReverseTunnels();\n    }\n\n    close(): MaybePromiseLike<void> {\n        return this.#dispatcher.close();\n    }\n}\n", "// cspell:ignore mdns\n\nimport type { AdbServerClient } from \"../client.js\";\n\nexport class MDnsCommands {\n    readonly #client: AdbServerClient;\n\n    constructor(client: AdbServerClient) {\n        this.#client = client;\n    }\n\n    async check() {\n        const connection =\n            await this.#client.createConnection(\"host:mdns:check\");\n        try {\n            const response = await connection.readString();\n            return !response.startsWith(\"ERROR:\");\n        } finally {\n            await connection.dispose();\n        }\n    }\n\n    async getServices() {\n        const connection =\n            await this.#client.createConnection(\"host:mdns:services\");\n        try {\n            const response = await connection.readString();\n            return response\n                .split(\"\\n\")\n                .filter(Boolean)\n                .map((line) => {\n                    const parts = line.split(\"\\t\");\n                    return {\n                        name: parts[0]!,\n                        service: parts[1]!,\n                        address: parts[2]!,\n                    };\n                });\n        } finally {\n            await connection.dispose();\n        }\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport type { WritableStreamDefaultWriter } from \"@yume-chan/stream-extra\";\nimport {\n    BufferedReadableStream,\n    tryCancel,\n    tryClose,\n} from \"@yume-chan/stream-extra\";\nimport {\n    bipedal,\n    decodeUtf8,\n    encodeUtf8,\n    TextDecoder,\n} from \"@yume-chan/struct\";\n\nimport { hexToNumber, sequenceEqual, write4HexDigits } from \"../utils/index.js\";\n\nimport type { AdbServerClient } from \"./client.js\";\n\nconst OKAY = encodeUtf8(\"OKAY\");\nexport const FAIL = encodeUtf8(\"FAIL\");\n\nexport class AdbServerStream {\n    #connection: AdbServerClient.ServerConnection;\n    #buffered: BufferedReadableStream;\n    #writer: WritableStreamDefaultWriter<Uint8Array>;\n\n    constructor(connection: AdbServerClient.ServerConnection) {\n        this.#connection = connection;\n        this.#buffered = new BufferedReadableStream(connection.readable);\n        this.#writer = connection.writable.getWriter();\n    }\n\n    readExactly(length: number): MaybePromiseLike<Uint8Array> {\n        return this.#buffered.readExactly(length);\n    }\n\n    readString = bipedal(function* (this: AdbServerStream, then) {\n        const data = yield* then(this.readExactly(4));\n        const length = hexToNumber(data);\n        if (length === 0) {\n            return \"\";\n        } else {\n            const decoder = new TextDecoder();\n            let result = \"\";\n            const iterator = this.#buffered.iterateExactly(length);\n            while (true) {\n                const { done, value } = iterator.next();\n                if (done) {\n                    break;\n                }\n                result += decoder.decode(yield* then(value), { stream: true });\n            }\n            result += decoder.decode();\n            return result;\n        }\n    });\n\n    async readOkay(): Promise<void> {\n        const response = await this.readExactly(4);\n        if (sequenceEqual(response, OKAY)) {\n            // `OKAY` is followed by data length and data\n            // But different services want to parse the data differently\n            // So don't read the data here\n            return;\n        }\n\n        if (sequenceEqual(response, FAIL)) {\n            const reason = await this.readString();\n            throw new Error(reason);\n        }\n\n        throw new Error(`Unexpected response: ${decodeUtf8(response)}`);\n    }\n\n    async writeString(value: string): Promise<void> {\n        // TODO: investigate using `encodeUtf8(\"0000\" + value)` then modifying the length\n        // That way allocates a new string (hopefully only a rope) instead of a new buffer\n        const encoded = encodeUtf8(value);\n        const buffer = new Uint8Array(4 + encoded.length);\n        write4HexDigits(buffer, 0, encoded.length);\n        buffer.set(encoded, 4);\n        await this.#writer.write(buffer);\n    }\n\n    release() {\n        this.#writer.releaseLock();\n        return {\n            readable: this.#buffered.release(),\n            writable: this.#connection.writable,\n            closed: this.#connection.closed,\n            close: () => this.#connection.close(),\n        };\n    }\n\n    async dispose() {\n        void tryCancel(this.#buffered);\n        void tryClose(this.#writer);\n        await this.#connection.close();\n    }\n}\n", "// cspell:ignore tport\n\nimport { hexToNumber, sequenceEqual } from \"../../utils/index.js\";\nimport type { AdbServerClient } from \"../client.js\";\nimport { FAIL } from \"../stream.js\";\n\nexport class NetworkError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = \"NetworkError\";\n    }\n}\n\nexport class UnauthorizedError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = \"UnauthorizedError\";\n    }\n}\n\nexport class AlreadyConnectedError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = \"AlreadyConnectedError\";\n    }\n}\n\nexport class WirelessCommands {\n    readonly #client: AdbServerClient;\n\n    constructor(client: AdbServerClient) {\n        this.#client = client;\n    }\n\n    /**\n     * `adb pair <password> <address>`\n     */\n    async pair(address: string, password: string): Promise<void> {\n        const connection = await this.#client.createConnection(\n            `host:pair:${password}:${address}`,\n        );\n        try {\n            const response = await connection.readExactly(4);\n            // `response` is either `FAIL`, or 4 hex digits for length of the string\n            if (sequenceEqual(response, FAIL)) {\n                throw new Error(await connection.readString());\n            }\n            const length = hexToNumber(response);\n            // Ignore the string as it's always `Successful ...`\n            await connection.readExactly(length);\n        } finally {\n            await connection.dispose();\n        }\n    }\n\n    /**\n     * `adb connect <address>`\n     */\n    async connect(address: string): Promise<void> {\n        const connection = await this.#client.createConnection(\n            `host:connect:${address}`,\n        );\n        try {\n            const response = await connection.readString();\n            switch (response) {\n                case `already connected to ${address}`:\n                    throw new AlreadyConnectedError(response);\n                case `failed to connect to ${address}`: // `adb pair` mode not authorized\n                case `failed to authenticate to ${address}`: // `adb tcpip` mode not authorized\n                    throw new UnauthorizedError(response);\n                case `connected to ${address}`:\n                    return;\n                default:\n                    throw new NetworkError(response);\n            }\n        } finally {\n            await connection.dispose();\n        }\n    }\n\n    /**\n     * `adb disconnect <address>`\n     */\n    async disconnect(address: string): Promise<void> {\n        const connection = await this.#client.createConnection(\n            `host:disconnect:${address}`,\n        );\n        try {\n            await connection.readString();\n        } finally {\n            await connection.dispose();\n        }\n    }\n}\n", "import { EventEmitter, StickyEventEmitter } from \"@yume-chan/event\";\n\nimport { Ref } from \"../utils/index.js\";\n\nimport { AdbServerClient } from \"./client.js\";\nimport type { AdbServerStream } from \"./stream.js\";\n\nexport function unorderedRemove<T>(array: T[], index: number) {\n    if (index < 0 || index >= array.length) {\n        return;\n    }\n    array[index] = array[array.length - 1]!;\n    array.length -= 1;\n}\n\ninterface Observer {\n    includeStates: readonly AdbServerClient.ConnectionState[];\n    onDeviceAdd: EventEmitter<readonly AdbServerClient.Device[]>;\n    onDeviceRemove: EventEmitter<readonly AdbServerClient.Device[]>;\n    onListChange: EventEmitter<readonly AdbServerClient.Device[]>;\n    onError: EventEmitter<Error>;\n}\n\nfunction filterDeviceStates(\n    devices: readonly AdbServerClient.Device[],\n    states: readonly AdbServerClient.ConnectionState[],\n) {\n    return devices.filter((device) => states.includes(device.state));\n}\n\nexport class AdbServerDeviceObserverOwner {\n    current: readonly AdbServerClient.Device[] = [];\n\n    readonly #client: AdbServerClient;\n\n    #stream: Promise<AdbServerStream> | undefined;\n    #observers: Observer[] = [];\n\n    constructor(client: AdbServerClient) {\n        this.#client = client;\n    }\n\n    async #receive(stream: AdbServerStream) {\n        const response = await stream.readString();\n        const next = AdbServerClient.parseDeviceList(response);\n\n        const removed = this.current.slice();\n        const added: AdbServerClient.Device[] = [];\n        for (const nextDevice of next) {\n            const index = removed.findIndex(\n                (device) => device.transportId === nextDevice.transportId,\n            );\n\n            if (index === -1) {\n                added.push(nextDevice);\n                continue;\n            }\n\n            unorderedRemove(removed, index);\n        }\n\n        this.current = next;\n\n        if (added.length) {\n            for (const observer of this.#observers) {\n                const filtered = filterDeviceStates(\n                    added,\n                    observer.includeStates,\n                );\n                if (filtered.length) {\n                    observer.onDeviceAdd.fire(filtered);\n                }\n            }\n        }\n        if (removed.length) {\n            for (const observer of this.#observers) {\n                const filtered = filterDeviceStates(\n                    removed,\n                    observer.includeStates,\n                );\n                if (filtered.length) {\n                    observer.onDeviceRemove.fire(removed);\n                }\n            }\n        }\n\n        for (const observer of this.#observers) {\n            const filtered = filterDeviceStates(\n                this.current,\n                observer.includeStates,\n            );\n            observer.onListChange.fire(filtered);\n        }\n    }\n\n    async #receiveLoop(stream: AdbServerStream) {\n        try {\n            while (true) {\n                await this.#receive(stream);\n            }\n        } catch (e) {\n            this.#stream = undefined;\n\n            for (const observer of this.#observers) {\n                observer.onError.fire(e as Error);\n            }\n        }\n    }\n\n    async #connect() {\n        const stream = await this.#client.createConnection(\n            \"host:track-devices-l\",\n            // Each individual observer will ref depending on their options\n            { unref: true },\n        );\n\n        // Set `current` and `onListChange` value before returning\n        await this.#receive(stream);\n\n        // Then start receive loop\n        void this.#receiveLoop(stream);\n\n        return stream;\n    }\n\n    async #handleObserverStop(stream: AdbServerStream) {\n        if (this.#observers.length === 0) {\n            this.#stream = undefined;\n            await stream.dispose();\n        }\n    }\n\n    async createObserver(\n        options?: AdbServerDeviceObserverOwner.Options,\n    ): Promise<AdbServerClient.DeviceObserver> {\n        options?.signal?.throwIfAborted();\n\n        let current: readonly AdbServerClient.Device[] = [];\n        const onDeviceAdd = new EventEmitter<\n            readonly AdbServerClient.Device[]\n        >();\n        const onDeviceRemove = new EventEmitter<\n            readonly AdbServerClient.Device[]\n        >();\n        const onListChange = new StickyEventEmitter<\n            readonly AdbServerClient.Device[]\n        >();\n        const onError = new StickyEventEmitter<Error>();\n\n        const includeStates = options?.includeStates ?? [\n            \"device\",\n            \"unauthorized\",\n        ];\n        const observer = {\n            includeStates,\n            onDeviceAdd,\n            onDeviceRemove,\n            onListChange,\n            onError,\n        } satisfies Observer;\n        // Register `observer` before `#connect`.\n        // So `#handleObserverStop` knows if there is any observer.\n        this.#observers.push(observer);\n\n        // Read the filtered `current` value from `onListChange` event\n        onListChange.event((value) => (current = value));\n\n        let stream: AdbServerStream;\n        if (!this.#stream) {\n            // `#connect` will initialize `onListChange` and `current`\n            this.#stream = this.#connect();\n\n            try {\n                stream = await this.#stream;\n            } catch (e) {\n                this.#stream = undefined;\n                throw e;\n            }\n        } else {\n            stream = await this.#stream;\n            // Initialize `onListChange` and `current` ourselves\n            onListChange.fire(filterDeviceStates(this.current, includeStates));\n        }\n\n        const ref = new Ref(options);\n\n        const stop = async () => {\n            unorderedRemove(this.#observers, this.#observers.indexOf(observer));\n            await this.#handleObserverStop(stream);\n            ref.unref();\n        };\n\n        if (options?.signal) {\n            if (options.signal.aborted) {\n                await stop();\n                throw options.signal.reason;\n            }\n\n            options.signal.addEventListener(\"abort\", () => void stop());\n        }\n\n        return {\n            onDeviceAdd: onDeviceAdd.event,\n            onDeviceRemove: onDeviceRemove.event,\n            onListChange: onListChange.event,\n            onError: onError.event,\n            get current() {\n                return current;\n            },\n            stop,\n        };\n    }\n}\n\nexport namespace AdbServerDeviceObserverOwner {\n    export interface Options extends AdbServerClient.ServerConnectionOptions {\n        includeStates?: readonly AdbServerClient.ConnectionState[];\n    }\n}\n", "import { PromiseResolver } from \"@yume-chan/async\";\n\nimport type {\n    AdbIncomingSocketHandler,\n    AdbSocket,\n    AdbTransport,\n} from \"../adb.js\";\nimport type { AdbBanner } from \"../banner.js\";\nimport { AdbFeature } from \"../features.js\";\n\nimport type { AdbServerClient } from \"./client.js\";\n\nexport const ADB_SERVER_DEFAULT_FEATURES = /* #__PURE__ */ (() =>\n    [\n        AdbFeature.ShellV2,\n        AdbFeature.Cmd,\n        AdbFeature.StatV2,\n        AdbFeature.ListV2,\n        AdbFeature.FixedPushMkdir,\n        \"apex\",\n        AdbFeature.Abb,\n        // only tells the client the symlink timestamp issue in `adb push --sync` has been fixed.\n        // No special handling required.\n        \"fixed_push_symlink_timestamp\",\n        AdbFeature.AbbExec,\n        \"remount_shell\",\n        \"track_app\",\n        AdbFeature.SendReceiveV2,\n        \"sendrecv_v2_brotli\",\n        \"sendrecv_v2_lz4\",\n        \"sendrecv_v2_zstd\",\n        \"sendrecv_v2_dry_run_send\",\n    ] as readonly AdbFeature[])();\n\nexport class AdbServerTransport implements AdbTransport {\n    #client: AdbServerClient;\n\n    readonly serial: string;\n\n    readonly transportId: bigint;\n\n    readonly maxPayloadSize: number = 1 * 1024 * 1024;\n\n    readonly banner: AdbBanner;\n\n    #sockets: AdbSocket[] = [];\n\n    #closed = new PromiseResolver<void>();\n    #disconnected: Promise<void>;\n    get disconnected() {\n        return this.#disconnected;\n    }\n\n    get clientFeatures() {\n        // No need to get host features (features supported by ADB server)\n        // Because we create all ADB packets ourselves\n        return ADB_SERVER_DEFAULT_FEATURES;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/max-params\n    constructor(\n        client: AdbServerClient,\n        serial: string,\n        banner: AdbBanner,\n        transportId: bigint,\n        disconnected: Promise<void>,\n    ) {\n        this.#client = client;\n        this.serial = serial;\n        this.banner = banner;\n        this.transportId = transportId;\n\n        this.#disconnected = Promise.race([this.#closed.promise, disconnected]);\n    }\n\n    async connect(service: string): Promise<AdbSocket> {\n        const socket = await this.#client.createDeviceConnection(\n            { transportId: this.transportId },\n            service,\n        );\n        this.#sockets.push(socket);\n        return socket;\n    }\n\n    async addReverseTunnel(\n        handler: AdbIncomingSocketHandler,\n        address?: string,\n    ): Promise<string> {\n        return await this.#client.connector.addReverseTunnel(handler, address);\n    }\n\n    async removeReverseTunnel(address: string): Promise<void> {\n        await this.#client.connector.removeReverseTunnel(address);\n    }\n\n    async clearReverseTunnels(): Promise<void> {\n        await this.#client.connector.clearReverseTunnels();\n    }\n\n    async close(): Promise<void> {\n        for (const socket of this.#sockets) {\n            await socket.close();\n        }\n        this.#sockets.length = 0;\n        this.#closed.resolve();\n    }\n}\n", "// cspell:ignore tport\n\nimport type { MaybePromiseLike } from \"@yume-chan/async\";\nimport { PromiseResolver } from \"@yume-chan/async\";\nimport type { Event } from \"@yume-chan/event\";\nimport { getUint64LittleEndian } from \"@yume-chan/no-data-view\";\nimport type {\n    AbortSignal,\n    MaybeConsumable,\n    ReadableWritablePair,\n} from \"@yume-chan/stream-extra\";\nimport { AbortController } from \"@yume-chan/stream-extra\";\n\nimport type { AdbIncomingSocketHandler, AdbSocket, Closeable } from \"../adb.js\";\nimport { Adb } from \"../adb.js\";\nimport { AdbBanner } from \"../banner.js\";\nimport type { DeviceObserver as DeviceObserverBase } from \"../device-observer.js\";\nimport type { AdbFeature } from \"../features.js\";\nimport { hexToNumber } from \"../utils/index.js\";\n\nimport {\n    MDnsCommands,\n    WirelessCommands,\n    AlreadyConnectedError as _AlreadyConnectedError,\n    NetworkError as _NetworkError,\n    UnauthorizedError as _UnauthorizedError,\n} from \"./commands/index.js\";\nimport { AdbServerDeviceObserverOwner } from \"./observer.js\";\nimport { AdbServerStream } from \"./stream.js\";\nimport { AdbServerTransport } from \"./transport.js\";\n\n/**\n * Client for the ADB Server.\n */\nexport class AdbServerClient {\n    static NetworkError = _NetworkError;\n    static UnauthorizedError = _UnauthorizedError;\n    static AlreadyConnectedError = _AlreadyConnectedError;\n\n    static parseDeviceList(\n        value: string,\n        includeStates: readonly AdbServerClient.ConnectionState[] = [\n            \"device\",\n            \"unauthorized\",\n        ],\n    ): AdbServerClient.Device[] {\n        const devices: AdbServerClient.Device[] = [];\n        for (const line of value.split(\"\\n\")) {\n            if (!line) {\n                continue;\n            }\n\n            const parts = line.split(\" \").filter(Boolean);\n            const serial = parts[0]!;\n            const state = parts[1]! as AdbServerClient.ConnectionState;\n            if (!includeStates.includes(state)) {\n                continue;\n            }\n\n            let product: string | undefined;\n            let model: string | undefined;\n            let device: string | undefined;\n            let transportId: bigint | undefined;\n            for (let i = 2; i < parts.length; i += 1) {\n                const [key, value] = parts[i]!.split(\":\");\n                switch (key) {\n                    case \"product\":\n                        product = value;\n                        break;\n                    case \"model\":\n                        model = value;\n                        break;\n                    case \"device\":\n                        device = value;\n                        break;\n                    case \"transport_id\":\n                        transportId = BigInt(value!);\n                        break;\n                }\n            }\n            if (!transportId) {\n                throw new Error(`No transport id for device ${serial}`);\n            }\n            devices.push({\n                serial,\n                state,\n                authenticating: state === \"unauthorized\",\n                product,\n                model,\n                device,\n                transportId,\n            });\n        }\n        return devices;\n    }\n\n    static formatDeviceService(\n        device: AdbServerClient.DeviceSelector,\n        command: string,\n    ) {\n        if (!device) {\n            return `host:${command}`;\n        }\n        if (\"transportId\" in device) {\n            return `host-transport-id:${device.transportId}:${command}`;\n        }\n        if (\"serial\" in device) {\n            return `host-serial:${device.serial}:${command}`;\n        }\n        if (\"usb\" in device) {\n            return `host-usb:${command}`;\n        }\n        if (\"tcp\" in device) {\n            return `host-local:${command}`;\n        }\n        throw new TypeError(\"Invalid device selector\");\n    }\n\n    readonly connector: AdbServerClient.ServerConnector;\n\n    readonly wireless = new WirelessCommands(this);\n    readonly mDns = new MDnsCommands(this);\n    readonly #observerOwner = new AdbServerDeviceObserverOwner(this);\n\n    constructor(connector: AdbServerClient.ServerConnector) {\n        this.connector = connector;\n    }\n\n    async createConnection(\n        request: string,\n        options?: AdbServerClient.ServerConnectionOptions,\n    ): Promise<AdbServerStream> {\n        const connection = await this.connector.connect(options);\n        const stream = new AdbServerStream(connection);\n\n        try {\n            await stream.writeString(request);\n        } catch (e) {\n            await stream.dispose();\n            throw e;\n        }\n\n        try {\n            // `raceSignal` throws when the signal is aborted,\n            // so the `catch` block can close the connection.\n            await raceSignal(() => stream.readOkay(), options?.signal);\n            return stream;\n        } catch (e) {\n            await stream.dispose();\n            throw e;\n        }\n    }\n\n    /**\n     * `adb version`\n     */\n    async getVersion(): Promise<number> {\n        const connection = await this.createConnection(\"host:version\");\n        try {\n            const length = hexToNumber(await connection.readExactly(4));\n            const version = hexToNumber(await connection.readExactly(length));\n            return version;\n        } finally {\n            await connection.dispose();\n        }\n    }\n\n    async validateVersion(minimalVersion: number) {\n        const version = await this.getVersion();\n        if (version < minimalVersion) {\n            throw new Error(\n                `adb server version (${version}) doesn't match this client (${minimalVersion})`,\n            );\n        }\n    }\n\n    /**\n     * `adb kill-server`\n     */\n    async killServer(): Promise<void> {\n        const connection = await this.createConnection(\"host:kill\");\n        await connection.dispose();\n    }\n\n    /**\n     * `adb host-features`\n     */\n    async getServerFeatures(): Promise<AdbFeature[]> {\n        const connection = await this.createConnection(\"host:host-features\");\n        try {\n            const response = await connection.readString();\n            return response.split(\",\") as AdbFeature[];\n        } finally {\n            await connection.dispose();\n        }\n    }\n\n    /**\n     * Get a list of connected devices from ADB Server.\n     *\n     * Equivalent ADB Command: `adb devices -l`\n     */\n    async getDevices(\n        includeStates: readonly AdbServerClient.ConnectionState[] = [\n            \"device\",\n            \"unauthorized\",\n        ],\n    ): Promise<AdbServerClient.Device[]> {\n        const connection = await this.createConnection(\"host:devices-l\");\n        try {\n            const response = await connection.readString();\n            return AdbServerClient.parseDeviceList(response, includeStates);\n        } finally {\n            await connection.dispose();\n        }\n    }\n\n    /**\n     * Monitors device list changes.\n     */\n    async trackDevices(\n        options?: AdbServerDeviceObserverOwner.Options,\n    ): Promise<AdbServerClient.DeviceObserver> {\n        return this.#observerOwner.createObserver(options);\n    }\n\n    /**\n     * `adb -s <device> reconnect` or `adb reconnect offline`\n     */\n    async reconnectDevice(device: AdbServerClient.DeviceSelector | \"offline\") {\n        const connection = await this.createConnection(\n            device === \"offline\"\n                ? \"host:reconnect-offline\"\n                : AdbServerClient.formatDeviceService(device, \"reconnect\"),\n        );\n        try {\n            await connection.readString();\n        } finally {\n            await connection.dispose();\n        }\n    }\n\n    /**\n     * Gets the features supported by the device.\n     * The transport ID of the selected device is also returned,\n     * so the caller can execute other commands against the same device.\n     * @param device The device selector\n     * @returns The transport ID of the selected device, and the features supported by the device.\n     */\n    async getDeviceFeatures(\n        device: AdbServerClient.DeviceSelector,\n    ): Promise<{ transportId: bigint; features: readonly AdbFeature[] }> {\n        // On paper, `host:features` is a host service (device features are cached in host),\n        // so it shouldn't use `createDeviceConnection`,\n        // which is used to forward the service to the device.\n        //\n        // However, `createDeviceConnection` is a two step process:\n        //\n        //    1. Send a switch device service to host, to switch the connection to the device.\n        //    2. Send the actual service to host, let it forward the service to the device.\n        //\n        // In step 2, the host only forward the service to device if the service is unknown to host.\n        // If the service is a host service, it's still handled by host.\n        //\n        // Even better, if the service needs a device selector, but the selector is not provided,\n        // the service will be executed against the device selected by the switch device service.\n        // So we can use all device selector formats for the host service,\n        // and get the transport ID in the same time.\n        const connection = await this.createDeviceConnection(\n            device,\n            \"host:features\",\n        );\n        // Luckily `AdbServerClient.Socket` is compatible with `AdbServerClient.ServerConnection`\n        const stream = new AdbServerStream(connection);\n        try {\n            const featuresString = await stream.readString();\n            const features = featuresString.split(\",\") as AdbFeature[];\n            return { transportId: connection.transportId, features };\n        } finally {\n            await stream.dispose();\n        }\n    }\n\n    /**\n     * Creates a connection that will forward the service to device.\n     * @param device The device selector\n     * @param service The service to forward\n     * @returns An `AdbServerClient.Socket` that can be used to communicate with the service\n     */\n    async createDeviceConnection(\n        device: AdbServerClient.DeviceSelector,\n        service: string,\n    ): Promise<AdbServerClient.Socket> {\n        let switchService: string;\n        let transportId: bigint | undefined;\n        if (!device) {\n            await this.validateVersion(41);\n            switchService = `host:tport:any`;\n        } else if (\"transportId\" in device) {\n            switchService = `host:transport-id:${device.transportId}`;\n            transportId = device.transportId;\n        } else if (\"serial\" in device) {\n            await this.validateVersion(41);\n            switchService = `host:tport:serial:${device.serial}`;\n        } else if (\"usb\" in device) {\n            await this.validateVersion(41);\n            switchService = `host:tport:usb`;\n        } else if (\"tcp\" in device) {\n            await this.validateVersion(41);\n            switchService = `host:tport:local`;\n        } else {\n            throw new TypeError(\"Invalid device selector\");\n        }\n\n        const connection = await this.createConnection(switchService);\n\n        try {\n            await connection.writeString(service);\n        } catch (e) {\n            await connection.dispose();\n            throw e;\n        }\n\n        try {\n            if (transportId === undefined) {\n                const array = await connection.readExactly(8);\n                transportId = getUint64LittleEndian(array, 0);\n            }\n\n            await connection.readOkay();\n\n            const socket = connection.release();\n\n            return {\n                transportId,\n                service,\n                readable: socket.readable,\n                writable: socket.writable,\n                get closed() {\n                    return socket.closed;\n                },\n                async close() {\n                    await socket.close();\n                },\n            };\n        } catch (e) {\n            await connection.dispose();\n            throw e;\n        }\n    }\n    async #waitForUnchecked(\n        device: AdbServerClient.DeviceSelector,\n        state: \"device\" | \"disconnect\",\n        options?: AdbServerClient.ServerConnectionOptions,\n    ): Promise<void> {\n        let type: string;\n        if (!device) {\n            type = \"any\";\n        } else if (\"transportId\" in device) {\n            type = \"any\";\n        } else if (\"serial\" in device) {\n            type = \"any\";\n        } else if (\"usb\" in device) {\n            type = \"usb\";\n        } else if (\"tcp\" in device) {\n            type = \"local\";\n        } else {\n            throw new TypeError(\"Invalid device selector\");\n        }\n\n        // `waitFor` can't use `connectDevice`, because the device\n        // might not be available yet.\n        const service = AdbServerClient.formatDeviceService(\n            device,\n            `wait-for-${type}-${state}`,\n        );\n\n        const connection = await this.createConnection(service, options);\n        try {\n            await connection.readOkay();\n        } finally {\n            await connection.dispose();\n        }\n    }\n\n    /**\n     * Wait for a device to be connected or disconnected.\n     *\n     * `adb wait-for-<state>`\n     *\n     * @param device The device selector\n     * @param state The state to wait for\n     * @param options The options\n     * @returns A promise that resolves when the condition is met.\n     */\n    async waitFor(\n        device: AdbServerClient.DeviceSelector,\n        state: \"device\" | \"disconnect\",\n        options?: AdbServerClient.ServerConnectionOptions,\n    ): Promise<void> {\n        if (state === \"disconnect\") {\n            await this.validateVersion(41);\n        }\n\n        return this.#waitForUnchecked(device, state, options);\n    }\n\n    async waitForDisconnect(\n        transportId: bigint,\n        options?: AdbServerClient.ServerConnectionOptions,\n    ): Promise<void> {\n        const serverVersion = await this.getVersion();\n        if (serverVersion >= 41) {\n            return this.#waitForUnchecked(\n                { transportId },\n                \"disconnect\",\n                options,\n            );\n        } else {\n            const observer = await this.trackDevices(options);\n            return new Promise<void>((resolve, reject) => {\n                observer.onDeviceRemove((devices) => {\n                    if (\n                        devices.some(\n                            (device) => device.transportId === transportId,\n                        )\n                    ) {\n                        observer.stop();\n                        resolve();\n                    }\n                });\n                observer.onError((e) => {\n                    observer.stop();\n                    reject(e);\n                });\n            });\n        }\n    }\n\n    /**\n     * Creates an ADB Transport for the specified device.\n     */\n    async createTransport(\n        device: AdbServerClient.DeviceSelector,\n    ): Promise<AdbServerTransport> {\n        const { transportId, features } = await this.getDeviceFeatures(device);\n\n        const devices = await this.getDevices();\n        const info = devices.find(\n            (device) => device.transportId === transportId,\n        );\n\n        const banner = new AdbBanner(\n            info?.product,\n            info?.model,\n            info?.device,\n            features,\n        );\n\n        const waitAbortController = new AbortController();\n        const disconnected = this.waitForDisconnect(transportId, {\n            unref: true,\n            signal: waitAbortController.signal,\n        });\n\n        const transport = new AdbServerTransport(\n            this,\n            info?.serial ?? \"\",\n            banner,\n            transportId,\n            disconnected,\n        );\n\n        void transport.disconnected.finally(() => waitAbortController.abort());\n\n        return transport;\n    }\n\n    async createAdb(device: AdbServerClient.DeviceSelector) {\n        const transport = await this.createTransport(device);\n        return new Adb(transport);\n    }\n}\n\nexport async function raceSignal<T>(\n    callback: () => PromiseLike<T>,\n    ...signals: (AbortSignal | undefined)[]\n): Promise<T> {\n    const abortPromise = new PromiseResolver<never>();\n    function abort(this: AbortSignal) {\n        abortPromise.reject(this.reason);\n    }\n\n    try {\n        for (const signal of signals) {\n            if (!signal) {\n                continue;\n            }\n            if (signal.aborted) {\n                throw signal.reason;\n            }\n            signal.addEventListener(\"abort\", abort);\n        }\n\n        return await Promise.race([callback(), abortPromise.promise]);\n    } finally {\n        for (const signal of signals) {\n            if (!signal) {\n                continue;\n            }\n            signal.removeEventListener(\"abort\", abort);\n        }\n    }\n}\n\nexport namespace AdbServerClient {\n    export interface ServerConnectionOptions {\n        unref?: boolean | undefined;\n        signal?: AbortSignal | undefined;\n    }\n\n    export interface ServerConnection\n        extends ReadableWritablePair<Uint8Array, MaybeConsumable<Uint8Array>>,\n            Closeable {\n        get closed(): Promise<undefined>;\n    }\n\n    export interface ServerConnector {\n        connect(\n            options?: ServerConnectionOptions,\n        ): MaybePromiseLike<ServerConnection>;\n\n        addReverseTunnel(\n            handler: AdbIncomingSocketHandler,\n            address?: string,\n        ): MaybePromiseLike<string>;\n\n        removeReverseTunnel(address: string): MaybePromiseLike<void>;\n\n        clearReverseTunnels(): MaybePromiseLike<void>;\n    }\n\n    export interface Socket extends AdbSocket {\n        transportId: bigint;\n    }\n\n    /**\n     * A union type for selecting a device.\n     */\n    export type DeviceSelector =\n        | { transportId: bigint }\n        | { serial: string }\n        | { usb: true }\n        | { tcp: true }\n        | undefined;\n\n    export type ConnectionState = \"unauthorized\" | \"offline\" | \"device\";\n\n    export interface Device {\n        serial: string;\n        state: ConnectionState;\n        /** @deprecated Use {@link state} instead */\n        authenticating: boolean;\n        product?: string | undefined;\n        model?: string | undefined;\n        device?: string | undefined;\n        transportId: bigint;\n    }\n\n    export interface DeviceObserver extends DeviceObserverBase<Device> {\n        onError: Event<Error>;\n    }\n\n    export type NetworkError = _NetworkError;\n    export type UnauthorizedError = _UnauthorizedError;\n    export type AlreadyConnectedError = _AlreadyConnectedError;\n}\n", "export * from \"./device.js\";\nexport * from \"./manager.js\";\nexport * from \"./utils.js\";\nexport * from \"./observer.js\";\n", "export class DeviceBusyError extends Error {\n    constructor(cause?: Error) {\n        super(\"The device is already in used by another program\", {\n            cause,\n        });\n    }\n}\n", "export function isErrorName(e: unknown, name: string): e is Error {\n    // node-usb package doesn't use `DOMException`,\n    // so use a looser check\n    // https://github.com/node-usb/node-usb/issues/573\n    return (\n        typeof e === \"object\" && e !== null && \"name\" in e && e.name === name\n    );\n}\n\nexport type PickNonNullable<T, K extends keyof T> = {\n    [P in K]-?: NonNullable<T[P]>;\n};\n\n/**\n * `classCode`, `subclassCode` and `protocolCode` are required\n * for selecting correct USB configuration and interface.\n */\nexport type UsbInterfaceFilter = PickNonNullable<\n    USBDeviceFilter,\n    \"classCode\" | \"subclassCode\" | \"protocolCode\"\n>;\n\nexport function isUsbInterfaceFilter(\n    filter: USBDeviceFilter,\n): filter is UsbInterfaceFilter {\n    return (\n        filter.classCode !== undefined &&\n        filter.subclassCode !== undefined &&\n        filter.protocolCode !== undefined\n    );\n}\n\nfunction matchUsbInterfaceFilter(\n    alternate: USBAlternateInterface,\n    filter: UsbInterfaceFilter,\n) {\n    return (\n        alternate.interfaceClass === filter.classCode &&\n        alternate.interfaceSubclass === filter.subclassCode &&\n        alternate.interfaceProtocol === filter.protocolCode\n    );\n}\n\nexport interface UsbInterfaceIdentifier {\n    configuration: USBConfiguration;\n    interface_: USBInterface;\n    alternate: USBAlternateInterface;\n}\n\nexport function findUsbInterface(\n    device: USBDevice,\n    filter: UsbInterfaceFilter,\n): UsbInterfaceIdentifier | undefined {\n    for (const configuration of device.configurations) {\n        for (const interface_ of configuration.interfaces) {\n            for (const alternate of interface_.alternates) {\n                if (matchUsbInterfaceFilter(alternate, filter)) {\n                    return { configuration, interface_, alternate };\n                }\n            }\n        }\n    }\n    return undefined;\n}\n\nfunction padNumber(value: number) {\n    return value.toString(16).padStart(4, \"0\");\n}\n\nexport function getSerialNumber(device: USBDevice) {\n    if (device.serialNumber) {\n        return device.serialNumber;\n    }\n\n    return padNumber(device.vendorId) + \"x\" + padNumber(device.productId);\n}\n\n/**\n * Find the first pair of input and output endpoints from an alternate interface.\n *\n * ADB interface only has two endpoints, one for input and one for output.\n */\nexport function findUsbEndpoints(endpoints: readonly USBEndpoint[]) {\n    if (endpoints.length === 0) {\n        throw new TypeError(\"No endpoints given\");\n    }\n\n    let inEndpoint: USBEndpoint | undefined;\n    let outEndpoint: USBEndpoint | undefined;\n\n    for (const endpoint of endpoints) {\n        switch (endpoint.direction) {\n            case \"in\":\n                inEndpoint = endpoint;\n                if (outEndpoint) {\n                    return { inEndpoint, outEndpoint };\n                }\n                break;\n            case \"out\":\n                outEndpoint = endpoint;\n                if (inEndpoint) {\n                    return { inEndpoint, outEndpoint };\n                }\n                break;\n        }\n    }\n\n    if (!inEndpoint) {\n        throw new TypeError(\"No input endpoint found.\");\n    }\n    if (!outEndpoint) {\n        throw new TypeError(\"No output endpoint found.\");\n    }\n    throw new Error(\"unreachable\");\n}\n\nexport function matchFilter(\n    device: USBDevice,\n    filter: USBDeviceFilter & UsbInterfaceFilter,\n): UsbInterfaceIdentifier | false;\nexport function matchFilter(\n    device: USBDevice,\n    filter: USBDeviceFilter,\n): boolean;\nexport function matchFilter(\n    device: USBDevice,\n    filter: USBDeviceFilter,\n): UsbInterfaceIdentifier | boolean {\n    if (filter.vendorId !== undefined && device.vendorId !== filter.vendorId) {\n        return false;\n    }\n\n    if (\n        filter.productId !== undefined &&\n        device.productId !== filter.productId\n    ) {\n        return false;\n    }\n\n    if (\n        filter.serialNumber !== undefined &&\n        getSerialNumber(device) !== filter.serialNumber\n    ) {\n        return false;\n    }\n\n    if (isUsbInterfaceFilter(filter)) {\n        return findUsbInterface(device, filter) || false;\n    }\n\n    return true;\n}\n\nexport function matchFilters(\n    device: USBDevice,\n    filters: readonly (USBDeviceFilter & UsbInterfaceFilter)[],\n    exclusionFilters?: readonly USBDeviceFilter[],\n): UsbInterfaceIdentifier | false;\nexport function matchFilters(\n    device: USBDevice,\n    filters: readonly USBDeviceFilter[],\n    exclusionFilters?: readonly USBDeviceFilter[],\n): boolean;\nexport function matchFilters(\n    device: USBDevice,\n    filters: readonly USBDeviceFilter[],\n    exclusionFilters?: readonly USBDeviceFilter[],\n): UsbInterfaceIdentifier | boolean {\n    if (exclusionFilters && exclusionFilters.length > 0) {\n        if (matchFilters(device, exclusionFilters)) {\n            return false;\n        }\n    }\n\n    for (const filter of filters) {\n        const result = matchFilter(device, filter);\n        if (result) {\n            return result;\n        }\n    }\n    return false;\n}\n", "import type {\n    AdbDaemonDevice,\n    AdbPacketData,\n    AdbPacketInit,\n} from \"@yume-chan/adb\";\nimport {\n    AdbPacketHeader,\n    AdbPacketSerializeStream,\n    toLocalUint8Array,\n    unreachable,\n} from \"@yume-chan/adb\";\nimport type {\n    Consumable,\n    ReadableWritablePair,\n    WritableStream,\n} from \"@yume-chan/stream-extra\";\nimport {\n    DuplexStreamFactory,\n    MaybeConsumable,\n    ReadableStream,\n    pipeFrom,\n} from \"@yume-chan/stream-extra\";\nimport { EmptyUint8Array, Uint8ArrayExactReadable } from \"@yume-chan/struct\";\n\nimport { DeviceBusyError as _DeviceBusyError } from \"./error.js\";\nimport type { UsbInterfaceFilter, UsbInterfaceIdentifier } from \"./utils.js\";\nimport { findUsbEndpoints, getSerialNumber, isErrorName } from \"./utils.js\";\n\n/**\n * The default filter for ADB devices, as defined by Google.\n */\nexport const AdbDefaultInterfaceFilter = {\n    classCode: 0xff,\n    subclassCode: 0x42,\n    protocolCode: 1,\n} as const satisfies UsbInterfaceFilter;\n\nexport function mergeDefaultAdbInterfaceFilter(\n    filters: readonly USBDeviceFilter[] | undefined,\n): (USBDeviceFilter & UsbInterfaceFilter)[] {\n    if (!filters || filters.length === 0) {\n        return [AdbDefaultInterfaceFilter];\n    } else {\n        return filters.map((filter) => ({\n            ...filter,\n            classCode: filter.classCode ?? AdbDefaultInterfaceFilter.classCode,\n            subclassCode:\n                filter.subclassCode ?? AdbDefaultInterfaceFilter.subclassCode,\n            protocolCode:\n                filter.protocolCode ?? AdbDefaultInterfaceFilter.protocolCode,\n        }));\n    }\n}\n\nexport class AdbDaemonWebUsbConnection\n    implements ReadableWritablePair<AdbPacketData, Consumable<AdbPacketInit>>\n{\n    readonly #device: AdbDaemonWebUsbDevice;\n    get device() {\n        return this.#device;\n    }\n\n    readonly #inEndpoint: USBEndpoint;\n    get inEndpoint() {\n        return this.#inEndpoint;\n    }\n\n    readonly #outEndpoint: USBEndpoint;\n    get outEndpoint() {\n        return this.#outEndpoint;\n    }\n\n    readonly #readable: ReadableStream<AdbPacketData>;\n    get readable() {\n        return this.#readable;\n    }\n\n    readonly #writable: WritableStream<Consumable<AdbPacketInit>>;\n    get writable() {\n        return this.#writable;\n    }\n\n    constructor(\n        device: AdbDaemonWebUsbDevice,\n        inEndpoint: USBEndpoint,\n        outEndpoint: USBEndpoint,\n        usbManager: USB,\n    ) {\n        this.#device = device;\n        this.#inEndpoint = inEndpoint;\n        this.#outEndpoint = outEndpoint;\n\n        let closed = false;\n\n        const duplex = new DuplexStreamFactory<\n            AdbPacketData,\n            Consumable<Uint8Array>\n        >({\n            close: async () => {\n                try {\n                    closed = true;\n                    await device.raw.close();\n                } catch {\n                    /* device may have already disconnected */\n                }\n            },\n            dispose: () => {\n                closed = true;\n                usbManager.removeEventListener(\n                    \"disconnect\",\n                    handleUsbDisconnect,\n                );\n            },\n        });\n\n        function handleUsbDisconnect(e: USBConnectionEvent) {\n            if (e.device === device.raw) {\n                duplex.dispose().catch(unreachable);\n            }\n        }\n\n        usbManager.addEventListener(\"disconnect\", handleUsbDisconnect);\n\n        this.#readable = duplex.wrapReadable(\n            new ReadableStream<AdbPacketData>(\n                {\n                    pull: async (controller) => {\n                        const packet = await this.#transferIn();\n                        if (packet) {\n                            controller.enqueue(packet);\n                        } else {\n                            controller.close();\n                        }\n                    },\n                },\n                { highWaterMark: 0 },\n            ),\n        );\n\n        const zeroMask = outEndpoint.packetSize - 1;\n        this.#writable = pipeFrom(\n            duplex.createWritable(\n                new MaybeConsumable.WritableStream({\n                    write: async (chunk) => {\n                        try {\n                            await device.raw.transferOut(\n                                outEndpoint.endpointNumber,\n                                toLocalUint8Array(chunk),\n                            );\n\n                            // In USB protocol, a not-full packet indicates the end of a transfer.\n                            // If the payload size is a multiple of the packet size,\n                            // we need to send an empty packet to indicate the end,\n                            // so the OS will send it to the device immediately.\n                            if (zeroMask && (chunk.length & zeroMask) === 0) {\n                                await device.raw.transferOut(\n                                    outEndpoint.endpointNumber,\n                                    EmptyUint8Array,\n                                );\n                            }\n                        } catch (e) {\n                            if (closed) {\n                                return;\n                            }\n                            throw e;\n                        }\n                    },\n                }),\n            ),\n            new AdbPacketSerializeStream(),\n        );\n    }\n\n    async #transferIn(): Promise<AdbPacketData | undefined> {\n        try {\n            while (true) {\n                // ADB daemon sends each packet in two parts, the 24-byte header and the payload.\n                const result = await this.#device.raw.transferIn(\n                    this.#inEndpoint.endpointNumber,\n                    this.#inEndpoint.packetSize,\n                );\n\n                if (result.data!.byteLength !== 24) {\n                    continue;\n                }\n\n                // Per spec, the `result.data` always covers the whole `buffer`.\n                const buffer = new Uint8Array(result.data!.buffer);\n                const stream = new Uint8ArrayExactReadable(buffer);\n\n                // Add `payload` field to its type, it's assigned below.\n                const packet = AdbPacketHeader.deserialize(\n                    stream,\n                ) as AdbPacketHeader & { payload: Uint8Array };\n\n                if (packet.magic !== (packet.command ^ 0xffffffff)) {\n                    continue;\n                }\n\n                if (packet.payloadLength !== 0) {\n                    const result = await this.#device.raw.transferIn(\n                        this.#inEndpoint.endpointNumber,\n                        packet.payloadLength,\n                    );\n                    packet.payload = new Uint8Array(result.data!.buffer);\n                } else {\n                    packet.payload = EmptyUint8Array;\n                }\n\n                return packet;\n            }\n        } catch (e) {\n            // On Windows, disconnecting the device will cause `NetworkError` to be thrown,\n            // even before the `disconnect` event is fired.\n            // Wait a little while and check if the device is still connected.\n            // https://github.com/WICG/webusb/issues/219\n            if (isErrorName(e, \"NetworkError\")) {\n                await new Promise<void>((resolve) => {\n                    setTimeout(() => {\n                        resolve();\n                    }, 100);\n                });\n\n                if (closed) {\n                    return undefined;\n                }\n            }\n\n            throw e;\n        }\n    }\n}\n\nexport class AdbDaemonWebUsbDevice implements AdbDaemonDevice {\n    static DeviceBusyError = _DeviceBusyError;\n\n    readonly #interface: UsbInterfaceIdentifier;\n    readonly #usbManager: USB;\n\n    readonly #raw: USBDevice;\n    get raw() {\n        return this.#raw;\n    }\n\n    readonly #serial: string;\n    get serial(): string {\n        return this.#serial;\n    }\n\n    get name(): string {\n        return this.#raw.productName!;\n    }\n\n    /**\n     * Create a new instance of `AdbDaemonWebUsbConnection` using a specified `USBDevice` instance\n     *\n     * @param device The `USBDevice` instance obtained elsewhere.\n     * @param filters The filters to use when searching for ADB interface. Defaults to {@link ADB_DEFAULT_DEVICE_FILTER}.\n     */\n    constructor(\n        device: USBDevice,\n        interface_: UsbInterfaceIdentifier,\n        usbManager: USB,\n    ) {\n        this.#raw = device;\n        this.#serial = getSerialNumber(device);\n        this.#interface = interface_;\n        this.#usbManager = usbManager;\n    }\n\n    async #claimInterface(): Promise<{\n        inEndpoint: USBEndpoint;\n        outEndpoint: USBEndpoint;\n    }> {\n        if (!this.#raw.opened) {\n            await this.#raw.open();\n        }\n\n        const { configuration, interface_, alternate } = this.#interface;\n\n        if (\n            this.#raw.configuration?.configurationValue !==\n            configuration.configurationValue\n        ) {\n            // Note: Switching configuration is not supported on Windows,\n            // but Android devices should always expose ADB function at the first (default) configuration.\n            await this.#raw.selectConfiguration(\n                configuration.configurationValue,\n            );\n        }\n\n        if (!interface_.claimed) {\n            try {\n                await this.#raw.claimInterface(interface_.interfaceNumber);\n            } catch (e) {\n                if (isErrorName(e, \"NetworkError\")) {\n                    throw new AdbDaemonWebUsbDevice.DeviceBusyError(e);\n                }\n\n                throw e;\n            }\n        }\n\n        if (\n            interface_.alternate.alternateSetting !== alternate.alternateSetting\n        ) {\n            await this.#raw.selectAlternateInterface(\n                interface_.interfaceNumber,\n                alternate.alternateSetting,\n            );\n        }\n\n        return findUsbEndpoints(alternate.endpoints);\n    }\n\n    /**\n     * Open the device and create a new connection to the ADB Daemon.\n     */\n    async connect(): Promise<AdbDaemonWebUsbConnection> {\n        const { inEndpoint, outEndpoint } = await this.#claimInterface();\n        return new AdbDaemonWebUsbConnection(\n            this,\n            inEndpoint,\n            outEndpoint,\n            this.#usbManager,\n        );\n    }\n}\n\nexport namespace AdbDaemonWebUsbDevice {\n    export type DeviceBusyError = _DeviceBusyError;\n}\n", "import type { DeviceObserver } from \"@yume-chan/adb\";\nimport { unorderedRemove } from \"@yume-chan/adb\";\nimport { EventEmitter, StickyEventEmitter } from \"@yume-chan/event\";\n\nimport {\n    AdbDaemonWebUsbDevice,\n    mergeDefaultAdbInterfaceFilter,\n} from \"./device.js\";\nimport type { AdbDaemonWebUsbDeviceManager } from \"./manager.js\";\nimport type { UsbInterfaceFilter } from \"./utils.js\";\nimport { matchFilters } from \"./utils.js\";\n\n/**\n * A watcher that listens for new WebUSB devices and notifies the callback when\n * a new device is connected or disconnected.\n */\nexport class AdbDaemonWebUsbDeviceObserver\n    implements DeviceObserver<AdbDaemonWebUsbDevice>\n{\n    static async create(\n        usb: USB,\n        options: AdbDaemonWebUsbDeviceManager.RequestDeviceOptions = {},\n    ) {\n        const devices = await usb.getDevices();\n        return new AdbDaemonWebUsbDeviceObserver(usb, devices, options);\n    }\n\n    readonly #filters: readonly (USBDeviceFilter & UsbInterfaceFilter)[];\n    readonly #exclusionFilters?: readonly USBDeviceFilter[] | undefined;\n    readonly #usbManager: USB;\n\n    readonly #onDeviceAdd = new EventEmitter<\n        readonly AdbDaemonWebUsbDevice[]\n    >();\n    onDeviceAdd = this.#onDeviceAdd.event;\n\n    readonly #onDeviceRemove = new EventEmitter<\n        readonly AdbDaemonWebUsbDevice[]\n    >();\n    onDeviceRemove = this.#onDeviceRemove.event;\n\n    readonly #onListChange = new StickyEventEmitter<\n        readonly AdbDaemonWebUsbDevice[]\n    >();\n    onListChange = this.#onListChange.event;\n\n    current: readonly AdbDaemonWebUsbDevice[] = [];\n\n    constructor(\n        usb: USB,\n        initial: USBDevice[],\n        options: AdbDaemonWebUsbDeviceManager.RequestDeviceOptions = {},\n    ) {\n        this.#filters = mergeDefaultAdbInterfaceFilter(options.filters);\n        this.#exclusionFilters = options.exclusionFilters;\n        this.#usbManager = usb;\n\n        this.current = initial\n            .map((device) => this.#convertDevice(device))\n            .filter((device) => !!device);\n        // Fire `onListChange` to set the sticky value\n        this.#onListChange.fire(this.current);\n\n        this.#usbManager.addEventListener(\"connect\", this.#handleConnect);\n        this.#usbManager.addEventListener(\"disconnect\", this.#handleDisconnect);\n    }\n\n    #convertDevice(device: USBDevice): AdbDaemonWebUsbDevice | undefined {\n        const interface_ = matchFilters(\n            device,\n            this.#filters,\n            this.#exclusionFilters,\n        );\n        if (!interface_) {\n            return undefined;\n        }\n\n        return new AdbDaemonWebUsbDevice(device, interface_, this.#usbManager);\n    }\n\n    #handleConnect = (e: USBConnectionEvent) => {\n        const device = this.#convertDevice(e.device);\n        if (!device) {\n            return;\n        }\n\n        // We send a `connect` event on `requestDevice` success,\n        // but this device might already exist if we already have the permission for it.\n        if (this.current.some((item) => item.raw === device.raw)) {\n            return;\n        }\n\n        const next = this.current.slice();\n        next.push(device);\n        this.current = next;\n\n        this.#onDeviceAdd.fire([device]);\n        this.#onListChange.fire(this.current);\n    };\n\n    #handleDisconnect = (e: USBConnectionEvent) => {\n        const index = this.current.findIndex(\n            (device) => device.raw === e.device,\n        );\n        if (index !== -1) {\n            const device = this.current[index]!;\n\n            const next = this.current.slice();\n            unorderedRemove(next, index);\n            this.current = next;\n\n            this.#onDeviceRemove.fire([device]);\n            this.#onListChange.fire(this.current);\n        }\n    };\n\n    stop(): void {\n        this.#usbManager.removeEventListener(\"connect\", this.#handleConnect);\n        this.#usbManager.removeEventListener(\n            \"disconnect\",\n            this.#handleDisconnect,\n        );\n\n        this.#onDeviceAdd.dispose();\n        this.#onDeviceRemove.dispose();\n        this.#onListChange.dispose();\n    }\n}\n", "import {\n    AdbDaemonWebUsbDevice,\n    mergeDefaultAdbInterfaceFilter,\n} from \"./device.js\";\nimport { AdbDaemonWebUsbDeviceObserver } from \"./observer.js\";\nimport { isErrorName, matchFilters } from \"./utils.js\";\n\nexport namespace AdbDaemonWebUsbDeviceManager {\n    export interface RequestDeviceOptions {\n        filters?: readonly USBDeviceFilter[] | undefined;\n        exclusionFilters?: readonly USBDeviceFilter[] | undefined;\n    }\n}\n\nexport class AdbDaemonWebUsbDeviceManager {\n    /**\n     * Gets the instance of {@link AdbDaemonWebUsbDeviceManager} using browser WebUSB implementation.\n     *\n     * May be `undefined` if current runtime does not support WebUSB.\n     */\n    static readonly BROWSER = /* #__PURE__ */ (() =>\n        typeof globalThis.navigator !== \"undefined\" && globalThis.navigator.usb\n            ? new AdbDaemonWebUsbDeviceManager(globalThis.navigator.usb)\n            : undefined)();\n\n    readonly #usbManager: USB;\n\n    /**\n     * Create a new instance of {@link AdbDaemonWebUsbDeviceManager} using the specified WebUSB implementation.\n     * @param usbManager A WebUSB compatible interface.\n     */\n    constructor(usbManager: USB) {\n        this.#usbManager = usbManager;\n    }\n\n    /**\n     * Call `USB#requestDevice()` to prompt the user to select a device.\n     */\n    async requestDevice(\n        options: AdbDaemonWebUsbDeviceManager.RequestDeviceOptions = {},\n    ): Promise<AdbDaemonWebUsbDevice | undefined> {\n        const filters = mergeDefaultAdbInterfaceFilter(options.filters);\n\n        try {\n            const device = await this.#usbManager.requestDevice({\n                filters,\n                exclusionFilters: options.exclusionFilters as USBDeviceFilter[],\n            });\n\n            const interface_ = matchFilters(\n                device,\n                filters,\n                options.exclusionFilters,\n            );\n            if (!interface_) {\n                // `#usbManager` doesn't support `exclusionFilters`,\n                // selected device is invalid\n                return undefined;\n            }\n\n            // If this `requestDevice` adds a new device,\n            // Chrome won't fire a `connect` event for it.\n            // This will cause device observer to lose track of it,\n            // and when the device disconnects, device observer won't fire the disconnect event for it.\n            this.#usbManager.dispatchEvent(\n                new USBConnectionEvent(\"connect\", { device }),\n            );\n\n            return new AdbDaemonWebUsbDevice(\n                device,\n                interface_,\n                this.#usbManager,\n            );\n        } catch (e) {\n            // No device selected\n            if (isErrorName(e, \"NotFoundError\")) {\n                return undefined;\n            }\n\n            throw e;\n        }\n    }\n\n    /**\n     * Get all connected and requested devices that match the specified filters.\n     */\n    async getDevices(\n        options: AdbDaemonWebUsbDeviceManager.RequestDeviceOptions = {},\n    ): Promise<AdbDaemonWebUsbDevice[]> {\n        const filters = mergeDefaultAdbInterfaceFilter(options.filters);\n\n        const devices = await this.#usbManager.getDevices();\n        // filter map\n        const result: AdbDaemonWebUsbDevice[] = [];\n        for (const device of devices) {\n            const interface_ = matchFilters(\n                device,\n                filters,\n                options.exclusionFilters,\n            );\n            if (interface_) {\n                result.push(\n                    new AdbDaemonWebUsbDevice(\n                        device,\n                        interface_,\n                        this.#usbManager,\n                    ),\n                );\n            }\n        }\n\n        return result;\n    }\n\n    trackDevices(\n        options: AdbDaemonWebUsbDeviceManager.RequestDeviceOptions = {},\n    ): Promise<AdbDaemonWebUsbDeviceObserver> {\n        return AdbDaemonWebUsbDeviceObserver.create(this.#usbManager, options);\n    }\n}\n", "// cspell: ignore RSASSA\n\nimport type { AdbCredentialStore, AdbPrivateKey } from \"@yume-chan/adb\";\n\nfunction openDatabase() {\n    return new Promise<IDBDatabase>((resolve, reject) => {\n        const request = indexedDB.open(\"Tango\", 1);\n        request.onerror = () => {\n            reject(request.error!);\n        };\n        request.onupgradeneeded = () => {\n            const db = request.result;\n            db.createObjectStore(\"Authentication\", { autoIncrement: true });\n        };\n        request.onsuccess = () => {\n            const db = request.result;\n            resolve(db);\n        };\n    });\n}\n\nasync function saveKey(key: Uint8Array): Promise<void> {\n    const db = await openDatabase();\n\n    return new Promise((resolve, reject) => {\n        const transaction = db.transaction(\"Authentication\", \"readwrite\");\n        const store = transaction.objectStore(\"Authentication\");\n        const putRequest = store.add(key);\n        putRequest.onerror = () => {\n            reject(putRequest.error!);\n        };\n        putRequest.onsuccess = () => {\n            resolve();\n        };\n        transaction.onerror = () => {\n            reject(transaction.error!);\n        };\n        transaction.oncomplete = () => {\n            db.close();\n        };\n    });\n}\n\nasync function getAllKeys() {\n    const db = await openDatabase();\n\n    return new Promise<Uint8Array[]>((resolve, reject) => {\n        const transaction = db.transaction(\"Authentication\", \"readonly\");\n        const store = transaction.objectStore(\"Authentication\");\n        const getRequest = store.getAll();\n        getRequest.onerror = () => {\n            reject(getRequest.error!);\n        };\n        getRequest.onsuccess = () => {\n            resolve(getRequest.result as Uint8Array[]);\n        };\n        transaction.onerror = () => {\n            reject(transaction.error!);\n        };\n        transaction.oncomplete = () => {\n            db.close();\n        };\n    });\n}\n\n/**\n * An `AdbCredentialStore` implementation that creates RSA private keys using Web Crypto API\n * and stores them in IndexedDB.\n */\nexport default class AdbWebCredentialStore implements AdbCredentialStore {\n    readonly #appName: string;\n\n    constructor(appName = \"Tango\") {\n        this.#appName = appName;\n    }\n\n    /**\n     * Generates a RSA private key and store it into LocalStorage.\n     *\n     * Calling this method multiple times will overwrite the previous key.\n     *\n     * @returns The private key in PKCS #8 format.\n     */\n    async generateKey(): Promise<AdbPrivateKey> {\n        const { privateKey: cryptoKey } = await crypto.subtle.generateKey(\n            {\n                name: \"RSASSA-PKCS1-v1_5\",\n                modulusLength: 2048,\n                // 65537\n                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n                hash: \"SHA-1\",\n            },\n            true,\n            [\"sign\", \"verify\"],\n        );\n\n        const privateKey = new Uint8Array(\n            await crypto.subtle.exportKey(\"pkcs8\", cryptoKey),\n        );\n        await saveKey(privateKey);\n\n        return {\n            buffer: privateKey,\n            name: `${this.#appName}@${globalThis.location.hostname}`,\n        };\n    }\n\n    /**\n     * Yields the stored RSA private key.\n     *\n     * This method returns a generator, so `for await...of...` loop should be used to read the key.\n     */\n    async *iterateKeys(): AsyncGenerator<AdbPrivateKey, void, void> {\n        for (const key of await getAllKeys()) {\n            yield {\n                buffer: key,\n                name: `${this.#appName}@${globalThis.location.hostname}`,\n            };\n        }\n    }\n}\n", "// Tango ADB Entry Point - \u6574\u5408\u6240\u6709\u9700\u8981\u7684\u6A21\u5757\nimport * as Adb from '@yume-chan/adb';\nimport * as AdbDaemonWebUsb from '@yume-chan/adb-daemon-webusb';\nimport * as AdbCredentialWeb from '@yume-chan/adb-credential-web';\nimport * as StreamExtra from '@yume-chan/stream-extra';\n\n// \u5BFC\u51FA\u6240\u6709\u6A21\u5757\nwindow.TangoADB = {\n  Adb,\n  AdbDaemonWebUsb,\n  AdbCredentialWeb,\n  StreamExtra\n};\n\nconsole.log('Tango ADB loaded:', Object.keys(window.TangoADB));\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA,MAAAA,eAAA;WAAAA,cAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gBAAAC;IAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACEA;AAAM,MAAO,kBAAP,MAAsB;IAUxB,cAAA;AATA;AAGA;AACA;AAEA,iCAA+B;AAUxB,qCAAU,CAAC,UAAmC;AACjD,2BAAK,UAAL,WAAc;AACd,2BAAK,QAAS;MAClB;AAEO,oCAAS,CAAC,WAAsB;AACnC,2BAAK,SAAL,WAAa;AACb,2BAAK,QAAS;MAClB;AAdI,yBAAK,UAAW,IAAI,QAAW,CAAC,SAAS,WAAU;AAC/C,2BAAK,UAAW;AAChB,2BAAK,SAAU;MACnB,CAAC;IACL;IAbA,IAAW,UAAO;AAAiB,aAAO,mBAAK;IAAU;IAMzD,IAAW,QAAK;AAA2B,aAAO,mBAAK;IAAQ;;AAP/D;AAGA;AACA;AAEA;;;ACPE,MAAO,wBAAP,MAA4B;IAK9B,YAAmB,UAAkB,GAAC;AAJ9B;AAEA,8CAAsD,oBAAI,IAAG;AAGjE,WAAK,SAAS;IAClB;IAEO,MAAG;AACN,YAAM,KAAK,KAAK;AAChB,YAAM,WAAW,IAAI,gBAAe;AACpC,WAAK,iBAAiB,IAAI,IAAI,QAAQ;AACtC,aAAO,CAAC,IAAI,SAAS,OAAO;IAChC;IAEQ,YAAY,IAAU;AAC1B,UAAI,CAAC,KAAK,iBAAiB,IAAI,EAAE,GAAG;AAChC,eAAO;MACX;AAEA,YAAM,WAAW,KAAK,iBAAiB,IAAI,EAAE;AAC7C,WAAK,iBAAiB,OAAO,EAAE;AAC/B,aAAO;IACX;IAEO,QAAW,IAAY,QAAS;AACnC,YAAM,WAAW,KAAK,YAAY,EAAE;AACpC,UAAI,aAAa,MAAM;AACnB,iBAAS,QAAQ,MAAM;AACvB,eAAO;MACX;AACA,aAAO;IACX;IAEO,OAAO,IAAY,QAAa;AACnC,YAAM,WAAW,KAAK,YAAY,EAAE;AACpC,UAAI,aAAa,MAAM;AACnB,iBAAS,OAAO,MAAM;AACtB,eAAO;MACX;AACA,aAAO;IACX;;;;AC5CE,WAAU,MAAM,MAAY;AAC9B,WAAO,IAAI,QAAc,aAAU;AAE9B,iBAAmB,WAAW,MAAM,QAAO,GAAI,IAAI;IACxD,CAAC;EACL;;;ACDM,WAAU,cAAiB,OAAc;AAC3C,WAAO,OAAO,UAAU,YAAY,UAAU,QAAQ,UAAU;EACpE;;;ACHA,WAAS,QACL,UACA,MAAa;AAEb,WAAO,MAAM;AACT,YAAM,EAAE,MAAM,MAAK,IAAK,SAAS,KAAK,IAAI;AAC1C,UAAI,MAAM;AACN,eAAO;MACX;AACA,UAAI,cAAc,KAAK,GAAG;AACtB,eAAO,MAAM,KACT,CAACC,WAAU,QAAQ,UAAU,EAAE,UAAUA,OAAK,CAAE,GAChD,CAAC,UAAmB,QAAQ,UAAU,EAAE,MAAK,CAAE,CAAC;MAExD;AACA,aAAO;IACX;EACJ;;AASM,WAAU,QACZ,IACA,UAAe;AAEf,aAAS,UAAsB,MAAO;AAClC,YAAM,WAAW,GAAG,KAChB,MACA,WACI,OAA0B;AAM1B,YAAI,cAAc,KAAK,GAAG;AACtB,gBAAMC,UAAS,MAAM;AACrB,cAAI,cAAcA,SAAQ;AACtB,mBAAOA,QAAO;UAClB,OAAO;AACH,kBAAMA,QAAO;UACjB;QACJ;AAEA,eAAO;MACX,GACA,GAAG,IAAI;AAEX,aAAO,QAAQ,UAAU,MAAS;IACtC;AAEA,QAAI,UAAU;AACV,aAAO,OAAO,KAAK,QAAQ;IAC/B,OAAO;AACH,aAAO;IACX;EACJ;;;ACpDM,WAAU,uBACZ,YAAqC;AAErC,WAAO,CACH,QACA,YACO;AACP,UAAI,YAAY,SAAS;AACrB,cAAMC,UAAS,WAAW,QAAQ,OAAO;AACzC,gBAAQ,OAAO,IAAIA,SAAQ,QAAQ,KAAK;AACxC,eAAOA,QAAO;MAClB,OAAO;AACH,eAAO,WAAW,QAAQ,OAAO;MACrC;IACJ;EACJ;AAQM,WAAU,oBACZ,MACA,YAAkC;AAElC,WAAO,CACH,QACA,YACO;AACP,UAAI,YAAY,SAAS;AACrB,gBAAQ,UAAR,QAAQ,QAAU;AAClB,mBAAW,QAAQ,OAAgB;AACnC,eAAO;MACX,OAAO;AACH,cAAMA,UAAS,IAAI,WAAW,IAAI;AAClC,mBAAW,QAAQ;UACf,QAAAA;UACA,OAAO;UACP,cAAc,QAAQ;SACzB;AACD,eAAOA;MACX;IACJ;EACJ;;;;ACtBA,WAAS,OACL,MACA,MACA,WACA,aACA,SAA2C;AAE3C,UAAMC,SAAoC;MACtC;MACA;MACA,WACI,SAAS,YACH,uBACI,SAAwC,IAE5C,oBACI,MACA,SAAqC;MAEnD,aAAa,QAAQ,WAAW;MAChC,UAAU,SAAS;;AAEvB,QAAI,SAAS,MAAM;AACf,MAAAA,OAAM,OAAO,QAAQ;IACzB;AACA,WAAOA;EACX;AAEO,MAAM,QAAQ;;;ACxDd,MAAM,kBAAkB,IAAI,WAAW,CAAC;AAE/C,WAAS,yBACL,MACA,QACA,OACA,QAAc;AAEd,QAAI,OAAO,SAAS,QAAQ;AACxB,WAAK,IAAI,QAAQ,KAAK;AAEtB,WAAK,KAAK,GAAG,QAAQ,OAAO,QAAQ,QAAQ,MAAM;IACtD,WAAW,OAAO,WAAW,QAAQ;AACjC,WAAK,IAAI,QAAQ,KAAK;IAC1B,OAAO;AACH,WAAK,IAAI,OAAO,SAAS,GAAG,MAAM,GAAG,KAAK;IAC9C;EACJ;;AAqGM,WAAU,OACZ,eAKA,WAA0C;AAG1C,QAAI,OAAO,kBAAkB,UAAU;AACnC,UAAI;AACJ,UAAIC;AAIJ,UAAIC;AAEJ,UAAI,kBAAkB,GAAG;AACrB,oBAAY,MAAK;QAAE;AAEnB,YAAI,WAAW;AAEX,UAAAD,eAAc,aAAS;AACnB,mBAAO,UAAU,QAAQ,eAAe;UAC5C;QACJ,OAAO;AAEH,UAAAA,eAAc,aAAS;AACnB,mBAAO;UACX;QACJ;MACJ,OAAO;AACH,oBAAY,CAAC,OAAO,EAAE,QAAAE,SAAQ,MAAK,MAC/B,yBAAyBA,SAAQ,OAAO,OAAO,aAAa;AAEhE,YAAI,WAAW;AACX,UAAAF,eAAc,WAAW,MAAM,QAAM;AACjC,kBAAM,QAAQ,OAAO,YAAY,aAAa;AAC9C,mBAAO,UAAU,QAAQ,OAAO,KAAK,KAAK,CAAC;UAC/C;AACA,UAAAC,QAAO,CAAC,UAAU,UAAU,KAAK,KAAK;QAC1C,OAAO;AAEH,UAAAD,eAAc,WAAW,OAAO,QAAM;AAClC,kBAAM,QAAQ,OAAO,YAAY,aAAa;AAC9C,mBAAO;UACX;QACJ;MACJ;AAEA,aAAO,MAAM,eAAe,QAAQ,WAAWA,cAAa,EAAE,MAAAC,MAAI,CAAE;IACxE;AAIA,SACK,OAAO,kBAAkB,YACtB,OAAO,kBAAkB,eAC7B,eAAe,eACjB;AACE,UAAID;AAIJ,UAAIC;AAEJ,UAAI,WAAW;AACX,QAAAD,eAAc,WAAW,MAAM,QAAQ,SAAO;AAC1C,gBAAM,SAAS,OAAO,KAClB,cAAc,YAAY,QAAQ,OAAO,CAAC;AAE9C,gBAAM,QACF,WAAW,IAAI,OAAO,YAAY,MAAM,IAAI;AAChD,iBAAO,UAAU,QAAQ,OAAO,KAAK,KAAK,CAAC;QAC/C;AACA,QAAAC,QAAO,CAAC,UAAU,UAAU,KAAK,KAAK;MAC1C,OAAO;AACH,QAAAD,eAAc,WAAW,MAAM,QAAQ,SAAO;AAC1C,gBAAM,SAAS,OAAO,KAClB,cAAc,YAAY,QAAQ,OAAO,CAAC;AAE9C,gBAAM,QACF,WAAW,IAAI,OAAO,YAAY,MAAM,IAAI;AAChD,iBAAO;QACX;MACJ;AAEA,aAAO,MACH,cAAc,MACd,WACA,CAAC,OAAO,EAAE,aAAY,MAAM;AACxB,YAAI,cAAc,SAAS,WAAW;AAClC,gBAAM,eAAe,cAAc,UAAU,MAAM,QAAQ;YACvD;WACH;AAED,cAAI,MAAM,WAAW,GAAG;AACpB,mBAAO;UACX;AAEA,gBAAM,SAAS,IAAI,WACf,aAAa,SAAS,MAAM,MAAM;AAEtC,iBAAO,IAAI,cAAc,CAAC;AAC1B,iBAAO,IAAI,OAAO,aAAa,MAAM;AACrC,iBAAO;QACX,OAAO;AACH,gBAAM,SAAS,IAAI,WACf,cAAc,OAAO,MAAM,MAAM;AAErC,wBAAc,UAAU,MAAM,QAAQ;YAClC,QAAQ;YACR,OAAO;YACP;WACH;AACD,iBAAO,IAAI,OAAO,cAAc,IAAI;AACpC,iBAAO;QACX;MACJ,GACAA,cACA,EAAE,MAAAC,MAAI,CAAE;IAEhB;AAGA,QAAI,OAAO,kBAAkB,UAAU;AACnC,UAAID;AAIJ,UAAIC;AAKJ,UAAI,WAAW;AACX,QAAAD,eAAc,WAAW,MAAM,QAAQ,EAAE,aAAY,GAAE;AACnD,gBAAM,SAAS,aAAa,aAAa;AACzC,gBAAM,QACF,WAAW,IAAI,OAAO,YAAY,MAAM,IAAI;AAChD,iBAAO,UAAU,QAAQ,OAAO,KAAK,KAAK,CAAC;QAC/C;AACA,QAAAC,QAAO,CAAC,OAAO,iBAAgB;AAC3B,gBAAM,QAAQ,UAAU,KAAK,KAAK;AAClC,uBAAa,aAAa,IAAI,MAAM;AACpC,iBAAO;QACX;MACJ,OAAO;AAEH,QAAAD,eAAc,WAAW,OAAO,QAAQ,EAAE,aAAY,GAAE;AACpD,gBAAM,SAAS,aAAa,aAAa;AACzC,gBAAM,QACF,WAAW,IAAI,OAAO,YAAY,MAAM,IAAI;AAChD,iBAAO;QACX;AACA,QAAAC,QAAO,CAAC,OAAO,iBAAgB;AAC3B,gBAAM,QAAQ;AACd,uBAAa,aAAa,IAAI,MAAM;AACpC,iBAAO;QACX;MACJ;AAEA,aAAO,MAAM,GAAG,WAAW,CAAC,WAAW,QAAQD,cAAa,EAAE,MAAAC,MAAI,CAAE;IACxE;AAEA,QAAI;AACJ,QAAI;AAMJ,QAAI,WAAW;AACX,oBAAc,WAAW,MAAM,QAAQ,EAAE,aAAY,GAAE;AACnD,cAAM,YAAY,aAAa,cAAc,KAAK;AAClD,cAAM,SAAS,cAAc,QAAQ,SAAS;AAC9C,cAAM,QACF,WAAW,IAAI,OAAO,YAAY,MAAM,IAAI;AAChD,eAAO,UAAU,QAAQ,OAAO,KAAK,KAAK,CAAC;MAC/C;AACA,aAAO,CAAC,OAAO,iBAAgB;AAC3B,cAAM,QAAQ,UAAU,KAAK,KAAK;AAClC,qBAAa,cAAc,KAAK,IAAI,cAAc,KAC9C,MAAM,MAAM;AAEhB,eAAO;MACX;IACJ,OAAO;AAEH,oBAAc,WAAW,OAAO,QAAQ,EAAE,aAAY,GAAE;AACpD,cAAM,YAAY,aAAa,cAAc,KAAK;AAClD,cAAM,SAAS,cAAc,QAAQ,SAAS;AAC9C,cAAM,QACF,WAAW,IAAI,OAAO,YAAY,MAAM,IAAI;AAChD,eAAO;MACX;AACA,aAAO,CAAC,OAAO,iBAAgB;AAC3B,cAAM,QAAQ;AACd,qBAAa,cAAc,KAAK,IAAI,cAAc,KAC9C,MAAM,MAAM;AAEhB,eAAO;MACX;IACJ;AAEA,WAAO,MAAM,GAAG,WAAW,CAAC,WAAW,QAAQ,aAAa,EAAE,KAAI,CAAE;EACxE;;;ACvUM,MAAO,0BAAP,cAAuC,MAAK;IAC9C,cAAA;AACI,YAAM,qBAAqB;IAC/B;;AAPJ;AAsBM,MAAO,0BAAP,MAA8B;IAQhC,YAAY,MAAgB;AAP5B;AACA;AAOI,yBAAK,OAAQ;AACb,yBAAK,WAAY;IACrB;IAPA,IAAI,WAAQ;AACR,aAAO,mBAAK;IAChB;IAOA,YAAY,QAAc;AACtB,UAAI,mBAAK,aAAY,SAAS,mBAAK,OAAM,QAAQ;AAC7C,cAAM,IAAI,wBAAuB;MACrC;AAEA,YAAM,SAAS,mBAAK,OAAM,SACtB,mBAAK,YACL,mBAAK,aAAY,MAAM;AAG3B,yBAAK,WAAL,mBAAK,aAAa;AAClB,aAAO;IACX;;AAxBA;AACA;;;ACqBE,MAAO,yBAAP,cAAsC,MAAK;IAC7C,YAAY,SAAe;AACvB,YAAM,OAAO;IACjB;;AAGE,MAAO,2BAAP,cAAwC,uBAAsB;IAChE,cAAA;AACI,YACI,4EAA4E;IAEpF;;AAGE,MAAO,mBAAP,cAAgC,uBAAsB;IACxD,cAAA;AACI,YAAM,yDAAyD;IACnE;;;AAmBE,WAAU,OASZ,QACA,SASC;AAED,UAAM,YAAY,OAAO,QAAQ,MAAM;AAEvC,QAAI,OAAO;AACX,QAAI,OAAO;AACX,eAAW,CAAC,EAAEE,MAAK,KAAK,WAAW;AAC/B,cAAQA,OAAM;AACd,UAAI,QAAQA,OAAM,SAAS,QAAQ;AAC/B,eAAO;MACX;IACJ;AAEA,UAAM,eAAe,QAAQ;AAC7B,UAAM,QAAQ,QAAQ,QAChB,OAAO,0BAA0B,QAAQ,KAAK,IAC9C;AAEN,WAAO;MACH;MACA;MACA,OAAO,QAAQ;MAEf,MAAM,OAAO,SAAS;MACtB;MACA,UACI,QACA,iBAAqD;AAErD,cAAM,OAAgC,EAAE,GAAG,OAAM;AAEjD,mBAAW,CAAC,KAAKA,MAAK,KAAK,WAAW;AAClC,cAAI,OAAO,QAAQ,UAAUA,QAAO;AAChC,kBAAM,SAASA,OAAM,OAAO,KAAK,GAAG,GAAG,IAAa;AACpD,iBAAK,GAAG,IAAI;UAChB;QACJ;AAEA,cAAM,QAAQ,IAAI,MAAc,UAAU,MAAM;AAChD,cAAM,UAAU,IAAI,MAA8B,UAAU,MAAM;AAClE;AACI,gBAAMC,WAAwC,EAAE,aAAY;AAC5D,qBAAW,CAACC,QAAO,CAAC,KAAKF,MAAK,CAAC,KAAK,UAAU,QAAO,GAAI;AACrD,gBAAIA,OAAM,SAAS,QAAQ;AACvB,oBAAME,MAAK,IAAIF,OAAM;YACzB,OAAO;AACH,sBAAQE,MAAK,IAAIF,OAAM,UAAU,KAAK,GAAG,GAAGC,QAAO;AACnD,oBAAMC,MAAK,IAAI,QAAQA,MAAK,EAAE;YAClC;UACJ;QACJ;AAEA,cAAMC,QAAO,MAAM,OAAO,CAAC,KAAKA,UAAS,MAAMA,OAAM,CAAC;AAEtD,YAAI;AACJ,YAAIC;AACJ,YAAI;AACJ,YAAI,2BAA2B,YAAY;AACvC,cAAI,gBAAgB,SAASD,OAAM;AAC/B,kBAAM,IAAI,MAAM,kBAAkB;UACtC;AACA,2BAAiB;AACjB,UAAAC,UAAS;AACT,kBAAQ;QACZ,WACI,OAAO,oBAAoB,YAC3B,YAAY,iBACd;AACE,2BAAiB;AACjB,UAAAA,UAAS,gBAAgB;AACzB,kBAAQ,gBAAgB,SAAS;AACjC,cAAIA,QAAO,SAAS,QAAQD,OAAM;AAC9B,kBAAM,IAAI,MAAM,kBAAkB;UACtC;QACJ,OAAO;AACH,2BAAiB;AACjB,UAAAC,UAAS,IAAI,WAAWD,KAAI;AAC5B,kBAAQ;QACZ;AAEA,cAAM,UAAU;UACZ,QAAAC;UACA;UACA;;AAEJ,mBAAW,CAACF,QAAO,CAAC,KAAKF,MAAK,CAAC,KAAK,UAAU,QAAO,GAAI;AACrD,cAAI,QAAQE,MAAK,GAAG;AAChB,YAAAE,QAAO,IAAI,QAAQF,MAAK,GAAG,QAAQ,KAAK;UAC5C,OAAO;AACH,YAAAF,OAAM,UAAU,KAAK,GAAG,GAAG,OAAO;UACtC;AACA,kBAAQ,SAAS,MAAME,MAAK;QAChC;AAEA,YAAI,gBAAgB;AAChB,iBAAOC;QACX,OAAO;AACH,iBAAOC;QACX;MACJ;MACA,aAAa,QAAQ,WAEjB,MACA,QAA0B;AAE1B,cAAM,gBAAgB,OAAO;AAE7B,cAAM,SAAS,CAAA;AACf,cAAM,UAEF;UACA,cAAc;UACd;;AAGJ,YAAI;AACA,qBAAW,CAAC,KAAKJ,MAAK,KAAK,WAAW;AAClC,mBAAO,GAAG,IAAI,OAAO,KACjBA,OAAM,YAAY,QAAQ,OAAO,CAAC;UAE1C;QACJ,SAAS,GAAG;AACR,cAAI,EAAE,aAAa,0BAA0B;AACzC,kBAAM;UACV;AAEA,cAAI,OAAO,aAAa,eAAe;AACnC,kBAAM,IAAI,iBAAgB;UAC9B,OAAO;AACH,kBAAM,IAAI,yBAAwB;UACtC;QACJ;AAEA,YAAI,OAAO;AACP,iBAAO,iBAAiB,QAAQ,KAAK;QACzC;AAEA,YAAI,QAAQ,iBAAiB;AACzB,iBAAO,QAAQ,gBAAgB,KAC3B,QACA,MAAe;QAEvB,OAAO;AACH,iBAAO;QACX;MACJ,CAAC;;EAET;;;;AC9OM,WAAU,OAUZ,MACA,QACA,SAQC;AAED,WAAO,OAAO,OAAO,OAAO,CAAA,GAAI,KAAK,QAAQ,MAAM,GAAG;MAClD,cAAc,SAAS,gBAAgB,KAAK;MAC5C,OAAO,KAAK;MACZ,iBAAiB,SAAS;KAC7B;EACL;;;;ACZM,WAAU,SACZK,SACA,QACA,cAAqB;AAErB,WAAO,eACDA,QAAO,MAAM,IACRA,QAAO,SAAS,CAAC,KAAM,IACvBA,QAAO,SAAS,CAAC,KAAM,KACvBA,QAAO,SAAS,CAAC,KAAM,KAC3BA,QAAO,MAAM,KAAM,KACfA,QAAO,SAAS,CAAC,KAAM,KACvBA,QAAO,SAAS,CAAC,KAAM,IACxBA,QAAO,SAAS,CAAC;EAC/B;AAwBM,WAAU,SACZC,SACA,QACA,OACA,cAAqB;AAErB,QAAI,cAAc;AACd,MAAAA,QAAO,MAAM,IAAI;AACjB,MAAAA,QAAO,SAAS,CAAC,IAAI,SAAS;AAC9B,MAAAA,QAAO,SAAS,CAAC,IAAI,SAAS;AAC9B,MAAAA,QAAO,SAAS,CAAC,IAAI,SAAS;IAClC,OAAO;AACH,MAAAA,QAAO,MAAM,IAAI,SAAS;AAC1B,MAAAA,QAAO,SAAS,CAAC,IAAI,SAAS;AAC9B,MAAAA,QAAO,SAAS,CAAC,IAAI,SAAS;AAC9B,MAAAA,QAAO,SAAS,CAAC,IAAI;IACzB;EACJ;;;ACvBM,WAAU,qBACZC,SACA,QACA,OAAa;AAEb,IAAAA,QAAO,MAAM,IAAI,OAAO,QAAQ,KAAK;AACrC,IAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,KAAM,KAAK;AACjD,IAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,MAAO,KAAK;AAClD,IAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,MAAO,KAAK;AAClD,IAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,MAAO,KAAK;AAClD,IAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,MAAO,KAAK;AAClD,IAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,MAAO,KAAK;AAClD,IAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,MAAO,KAAK;EACtD;AAEM,WAAU,kBACZA,SACA,QACA,OAAa;AAEb,IAAAA,QAAO,MAAM,IAAI,OAAQ,SAAS,MAAO,KAAK;AAC9C,IAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,MAAO,KAAK;AAClD,IAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,MAAO,KAAK;AAClD,IAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,MAAO,KAAK;AAClD,IAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,MAAO,KAAK;AAClD,IAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,MAAO,KAAK;AAClD,IAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,KAAM,KAAK;AACjD,IAAAA,QAAO,SAAS,CAAC,IAAI,OAAO,QAAQ,KAAK;EAC7C;;;;ACnFM,WAAU,sBACZC,SACA,QAAc;AAEd,YACKA,QAAO,MAAM,IACTA,QAAO,SAAS,CAAC,KAAM,IACvBA,QAAO,SAAS,CAAC,KAAM,KACvBA,QAAO,SAAS,CAAC,KAAM,QAC5B;EAER;;AAcM,WAAU,UACZC,SACA,QACA,cAAqB;AAErB,WAAO,gBACAA,QAAO,MAAM,IACTA,QAAO,SAAS,CAAC,KAAM,IACvBA,QAAO,SAAS,CAAC,KAAM,KACvBA,QAAO,SAAS,CAAC,KAAM,QACxB,KACFA,QAAO,MAAM,KAAM,KAChBA,QAAO,SAAS,CAAC,KAAM,KACvBA,QAAO,SAAS,CAAC,KAAM,IACxBA,QAAO,SAAS,CAAC,OACjB;EACd;AAEM,WAAU,sBACZA,SACA,QACA,OAAa;AAEb,IAAAA,QAAO,MAAM,IAAI;AACjB,IAAAA,QAAO,SAAS,CAAC,IAAI,SAAS;AAC9B,IAAAA,QAAO,SAAS,CAAC,IAAI,SAAS;AAC9B,IAAAA,QAAO,SAAS,CAAC,IAAI,SAAS;EAClC;AAaM,WAAU,UACZC,SACA,QACA,OACA,cAAqB;AAErB,QAAI,cAAc;AACd,MAAAA,QAAO,MAAM,IAAI;AACjB,MAAAA,QAAO,SAAS,CAAC,IAAI,SAAS;AAC9B,MAAAA,QAAO,SAAS,CAAC,IAAI,SAAS;AAC9B,MAAAA,QAAO,SAAS,CAAC,IAAI,SAAS;IAClC,OAAO;AACH,MAAAA,QAAO,MAAM,IAAI,SAAS;AAC1B,MAAAA,QAAO,SAAS,CAAC,IAAI,SAAS;AAC9B,MAAAA,QAAO,SAAS,CAAC,IAAI,SAAS;AAC9B,MAAAA,QAAO,SAAS,CAAC,IAAI;IACzB;EACJ;;;ACnFM,WAAU,sBACZC,SACA,QAAc;AAEd,WACI,OAAOA,QAAO,MAAM,CAAE,IACrB,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,KAC/B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,MAC/B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,MAC/B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,MAC/B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,MAC/B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,MAC/B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK;EAExC;AAEM,WAAU,mBAAmBA,SAAoB,QAAc;AACjE,WACK,OAAOA,QAAO,MAAM,CAAE,KAAK,MAC3B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,MAC/B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,MAC/B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,MAC/B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,MAC/B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,MAC/B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,KAChC,OAAOA,QAAO,SAAS,CAAC,CAAE;EAElC;AAEM,WAAU,UACZA,SACA,QACA,cAAqB;AAErB,WAAO,eACD,OAAOA,QAAO,MAAM,CAAE,IACjB,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,KAC/B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,MAC/B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,MAC/B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,MAC/B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,MAC/B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,MAC/B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,MACnC,OAAOA,QAAO,MAAM,CAAE,KAAK,MACvB,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,MAC/B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,MAC/B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,MAC/B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,MAC/B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,MAC/B,OAAOA,QAAO,SAAS,CAAC,CAAE,KAAK,KAChC,OAAOA,QAAO,SAAS,CAAC,CAAE;EACxC;AAgCM,WAAU,UACZC,SACA,QACA,OACA,cAAqB;AAErB,QAAI,cAAc;AACd,MAAAA,QAAO,MAAM,IAAI,OAAO,QAAQ,KAAK;AACrC,MAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,KAAM,KAAK;AACjD,MAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,MAAO,KAAK;AAClD,MAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,MAAO,KAAK;AAClD,MAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,MAAO,KAAK;AAClD,MAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,MAAO,KAAK;AAClD,MAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,MAAO,KAAK;AAClD,MAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,MAAO,KAAK;IACtD,OAAO;AACH,MAAAA,QAAO,MAAM,IAAI,OAAQ,SAAS,MAAO,KAAK;AAC9C,MAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,MAAO,KAAK;AAClD,MAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,MAAO,KAAK;AAClD,MAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,MAAO,KAAK;AAClD,MAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,MAAO,KAAK;AAClD,MAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,MAAO,KAAK;AAClD,MAAAA,QAAO,SAAS,CAAC,IAAI,OAAQ,SAAS,KAAM,KAAK;AACjD,MAAAA,QAAO,SAAS,CAAC,IAAI,OAAO,QAAQ,KAAK;IAC7C;EACJ;;;;AC9EA,WAAS,OACL,MACA,WAIA,aAImC;AAEnC,UAAM,MAAsB,MAAM;AAClC,WAAO,OAAO,IAAI,MAAM,MAAM,QAAQ,WAAW,WAAW,CAAC;AAC7D,WAAO;EACX;AAEO,MAAM,KAA0B,uBACnC,GACA,CAAC,OAAO,EAAE,QAAAC,SAAQ,MAAK,MAAM;AACzB,IAAAA,QAAO,KAAK,IAAI;EACpB,GACA,WAAW,MAAM,QAAM;AACnB,UAAM,OAAO,OAAO,KAAK,OAAO,YAAY,CAAC,CAAC;AAC9C,WAAO,KAAK,CAAC;EACjB,CAAC;AAoCE,MAAM,MAA2B,uBACpC,GACA,CAAC,OAAO,EAAE,QAAAC,SAAQ,OAAO,aAAY,MAAM;AACvC,cAAUA,SAAQ,OAAO,OAAO,YAAY;EAChD,GACA,WAAW,MAAM,QAAQ,EAAE,aAAY,GAAE;AACrC,UAAM,OAAO,OAAO,KAAK,OAAO,YAAY,CAAC,CAAC;AAC9C,WAAO,UAAU,MAAM,GAAG,YAAY;EAC1C,CAAC;AAGE,MAAM,MAA2B,uBACpC,GACA,CAAC,OAAO,EAAE,QAAAA,SAAQ,OAAO,aAAY,MAAM;AACvC,aAASA,SAAQ,OAAO,OAAO,YAAY;EAC/C,GACA,WAAW,MAAM,QAAQ,EAAE,aAAY,GAAE;AACrC,UAAM,OAAO,OAAO,KAAK,OAAO,YAAY,CAAC,CAAC;AAC9C,WAAO,SAAS,MAAM,GAAG,YAAY;EACzC,CAAC;AAGE,MAAM,MAA2B,uBACpC,GACA,CAAC,OAAO,EAAE,QAAAA,SAAQ,OAAO,aAAY,MAAM;AACvC,cAAUA,SAAQ,OAAO,OAAO,YAAY;EAChD,GACA,WAAW,MAAM,QAAQ,EAAE,aAAY,GAAE;AACrC,UAAM,OAAO,OAAO,KAAK,OAAO,YAAY,CAAC,CAAC;AAC9C,WAAO,UAAU,MAAM,GAAG,YAAY;EAC1C,CAAC;;;ACjGE,MAAM,EAAE,aAAa,YAAW,IACnC;AAEJ,MAAM,gBAAgC,oBAAI,YAAW;AACrD,MAAM,gBAAgC,oBAAI,YAAW;;AAG/C,WAAU,WAAW,OAAa;AACpC,WAAO,cAAc,OAAO,KAAK;EACrC;;AAGM,WAAU,WAAWC,SAAqC;AAG5D,WAAO,cAAc,OAAOA,OAAM;EACtC;;;ACXO,MAAM,qCAA6C,CACtD,kBAGA;AACA,UAAMC,SAAQ,OAAO,eAAwB;MACzC,SAAS;MACT,MAAM;KACT;AACA,IAAAA,OAAmC,KAAK,MAAMA;AAC/C,WAAOA;EACX;;;ACJO,MAAM,EAAE,gBAAe,IAAK;AAMnC,MAAM,iBAAkC,uBAAK;AACzC,UAAM,EAAE,gBAAAC,gBAAc,IAAK;AAE3B,QAAI,CAACA,gBAAe,MAAM;AACtB,MAAAA,gBAAe,OAAO,SAAU,UAAQ;AACpC,cAAM,WACF,OAAO,iBAAiB,WAClB,SAAS,OAAO,aAAa,EAAC,IAC9B,SAAS,OAAO,QAAQ,EAAC;AAEnC,eAAO,IAAIA,gBAAe;UACtB,MAAM,KAAK,YAAU;AACjB,kBAAM,SAAS,MAAM,SAAS,KAAI;AAClC,gBAAI,OAAO,MAAM;AACb,yBAAW,MAAK;AAChB;YACJ;AACA,uBAAW,QAAQ,OAAO,KAAK;UACnC;UACA,MAAM,OAAO,QAAM;AACf,kBAAM,SAAS,SAAS,MAAM;UAClC;SACH;MACL;IACJ;AAEA,QACI,CAACA,gBAAe,UAAU,OAAO,aAAa,KAC9C,CAACA,gBAAe,UAAU,QAC5B;AACE,MAAAA,gBAAe,UAAU,SAAS,iBAE9B,SAAuC;AAEvC,cAAM,SAAS,KAAK,UAAS;AAC7B,YAAI;AACA,iBAAO,MAAM;AACT,kBAAM,EAAE,MAAM,MAAK,IAAK,MAAM,OAAO,KAAI;AACzC,gBAAI,MAAM;AACN;YACJ;AACA,kBAAM;UACV;QACJ;AAII,cAAI,CAAC,SAAS,eAAe;AACzB,kBAAM,OAAO,OAAM;UACvB;AACA,iBAAO,YAAW;QACtB;MACJ;AAEA,MAAAA,gBAAe,UAAU,OAAO,aAAa;MAEzCA,gBAAe,UAAU;IACjC;AAEA,WAAOA;EACX,GAAE;AAEK,MAAM,EAAE,gBAAgB,gBAAe,IAC1C;;;ACjEE,MAAO,qBAAP,cAAqC,eAAiB;;;;;;;;IAQxD,YACI,QACA,UACA,QAA8B;AAE9B,UAAI;AACJ,UAAI,gCAAgC;AACpC,YAAM,kBAAkB,IAAI,gBAAe;AAE3C,YACI;QACI,OAAO,CAAC,eAAc;AAClB,gBAAM,SAAS,OAAO;YAClB,aAAa,gBAAgB;YAC7B,SAAS,OAAO,UAAS;AACrB,uBAAS;gBACL,QAAQ;gBACR,WAAW;gBACX,OAAO;gBACP,OAAO;eACV;AAED,kBAAI,gBAAgB,OAAO,SAAS;AAkBhC,yBAAS;kBACL,QAAQ;kBACR,WAAW;kBACX,OAAO;kBACP,OAAO;iBACV;AACD;cACJ;AAEA,kBAAI,WAAW,gBAAgB,MAAM;AAGjC,2BAAW,QAAQ,KAAK;AAExB;cACJ;AAEA,kBAAI,+BAA+B;AAe/B,gDAAgC;AAChC,2BAAW,QAAQ,KAAK;AACxB,yBAAS;kBACL,QAAQ;kBACR,WAAW;kBACX,OAAO;kBACP,OAAO;iBACV;AACD;cACJ;AAEA,kBAAI,WAAW,eAAe,GAAG;AAC7B,yBAAS;kBACL,QAAQ;kBACR,WAAW;kBACX,OAAO;kBACP,OAAO;iBACV;AAED,+BAAe,IAAI,gBAAe;AAClC,sBAAM,aAAa;AAGnB,oBAAI,gBAAgB,OAAO,SAAS;AAChC,2BAAS;oBACL,QAAQ;oBACR,WAAW;oBACX,OAAO;oBACP,OAAO;mBACV;AACD;gBACJ;cACJ;AAEA,yBAAW,QAAQ,KAAK;AACxB,uBAAS;gBACL,QAAQ;gBACR,WAAW;gBACX,OAAO;gBACP,OAAO;eACV;YACL;YACA,QAAK;AACD,uBAAS;gBACL,QAAQ;gBACR,WAAW;gBACX,UAAU;gBACV,OAAO;eACV;AAID,kBAAI,gBAAgB,OAAO,SAAS;AAChC,yBAAS;kBACL,QAAQ;kBACR,WAAW;kBACX,UAAU;kBACV,OAAO;iBACV;AACD;cACJ;AAEA,yBAAW,MAAK;AAChB,uBAAS;gBACL,QAAQ;gBACR,WAAW;gBACX,UAAU;gBACV,OAAO;eACV;YACL;YACA,MAAM,GAAC;AACH,uBAAS;gBACL,QAAQ;gBACR,WAAW;gBACX,UAAU;gBACV,OAAO;eACV;AAGD,yBAAW,MAAM,CAAC;AAElB,uBAAS;gBACL,QAAQ;gBACR,WAAW;gBACX,UAAU;gBACV,OAAO;eACV;YACL;WACH;AAED,cAAI,UAAU,UAAU,QAAQ;AAM5B,mBAAO,KACH,MAAK;AACD,uBAAS;gBACL,QAAQ;gBACR,WAAW;gBACX,UAAU;gBACV,OAAO;eACV;AAED,kBAAI;AACA,2BAAW,MAAK;AAEhB,yBAAS;kBACL,QAAQ;kBACR,WAAW;kBACX,UAAU;kBACV,OAAO;iBACV;cACL,QAAQ;AACJ,yBAAS;kBACL,QAAQ;kBACR,WAAW;kBACX,UAAU;kBACV,OAAO;iBACV;cAIL;YACJ,GACA,CAAC,MAAK;AACF,uBAAS;gBACL,QAAQ;gBACR,WAAW;gBACX,UAAU;gBACV,OAAO;eACV;AAED,yBAAW,MAAM,CAAC;AAElB,uBAAS;gBACL,QAAQ;gBACR,WAAW;gBACX,UAAU;gBACV,OAAO;eACV;YACL,CAAC;UAET;QACJ;QACA,MAAM,MAAK;AACP,mBAAS;YACL,QAAQ;YACR,WAAW;YACX,OAAO;WACV;AAED,cAAI,cAAc;AACd,yBAAa,QAAO;UACxB,WAAW,UAAU,kBAAkB,GAAG;AACtC,4CAAgC;UACpC;AAEA,mBAAS;YACL,QAAQ;YACR,WAAW;YACX,OAAO;WACV;QACL;QACA,QAAQ,CAAC,WAAU;AACf,mBAAS;YACL,QAAQ;YACR,WAAW;YACX,OAAO;WACV;AAED,0BAAgB,MAAM,MAAM;AAE5B,wBAAc,QAAO;AAErB,mBAAS;YACL,QAAQ;YACR,WAAW;YACX,OAAO;WACV;QACL;SAEJ,QAAQ;IAEhB;;;;ACjSE,WAAU,SAAS,YAA6B;AAClD,QAAI;AACA,iBAAW,MAAK;AAChB,aAAO;IACX,QAAQ;AACJ,aAAO;IACX;EACJ;AAWA,iBAAsB,UAAU,QAE/B;AACG,QAAI;AACA,YAAM,OAAO,OAAM;AACnB,aAAO;IACX,QAAQ;AACJ,aAAO;IACX;EACJ;;;ACzCA,mDAAAC,YAAA;AAMM,MAAO,yBAAP,MAA6B;IAe/B,YAAY,QAAkC;AAf5C;AACF;AAGA;;0CAAkB;AAClB,0CAAkB;AAElB,yBAAAA,YAAY;AAKO;AACA;AA8FnB,yCAAc,QAAQ,WAElB,MACA,QAAc;AAEd,YAAI;AACJ,YAAI,QAAQ;AAEZ,cAAM,UAAU,sBAAK,oDAAL,WAAmB;AACnC,YAAI,SAAS;AACT,cAAI,QAAQ,WAAW,QAAQ;AAC3B,mBAAO;UACX;AAEA,mBAAS,IAAI,WAAW,MAAM;AAC9B,iBAAO,IAAI,SAAS,KAAK;AACzB,mBAAS,QAAQ;AACjB,oBAAU,QAAQ;QACtB,OAAO;AACH,mBAAS,IAAI,WAAW,MAAM;QAClC;AAEA,eAAO,SAAS,GAAG;AACf,gBAAM,QAAQ,OAAO,KAAK,sBAAK,kDAAL,WAAiB,OAAO;AAClD,iBAAO,IAAI,OAAO,KAAK;AACvB,mBAAS,MAAM;AACf,oBAAU,MAAM;QACpB;AAEA,eAAO;MACX,CAAC;AAzHG,WAAK,SAAS;AACd,WAAK,SAAS,OAAO,UAAS;IAClC;IAVA,IAAI,WAAQ;AACR,aAAO,mBAAKA;IAChB;IAqDA,eACI,QAAc;AAEd,UAAI,QAAQ,mBAAK,aAAY,IAAI;AACjC,aAAO;QACH,MAAM,MAAK;AACP,kBAAQ,OAAO;YACX,KAAK,GAAG;AACJ,oBAAM,QAAQ,sBAAK,oDAAL,WAAmB;AACjC,kBAAI,MAAM,WAAW,QAAQ;AACzB,wBAAQ;cACZ,OAAO;AACH,0BAAU,MAAM;AAChB,wBAAQ;cACZ;AACA,qBAAO,EAAE,MAAM,OAAO,MAAK;YAC/B;YACA,KAAK;AACD,sBAAQ;AACR,qBAAO;gBACH,MAAM;gBACN,OAAO,sBAAK,kDAAL,WAAiB,QAAQ,KAAK,CAAC,UAAS;AAC3C,sBAAI,MAAM,WAAW,QAAQ;AACzB,4BAAQ;kBACZ,OAAO;AACH,8BAAU,MAAM;AAChB,4BAAQ;kBACZ;AACA,yBAAO;gBACX,CAAC;;YAET,KAAK;AACD,qBAAO,EAAE,MAAM,MAAM,OAAO,OAAS;YACzC,KAAK;AACD,oBAAM,IAAI,MACN,oDAAoD;YAE5D;AACI,oBAAM,IAAI,MAAM,aAAa;UACrC;QACJ;;IAER;;;;;;IAuCA,UAAO;AACH,UAAI,mBAAK,mBAAkB,GAAG;AAC1B,eAAO,IAAI,mBAA+B,OAAO,eAAc;AAE3D,gBAAM,WAAW,mBAAK,WAAW,SAAS,mBAAK,gBAAe;AAC9D,gBAAM,WAAW,QAAQ,QAAQ;AAEjC,qBAAW,YAAY,iBAAiB,SAAS,MAAK;AAClD,iBAAK,UAAU,KAAK,MAAM;UAC9B,CAAC;AAGD,iBAAO,MAAM;AACT,kBAAM,EAAE,MAAM,MAAK,IAAK,MAAM,KAAK,OAAO,KAAI;AAC9C,gBAAI,MAAM;AACN;YACJ;AAEA,kBAAM,WAAW,QAAQ,KAAK;UAClC;QACJ,CAAC;MACL,OAAO;AAEH,aAAK,OAAO,YAAW;AACvB,eAAO,KAAK;MAChB;IACJ;IAEA,MAAM,OAAO,QAAgB;AACzB,YAAM,KAAK,OAAO,OAAO,MAAM;IACnC;;AA7KA;AAGA;AACA;AAEA,EAAAA,aAAA;AAPE;AAoBF,oBAAa,SAAC,QAAc;AACxB,QAAI,CAAC,mBAAK,YAAW;AACjB,aAAO;IACX;AAEA,UAAM,QAAQ,mBAAK,WAAU,SACzB,mBAAK,kBACL,mBAAK,mBAAkB,MAAM;AAIjC,QAAI,mBAAK,mBAAkB,QAAQ;AAC/B,yBAAKA,YAAL,mBAAKA,cAAa;AAClB,yBAAK,iBAAL,mBAAK,mBAAmB;AACxB,yBAAK,iBAAL,mBAAK,mBAAmB;AACxB,aAAO;IACX;AAEA,uBAAKA,YAAL,mBAAKA,cAAa,mBAAK;AACvB,uBAAK,WAAY;AACjB,uBAAK,iBAAkB;AACvB,uBAAK,iBAAkB;AACvB,WAAO;EACX;AAEM,kBAAW,eAAC,QAAc;AAC5B,UAAM,EAAE,MAAM,MAAK,IAAK,MAAM,KAAK,OAAO,KAAI;AAC9C,QAAI,MAAM;AACN,YAAM,IAAI,wBAAuB;IACrC;AAEA,QAAI,MAAM,SAAS,QAAQ;AACvB,yBAAK,WAAY;AACjB,yBAAK,iBAAkB;AACvB,yBAAK,iBAAkB,MAAM,SAAS;AACtC,yBAAKA,YAAL,mBAAKA,cAAa;AAClB,aAAO,MAAM,SAAS,GAAG,MAAM;IACnC;AAEA,uBAAKA,YAAL,mBAAKA,cAAa,MAAM;AACxB,WAAO;EACX;;;ACpEJ;AAYM,MAAO,0BAAP,MAA8B;IAahC,YACI,WAAkE;AAXtE;AAKA;AASI,UAAI;AAEJ,UAAI;AAEJ,YAAM,WAAW,IAAI,uBACjB,IAAI,mBAA+B,CAAC,eAAc;AAC9C,mCAA2B;MAC/B,CAAC,CAAC;AAGN,yBAAK,WAAY,IAAI,eAAkB;QACnC,MAAM,KAAK,YAAU;AACjB,cAAI;AACA,kBAAM,QAAQ,MAAM,UAAU,QAAQ;AACtC,uBAAW,QAAQ,KAAK;UAC5B,SAAS,GAAG;AAIR,gBAAI,aAAa,kBAAkB;AAC/B,yBAAW,MAAK;AAChB;YACJ;AACA,kBAAM;UACV;QACJ;QACA,QAAQ,CAAC,WAAU;AAKf,iBAAO,yBAAyB,MAAM,MAAM;QAChD;OACH;AAED,yBAAK,WAAY,IAAI,eAAe;QAChC,MAAM,YAAU;AACZ,qCAA2B;QAC/B;QACA,MAAM,MAAM,OAAK;AACb,gBAAM,yBAAyB,QAAQ,KAAK;QAChD;QACA,QAAK;AACD,mCAAyB,MAAK;QAClC;QACA,QAAK;AACD,mCAAyB,MAAK;QAClC;OACH;IACL;IA9DA,IAAI,WAAQ;AACR,aAAO,mBAAK;IAChB;IAGA,IAAI,WAAQ;AACR,aAAO,mBAAK;IAChB;;AARA;AAKA;;;ACrBJ,0BAAAC,YAAA,qBAAAC;AAwBM,MAAO,qBAAP,MAAyB;IAkC3B,cAAA;AAhCA;kCAAU;AAEV,oCAAY,IAAI,gBAAe;AAE/B,yBAAAD,YAAY,IAAI,eAAuB;QACnC,OAAO,CAAC,UAAS;AACb,6BAAK,SAAL,mBAAK,WAAW;QACpB;QACA,OAAO,MAAK;AACR,6BAAK,WAAU,QAAQ,mBAAK,QAAO;AACnC,6BAAK,qBAAoB,QAAQ,mBAAK,QAAO;AAC7C,6BAAK,qBAAoB,MAAK;QAClC;QACA,OAAO,CAAC,WAAU;AACd,6BAAK,WAAU,OAAO,MAAM;AAC5B,6BAAK,qBAAoB,MAAM,MAAM;QACzC;OACH;AAKD;AACA,yBAAAC,YAAY,IAAI,eAAuB;QACnC,OAAO,CAAC,eAAc;AAClB,6BAAK,qBAAsB;QAC/B;OACH;AAMG,WAAK,OAAO,iBAAiB,mBAAKA,aAAW;QACzC,MAAM;UACF,KAAK,MACD,mBAAK,WAAU,QAAQ,KAAK,KAAK,mBAAK,WAAU,OAAO;;QAE/D,OAAO;UACH,KAAK,MACD,mBAAK,WAAU,QAAQ,MAAM,KAAK,mBAAK,WAAU,OAAO;;QAEhE,SAAS;UACL,KAAK,MACD,mBAAK,WAAU,QAAQ,QAAQ,KAAK,mBAAK,WAAU,OAAO;;OAErE;IACL;IA7BA,IAAI,WAAQ;AACR,aAAO,mBAAKD;IAChB;IAQA,IAAI,WAAQ;AACR,aAAO,mBAAKC;IAChB;;AA9BA;AAEA;AAEA,EAAAD,aAAA;AAkBA;AACA,EAAAC,aAAA;AAjDJ,iBAAAC,YAAAF,YAAAG,sBAAAF;AAyFM,MAAO,qBAAP,MAAyB;IAwD3B,cAAA;AAvDA,oCAA0B,CAAA;AAE1B,yBAAAC,YAAY,IAAI,gBAAe;AAE/B,yBAAAF,YAAY,IAAI,eAA2B;QACvC,OAAO,CAAC,UAAS;AACb,6BAAK,WAAU,KAAK,KAAK;QAC7B;QACA,OAAO,MAAK;AACR,cAAI;AACJ,cAAI,SAAS;AACb,kBAAQ,mBAAK,WAAU,QAAQ;YAC3B,KAAK;AACD,uBAAS;AACT;YACJ,KAAK;AACD,uBAAS,mBAAK,WAAU,CAAC;AACzB;YACJ;AACI,uBAAS,IAAI,WACT,mBAAK,WAAU,OACX,CAAC,MAAM,SAAS,OAAO,KAAK,QAC5B,CAAC,CACJ;AAEL,yBAAW,WAAW,mBAAK,YAAW;AAClC,uBAAO,IAAI,SAAS,MAAM;AAC1B,0BAAU,QAAQ;cACtB;AACA;UACR;AAEA,6BAAKE,YAAU,QAAQ,MAAM;AAC7B,6BAAKC,sBAAoB,QAAQ,MAAM;AACvC,6BAAKA,sBAAoB,MAAK;QAClC;QACA,OAAO,CAAC,WAAU;AACd,6BAAKD,YAAU,OAAO,MAAM;AAC5B,6BAAKC,sBAAoB,MAAM,MAAM;QACzC;OACH;AAKD,yBAAAA;AACA,yBAAAF,YAAY,IAAI,eAA2B;QACvC,OAAO,CAAC,eAAc;AAClB,6BAAKE,sBAAsB;QAC/B;OACH;AAMG,WAAK,OAAO,iBAAiB,mBAAKF,aAAW;QACzC,MAAM;UACF,KAAK,MACD,mBAAKC,YAAU,QAAQ,KAAK,KAAK,mBAAKA,YAAU,OAAO;;QAE/D,OAAO;UACH,KAAK,MACD,mBAAKA,YAAU,QAAQ,MAAM,KAAK,mBAAKA,YAAU,OAAO;;QAEhE,SAAS;UACL,KAAK,MACD,mBAAKA,YAAU,QAAQ,QAAQ,KAAK,mBAAKA,YAAU,OAAO;;OAErE;IACL;IA7BA,IAAI,WAAQ;AACR,aAAO,mBAAKF;IAChB;IAQA,IAAI,WAAQ;AACR,aAAO,mBAAKC;IAChB;;AArDA;AAEA,EAAAC,aAAA;AAEA,EAAAF,aAAA;AAyCA,EAAAG,uBAAA;AACA,EAAAF,aAAA;;;ACpHE,MAAO,2BAAP,MAAO,kCAAoC,eAA6B;IAC1E,aAAa,QACT,YACA,OAAQ;AAER,YAAM,SAAS,IAAI,WAAW,KAAK;AACnC,iBAAW,QAAQ,MAAM;AACzB,YAAM,OAAO;IACjB;IAEA,YACI,QACA,UAA6B;AAE7B,UAAI;AAEJ,UAAI;AACJ,UAAI,UAAU;AACV,0BAAkB,CAAA;AAClB,YAAI,mBAAmB,UAAU;AAC7B,0BAAgB,gBAAgB,SAAS;QAC7C;AACA,YAAI,UAAU,UAAU;AACpB,0BAAgB,OAAO,CAAC,UAAS;AAC7B,mBAAO,SAAS,KAAM,MAAM,KAAK;UACrC;QACJ;MACJ;AAEA,YACI;QACI,MAAM,YAAU;AACZ,8BAAoB;YAChB,QAAQ,OAAK;AACT,qBAAO,0BAAyB,QAC5B,YACA,KAAK;YAEb;YACA,QAAK;AACD,yBAAW,MAAK;YACpB;YACA,MAAM,QAAM;AACR,yBAAW,MAAM,MAAM;YAC3B;;AAGJ,iBAAO,OAAO,QAAQ,iBAAiB;QAC3C;QACA,OAAI;AACA,iBAAO,OAAO,OAAO,iBAAiB;QAC1C;QACA,OAAO,QAAM;AACT,iBAAO,OAAO,SAAS,MAAM;QACjC;SAEJ,eAAe;IAEvB;;;;ACzEE,MAAO,mCAAP,cAAgD,eAErD;IACG,YACI,QACA,WACA,KAAY;AAEZ,YAAM,SAAS,OAAO,UAAU,EAAE,MAAM,OAAM,CAAE;AAChD,UAAI,QAAQ,IAAI,WAAW,SAAS;AACpC,YAAM;QACF,MAAM,KAAK,YAAU;AACjB,gBAAM,EAAE,MAAM,MAAK,IAAK,MAAM,OAAO,KAAK,OAAO,EAAE,IAAG,CAAE;AACxD,cAAI,MAAM;AACN,uBAAW,MAAK;AAChB;UACJ;AAEA,gBAAM,yBAAyB,QAAQ,YAAY,KAAK;AAExD,kBAAQ,IAAI,WAAW,MAAM,MAAM;QACvC;QACA,OAAO,QAAM;AACT,iBAAO,OAAO,OAAO,MAAM;QAC/B;OACH;IACL;;;;AC5BE,MAAO,+BAAP,cAAkD,eAEvD;IACG,YAAY,QAAyB;AACjC,YAAM,SAAS,OAAO,UAAS;AAC/B,YAAM;QACF,MAAM,OAAK;AACP,iBAAO,MAAM,WAAW,CAACG,WAAU,OAAO,MAAMA,MAAK,CAAC;QAC1D;QACA,MAAM,QAAM;AACR,iBAAO,OAAO,MAAM,MAAM;QAC9B;QACA,QAAK;AACD,iBAAO,OAAO,MAAK;QACvB;OACH;IACL;;;;ACCE,MAAO,2BAAP,cAA8C,eAEnD;IACG,aAAa,MACT,QACA,OAAQ;AAER,YAAM,aAAa,IAAI,WAAW,KAAK;AACvC,YAAM,OAAO,MAAM,UAAU;AAC7B,YAAM,WAAW;IACrB;IAEA,YACI,MACA,UAA6B;AAE7B,UAAI;AACJ,UAAI,UAAU;AACV,0BAAkB,CAAA;AAClB,YAAI,mBAAmB,UAAU;AAC7B,0BAAgB,gBAAgB,SAAS;QAC7C;AACA,YAAI,UAAU,UAAU;AACpB,0BAAgB,OAAO,CAAC,UAAS;AAC7B,mBAAO,SAAS,KACZ,iBAAiB,aAAa,MAAM,QAAQ,KAAK;UAEzD;QACJ;MACJ;AAEA,YACI;QACI,MAAM,YAAU;AACZ,iBAAO,KAAK,QAAQ,UAAU;QAClC;QACA,MAAM,OAAO,YAAU;AACnB,iBAAO,MAAM,WAAW,CAACC,WACrB,KAAK,QAAQA,QAAO,UAAU,CAAC;QAEvC;QACA,MAAM,QAAM;AACR,iBAAO,KAAK,QAAQ,MAAM;QAC9B;QACA,QAAK;AACD,iBAAO,KAAK,QAAO;QACvB;SAEJ,eAAe;IAEvB;;;;ACzDJ,MAAM,EAAE,SAAAC,SAAO,IAAK;AACb,MAAM,aAAsD,uBAC/DA,UAAS,YAAY,KAAKA,QAAO,MAChC,OAAO;IACJ,IAAI,UAAQ;AACR,aAAO,SAAQ;IACnB;OACA;;;ACpBR,aAAAC;AAgBM,MAAO,aAAP,MAAiB;IAYnB,YAAY,OAAQ;AANX;AACA,yBAAAA;AAEA;AACA;AAGL,yBAAK,OAAQ,WAAW,YAAY;AACpC,WAAK,QAAQ;AACb,yBAAKA,YAAY,IAAI,gBAAe;AACpC,WAAK,WAAW,mBAAKA,YAAU;IACnC;IAEA,UAAO;AACH,yBAAKA,YAAU,QAAO;IAC1B;IAEA,MAAM,OAAc;AAChB,yBAAKA,YAAU,OAAO,KAAK;IAC/B;IAEA,WAAc,UAAyB;AACnC,UAAI;AACA,YAAI,SAAS,mBAAK,OAAM,IAAI,MAAM,SAAS,KAAK,KAAK,CAAC;AACtD,YAAI,cAAc,MAAM,GAAG;AACvB,mBAAS,OAAO,KACZ,CAAC,UAAS;AACN,+BAAKA,YAAU,QAAO;AACtB,mBAAO;UACX,GACA,CAAC,MAAK;AACF,+BAAKA,YAAU,OAAO,CAAC;AACvB,kBAAM;UACV,CAAC;QAET,OAAO;AACH,6BAAKA,YAAU,QAAO;QAC1B;AACA,eAAO;MACX,SAAS,GAAG;AACR,2BAAKA,YAAU,OAAO,CAAC;AACvB,cAAM;MACV;IACJ;;AA3CS;AACA,EAAAA,aAAA;AANT,gBADS,YACO,kBAAiB;AACjC,gBAFS,YAEO,sBAAqB;AACrC,gBAHS,YAGO,kBAAiB;AACjC,gBAJS,YAIO,0BAAyB;;;ACpB7C;;;;;;;;;ACGM,WAAU,SAAY,OAAyB;AACjD,WAAO,iBAAiB,aAAa,MAAM,QAAQ;EACvD;AAEM,WAAU,WACZ,OACA,UAA6D;AAE7D,QAAI,iBAAiB,YAAY;AAC7B,aAAO,MAAM,WAAW,QAAQ;IACpC,OAAO;AACH,aAAO,SAAS,KAAc;IAClC;EACJ;;;ACXM,MAAO,oCAAP,cAAoD,eAEzD;IACG,YAAY,QAAyB;AACjC,YAAM,SAAS,OAAO,UAAS;AAC/B,YAAM;QACF,MAAM,OAAK;AACP,iBAAO,WAAW,OAAO,CAACC,WAAU,OAAO,MAAMA,MAAU,CAAC;QAChE;QACA,MAAM,QAAM;AACR,iBAAO,OAAO,MAAM,MAAM;QAC9B;QACA,QAAK;AACD,iBAAO,OAAO,MAAK;QACvB;OACH;IACL;;;;ACCE,MAAO,gCAAP,cAAmD,eAExD;IACG,YACI,MACA,UAA6B;AAE7B,UAAI;AACJ,UAAI,UAAU;AACV,0BAAkB,CAAA;AAClB,YAAI,mBAAmB,UAAU;AAC7B,0BAAgB,gBAAgB,SAAS;QAC7C;AACA,YAAI,UAAU,UAAU;AACpB,0BAAgB,OAAO,CAAC,UAAS;AAC7B,mBAAO,SAAS,KACZ,iBAAiB,aAAa,MAAM,QAAQ,KAAK;UAEzD;QACJ;MACJ;AAEA,YACI;QACI,MAAM,YAAU;AACZ,iBAAO,KAAK,QAAQ,UAAU;QAClC;QACA,MAAM,OAAO,YAAU;AACnB,iBAAO,WAAW,OAAO,CAACC,WACtB,KAAK,QAAQA,QAAY,UAAU,CAAC;QAE5C;QACA,MAAM,QAAM;AACR,iBAAO,KAAK,QAAQ,MAAM;QAC9B;QACA,QAAK;AACD,iBAAO,KAAK,QAAO;QACvB;SAEJ,eAAe;IAEvB;;;;AC/DJ;AAOM,MAAO,iBAAP,MAAqB;IAMvB,YAAY,MAAY;AALxB;AACS;AACT;AACA;AAGI,yBAAK,WAAY;AACjB,yBAAK,SAAU,IAAI,WAAW,IAAI;AAClC,yBAAK,SAAU;AACf,yBAAK,YAAa;IACtB;;;;;;;;IASA,CAAC,KAAK,MAAgB;AAClB,UAAI,SAAS;AACb,UAAI,YAAY,KAAK;AAErB,UAAI,mBAAK,aAAY,GAAG;AACpB,YAAI,aAAa,mBAAK,aAAY;AAC9B,6BAAK,SAAQ,IACT,KAAK,SAAS,GAAG,mBAAK,WAAU,GAChC,mBAAK,QAAO;AAEhB,oBAAU,mBAAK;AACf,uBAAa,mBAAK;AAElB,gBAAM,mBAAK;AACX,6BAAK,SAAU;AACf,6BAAK,YAAa,mBAAK;AAEvB,cAAI,cAAc,GAAG;AACjB;UACJ;QACJ,OAAO;AACH,6BAAK,SAAQ,IAAI,MAAM,mBAAK,QAAO;AACnC,6BAAK,SAAL,mBAAK,WAAW;AAChB,6BAAK,YAAL,mBAAK,cAAc;AACnB;QACJ;MACJ;AAEA,aAAO,aAAa,mBAAK,YAAW;AAChC,cAAM,MAAM,SAAS,mBAAK;AAC1B,cAAM,KAAK,SAAS,QAAQ,GAAG;AAC/B,iBAAS;AACT,qBAAa,mBAAK;MACtB;AAEA,UAAI,YAAY,GAAG;AACf,2BAAK,SAAQ,IAAI,KAAK,SAAS,MAAM,GAAG,mBAAK,QAAO;AACpD,2BAAK,SAAL,mBAAK,WAAW;AAChB,2BAAK,YAAL,mBAAK,cAAc;MACvB;IACJ;IAEA,QAAK;AACD,UAAI,mBAAK,aAAY,GAAG;AACpB,eAAO;MACX;AAEA,YAAM,SAAS,mBAAK,SAAQ,SAAS,GAAG,mBAAK,QAAO;AACpD,yBAAK,SAAU;AACf,yBAAK,YAAa,mBAAK;AACvB,aAAO;IACX;;AAtEA;AACS;AACT;AACA;AAsEE,MAAO,qBAAP,cAAkC,gBAGvC;IACG,YAAY,MAAc,UAAU,OAAK;AACrC,YAAM,WAAW,UAAU,IAAI,eAAe,IAAI,IAAI;AACtD,YAAM;QACF,MAAM,UAAU,OAAO,YAAU;AAC7B,gBAAM,yBAAgB,WAAW,OAAO,OAAOC,WAAS;AACpD,gBAAI,UAAU;AACV,yBAAWC,WAAU,SAAS,KAAKD,MAAK,GAAG;AACvC,sBAAM,WAAW,eAAe,QAC5B,YACAC,OAAM;cAEd;YACJ,OAAO;AACH,kBAAI,SAAS;AACb,kBAAI,YAAYD,OAAM;AACtB,qBAAO,YAAY,GAAG;AAClB,sBAAM,MAAM,SAAS;AACrB,sBAAM,WAAW,eAAe,QAC5B,YACAA,OAAM,SAAS,QAAQ,GAAG,CAAC;AAE/B,yBAAS;AACT,6BAAa;cACjB;YACJ;UACJ,CAAC;QACL;QACA,MAAM,YAAU;AACZ,cAAI,UAAU;AACV,kBAAM,OAAO,SAAS,MAAK;AAC3B,gBAAI,MAAM;AACN,yBAAW,QAAQ,IAAI;YAC3B;UACJ;QACJ;OACH;IACL;;;;ACrGJ,WAAS,yBACL,SAIA,YAA8C;AAE9C,QAAI,WAAW,SAAS;AACpB,aAAO,QAAQ,MAAM,UAAU;IACnC,WAAW,OAAO,YAAY,YAAY;AACtC,aAAO,QAAQ,UAAU;IAC7B,OAAO;AAGH,aAAO;IACX;EACJ;AA7BA;AAsCM,MAAO,qBAAP,cAAqC,eAAiB;IAKxD,YACI,SAIA,UAA6B;AAE7B,YACI;QACI,OAAO,OAAO,eAAc;AACxB,gBAAM,WAAW,MAAM,yBACnB,SACA,UAAU;AAId,eAAK,WAAW;AAChB,6BAAK,SAAU,KAAK,SAAS,UAAS;QAC1C;QACA,MAAM,OAAO,eAAc;AACvB,gBAAM,EAAE,MAAM,MAAK,IAAK,MAAM,mBAAK,SAC9B,KAAI,EACJ,MAAM,CAAC,MAAK;AACT,gBAAI,WAAW,SAAS;AACpB,sBAAQ,MAAM,CAAC;YACnB;AACA,kBAAM;UACV,CAAC;AAEL,cAAI,MAAM;AACN,uBAAW,MAAK;AAChB,gBAAI,WAAW,SAAS;AACpB,oBAAM,QAAQ,QAAO;YACzB;UACJ,OAAO;AACH,uBAAW,QAAQ,KAAK;UAC5B;QACJ;QACA,QAAQ,OAAO,WAAU;AACrB,gBAAM,mBAAK,SAAQ,OAAO,MAAM;AAChC,cAAI,YAAY,SAAS;AACrB,kBAAM,QAAQ,SAAS,MAAM;UACjC;QACJ;SAEJ,QAAQ;AAjDhB;AAEA;IAiDA;;AAjDA;;;ACnCJ,MAAM,OAAO,MAAK;EAElB;AAdA;AAgDM,MAAO,sBAAP,MAA0B;IAgB5B,YAAY,SAAoC;AAfhD,+CAA6D,CAAA;AAC7D,mCAA6C,CAAA;AAE7C,0CAAkB;AAKlB,kCAAU,IAAI,gBAAe;AAKpB;AAGL,yBAAK,UAAW,WAAW,CAAA;IAC/B;IAbA,IAAI,iBAAc;AACd,aAAO,mBAAK;IAChB;IAGA,IAAI,SAAM;AACN,aAAO,mBAAK,SAAQ;IACxB;IAQA,aACI,UACA,UAA6B;AAE7B,aAAO,IAAI,mBACP;QACI,OAAO,CAAC,eAAc;AAClB,6BAAK,sBAAqB,KAAK,UAAU;AACzC,iBAAO;QACX;QACA,QAAQ,YAAW;AAEf,gBAAM,KAAK,MAAK;QACpB;QACA,OAAO,YAAW;AAEd,gBAAM,KAAK,QAAO;QACtB;SAEJ,QAAQ;IAEhB;IAEA,eAAe,QAAyB;AACpC,YAAM,SAAS,OAAO,UAAS;AAC/B,yBAAK,UAAS,KAAK,MAAM;AAIzB,aAAO,IAAI,eAAkB;QACzB,OAAO,OAAO,UAAS;AACnB,gBAAM,OAAO,MAAM,KAAK;QAC5B;QACA,OAAO,OAAO,WAAU;AACpB,gBAAM,OAAO,MAAM,MAAM;AACzB,gBAAM,KAAK,MAAK;QACpB;QACA,OAAO,YAAW;AAEd,gBAAM,OAAO,MAAK,EAAG,MAAM,IAAI;AAC/B,gBAAM,KAAK,MAAK;QACpB;OACH;IACL;IAEA,MAAM,QAAK;AACP,UAAI,mBAAK,kBAAiB;AACtB;MACJ;AACA,yBAAK,iBAAkB;AAGvB,UAAK,MAAM,mBAAK,UAAS,QAAO,MAAQ,OAAO;AAE3C,cAAM,KAAK,QAAO;MACtB;AAEA,iBAAW,UAAU,mBAAK,WAAU;AAEhC,eAAO,MAAK,EAAG,MAAM,IAAI;MAC7B;IACJ;IAEA,MAAM,UAAO;AACT,yBAAK,iBAAkB;AACvB,yBAAK,SAAQ,QAAO;AAEpB,iBAAW,cAAc,mBAAK,uBAAsB;AAChD,iBAAS,UAAU;MACvB;AAEA,YAAM,mBAAK,UAAS,UAAS;IACjC;;AA3FA;AACA;AAEA;AAKA;AAKS;;;AC/Bb,MAAM,SAAS;AAER,MAAM,oBAAoB,OAAO;AAGjC,MAAM,oBAAoB,OAAO;;;ACnClC,MAAO,gBAAP,cAAgC,gBAAqB;IACvD,YAAY,UAA4B;AACpC,YAAM;QACF,UAAU,OAAO,YAAU;AACvB,mBAAS,KAAK;AACd,qBAAW,QAAQ,KAAK;QAC5B;OACH;IACL;;;;ACEE,WAAU,SACZ,UACA,MAAgC;AAEhC,UAAM,SAAS,KAAK,SAAS,UAAS;AACtC,UAAM,OAAO,KAAK,SAAS,OAAO,QAAQ;AAC1C,WAAO,IAAI,eAAkB;MACzB,MAAM,MAAM,OAAK;AACb,cAAM,OAAO,MAAM,KAAK;MAC5B;MACA,MAAM,QAAK;AACP,cAAM,OAAO,MAAK;AAClB,cAAM;MACV;KACH;EACL;;;ACzBM,MAAO,oBAAP,cAAiC,gBAA+B;IAClE,YAAY,WAAiB;AACzB,UAAI,YAAgC;AAEpC,YAAM;QACF,UAAU,OAAO,YAAU;AACvB,cAAI,WAAW;AACX,oBAAQ,YAAY;AACpB,wBAAY;UAChB;AAEA,cAAI,QAAQ;AACZ,iBAAO,QAAQ,MAAM,QAAQ;AACzB,kBAAM,QAAQ,MAAM,QAAQ,WAAW,KAAK;AAC5C,gBAAI,UAAU,IAAI;AACd,0BAAY,MAAM,UAAU,KAAK;AACjC;YACJ;AAEA,uBAAW,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAChD,oBAAQ,QAAQ;UACpB;QACJ;QACA,MAAM,YAAU;AACZ,cAAI,WAAW;AACX,uBAAW,QAAQ,SAAS;UAChC;QACJ;OACH;IACL;;;;AC3BE,MAAO,0BAAP,cAA0C,wBAA0B;IACtE,YAAYE,SAA6B;AACrC,YAAM,CAAC,WAAU;AACb,eAAOA,QAAO,YAAY,MAAM;MACpC,CAAC;IACL;;;;ACLE,MAAO,wBAAP,cAEI,gBAA0C;IAChD,YAAYC,SAAS;AACjB,YAAM;QACF,UAAU,OAAO,YAAU;AACvB,qBAAW,QAAQA,QAAO,UAAU,KAAK,CAAC;QAC9C;OACH;IACL;;;;ACCJ,iBAAe,yBACX,OAG8B;AAE9B,QAAI,WAAW,OAAO;AAClB,aAAO,MAAM,MAAM,MAAK;IAC5B,WAAW,OAAO,UAAU,YAAY;AACpC,aAAO,MAAM,MAAK;IACtB,OAAO;AAGH,aAAO;IACX;EACJ;AA1BA;AA4BM,MAAO,sBAAP,MAAO,4BAA8B,eAAiB;IAKxD,YACI,OAG8B;AAE9B,YAAM;QACF,OAAO,YAAW;AACd,gBAAM,WAAW,MAAM,yBAAyB,KAAK;AAGrD,eAAK,WAAW;AAChB,6BAAK,SAAU,KAAK,SAAS,UAAS;QAC1C;QACA,OAAO,OAAO,UAAS;AACnB,gBAAM,mBAAK,SAAQ,MAAM,KAAK;QAClC;QACA,OAAO,OAAO,WAAU;AACpB,gBAAM,mBAAK,SAAQ,MAAM,MAAM;AAC/B,cAAI,UAAU,KAAK,YAAY,WAAW,OAAO;AAC7C,kBAAM,MAAM,QAAO;UACvB;QACJ;QACA,OAAO,YAAW;AAKd,gBAAM,mBAAK,SAAQ,MAAK;AACxB,cAAI,UAAU,KAAK,YAAY,WAAW,OAAO;AAC7C,kBAAM,MAAM,QAAO;UACvB;QACJ;OACH;AArCL;AAEA;IAoCA;IAEA,mBAAsB,aAAkC;AACpD,UAAI;AACJ,aAAO,IAAI,oBAAsB;QAC7B,OAAO,MAAK;AACR,oBAAU,YAAY,SAAS,OAAO,IAAI;AAC1C,iBAAO,YAAY;QACvB;QACA,MAAM,QAAK;AACP,gBAAM;QACV;OACH;IACL;;AAjDA;AAHE,MAAO,qBAAP;;;AC3BN;AAAM,MAAO,iBAAP,MAAqB;IAGvB,cAAA;AAFA,uCAA6B,CAAA;AAGzB,WAAK,UAAU,KAAK,QAAQ,KAAK,IAAI;IACzC;IAEU,cAAoC,YAAa;AACvD,yBAAK,cAAa,KAAK,UAAU;AACjC,aAAO;IACX;IAEA,UAAO;AACH,iBAAW,cAAc,mBAAK,eAAc;AACxC,mBAAW,QAAO;MACtB;AAEA,yBAAK,cAAe,CAAA;IACxB;;AAjBA;;;ACME,MAAO,eAAP,MAAmB;IAGrB,cAAA;AAFmB,uCAAkD,CAAA;AAqBrE,mCAAgC,CAC5B,UACA,YACG,SACH;AACA,cAAM,OAA2C;UAC7C;UAMA;UACA;;AAEJ,eAAO,KAAK,iBAAiB,IAAI;MACrC;AAlCI,WAAK,QAAQ,KAAK,MAAM,KAAK,IAAI;IACrC;IAEU,iBACN,MAAwC;AAExC,WAAK,UAAU,KAAK,IAAI;AAExB,YAAM,SAA8B,MAAK;AACrC,cAAM,QAAQ,KAAK,UAAU,QAAQ,IAAI;AACzC,YAAI,UAAU,IAAI;AACd,eAAK,UAAU,OAAO,OAAO,CAAC;QAClC;MACJ;AACA,aAAO,UAAU;AACjB,aAAO;IACX;IAoBA,KAAK,GAAS;AACV,iBAAW,QAAQ,KAAK,UAAU,MAAK,GAAI;AACvC,aAAK,SAAS,KAAK,KAAK,SAAS,GAAG,GAAG,KAAK,IAAI;MACpD;IACJ;IAEA,UAAO;AACH,WAAK,UAAU,SAAS;IAC5B;;;;ACvDJ,MAAM,YAAY,uBAAO,WAAW;AAHpC;AAKM,MAAO,qBAAP,cAA6D,aAGlE;IAHK;;AAIF,iCAAoC;;IAEjB,iBACf,MAAwC;AAExC,UAAI,mBAAK,YAAW,WAAW;AAC3B,aAAK,SAAS,KAAK,KAAK,SAAS,mBAAK,SAAQ,GAAG,KAAK,IAAI;MAC9D;AACA,aAAO,MAAM,iBAAiB,IAAI;IACtC;IAES,KAAK,GAAS;AACnB,yBAAK,QAAS;AACd,YAAM,KAAK,CAAC;IAChB;;AAdA;;;ACVJ;AAIM,MAAO,iBAAP,cAA8B,eAAc;IAM9C,YAAY,KAAQ;AAChB,YAAK;AANA;AAOL,yBAAK,MAAO;IAChB;IAPA,IAAI,MAAG;AACH,aAAO,mBAAK;IAChB;;AAHS;;;ACCb,MAAM,UAAU,OAAO,EAAE,SAAS,IAAG,GAAI,EAAE,cAAc,KAAI,CAAE;AAExD,MAAM,mBAAmB,OAC5B;IACI,KAAK;IACL,MAAM;IACN,OAAO;IACP,QAAQ;IACR,YAAY;IACZ,YAAY;IACZ,aAAa;IACb,aAAa;IACb,cAAc;IACd,cAAc;IACd,cAAc;IACd,cAAc;IACd,MAAM,OAAO,MAAM;KAEvB,EAAE,cAAc,KAAI,CAAE;AAKnB,MAAM,mBAAmB,OAC5B;IACI,KAAK;IACL,YAAY;IACZ,MAAM;IACN,OAAO;IACP,QAAQ;IACR,YAAY;IACZ,YAAY;IACZ,aAAa;IACb,aAAa;IACb,cAAc;IACd,cAAc;IACd,cAAc;IACd,cAAc;IACd,MAAM,OAAO,MAAM;KAEvB,EAAE,cAAc,KAAI,CAAE;AAuBpB,MAAgB,sBAAhB,cAA4C,MAAK;IACnD,YAAY,SAAiB,SAAsB;AAC/C,YAAM,SAAS,OAAO;IAC1B;;AAGE,MAAO,wCAAP,cAAqD,oBAAmB;IAC1E,YAAY,SAAe;AACvB,YAAM,mCAAmC,OAAO,EAAE;IACtD;;AAGE,MAAO,+BAAP,cAA4C,oBAAmB;IACjE,cAAA;AACI,YAAM,wCAAwC;IAClD;;AAGJ,iBAAsB,YAAY,KAAQ;AACtC,UAAM,SAAS,MAAM,IAAI,aAAa,cAAc;AACpD,UAAM,SAAS,IAAI,uBAAuB,OAAO,QAAQ;AAEzD,QAAI;AACJ,QAAI;AACA,OAAC,EAAE,QAAO,IAAK,MAAM,QAAQ,YAAY,MAAM;IACnD,SAAS,GAAG;AACR,UAAI,aAAa,kBAAkB;AAC/B,cAAM,IAAI,6BAA4B;MAC1C;AACA,YAAM;IACV;AAEA,YAAQ,SAAS;MACb,KAAK;AAED,eAAO,MAAM,iBAAiB,YAAY,MAAM;MACpD,KAAK;AACD,eAAO,MAAM,iBAAiB,YAAY,MAAM;MACpD;AACI,cAAM,IAAI,sCAAsC,OAAO;IAC/D;EACJ;;;ACvGM,MAAO,WAAP,cAAwB,eAAc;IACxC,OAAO,OAAO,IAAE;AACZ,aAAO,KAAK,IAAI,oBAAoB,UAAU,IAAI,EAAE;IACxD;IAEA,aAAU;AACN,aAAO,KAAK,OAAO,YAAY;IACnC;IAEA,WAAQ;AACJ,aAAO,KAAK,OAAO,UAAU;IACjC;IAEA,WAAQ;AACJ,aAAO,KAAK,OAAO,UAAU;IACjC;IAEA,WAAQ;AACJ,aAAO,KAAK,OAAO,UAAU;IACjC;;;;;;IAOA,kBAAe;AACX,aAAO,KAAK,OAAO,KAAK;IAC5B;IAEA,WAAQ;AACJ,aAAO,KAAK,IAAI,WAAW,aAAa,cAAc,CAAC,UAAU,IAAI,CAAC;IAC1E;IAEA,YAAY,YAAY,OAAK;AACzB,YAAM,OAAO,CAAC,SAAS,UAAU;AACjC,UAAI,WAAW;AACX,aAAK,KAAK,aAAa;MAC3B;AACA,WAAK,KAAK,OAAO;AAEjB,aAAO,KAAK,IAAI,WAAW,aAAa,cAAc,IAAI;IAC9D;;;;;;IAOA,cAAW;AACP,aAAO,KAAK,OAAO,UAAU;IACjC;;;;AC1DE,WAAU,kBAAkB,OAAiB;AAC/C,QAAI,MAAM,kBAAkB,aAAa;AACrC,aAAO;IACX;AAEA,UAAM,OAAO,IAAI,WAAW,MAAM,MAAM;AACxC,SAAK,IAAI,KAAK;AACd,WAAO;EACX;;;ACRA;AAGM,MAAO,iBAAP,MAAqB;IAIvB,YAAY,aAAa,OAAK;AAH9B;AACS,iCAAkC,CAAA;AAGvC,yBAAK,MAAO;IAChB;IAEA,OAAI;AACA,UAAI,CAAC,mBAAK,OAAM;AACZ,2BAAK,MAAO;AAEZ,YAAI,mBAAK,QAAO,WAAW,GAAG;AAC1B,iBAAO,QAAQ,QAAO;QAC1B;MACJ;AAEA,YAAM,WAAW,IAAI,gBAAe;AACpC,yBAAK,QAAO,KAAK,QAAQ;AACzB,aAAO,SAAS;IACpB;IAEA,YAAS;AACL,UAAI,mBAAK,QAAO,WAAW,GAAG;AAC1B,2BAAK,QAAO,IAAG,EAAI,QAAO;MAC9B,OAAO;AACH,2BAAK,MAAO;MAChB;IACJ;IAEA,UAAO;AACH,iBAAW,QAAQ,mBAAK,SAAQ;AAC5B,aAAK,OAAO,IAAI,MAAM,sCAAsC,CAAC;MACjE;AACA,yBAAK,QAAO,SAAS;IACzB;;AAlCA;AACS;;;ACLb,MAAM,CAAC,aAAa,aAAa,WAAW,IAAqB,uBAAK;AAElE,UAAMC,eAAwB,CAAA;AAC9B,UAAMC,eAAwB,CAAA;AAC9B,UAAMC,eAAc,IAAI,WAAW,CAAC;AAEpC,aAAS,SAAS,OAAe,KAAW;AACxC,YAAM,gBAAgB,MAAM,WAAW,CAAC;AACxC,YAAM,cAAc,IAAI,WAAW,CAAC;AAEpC,eACQ,WAAW,eACf,YAAY,aACZ,YAAY,GACd;AACE,QAAAF,aAAY,QAAQ,IAAIC,aAAY;AACpC,QAAAA,aAAY,KAAK,QAAQ;MAC7B;IACJ;AAEA,aAAS,KAAK,GAAG;AACjB,aAAS,KAAK,GAAG;AACjB,aAAS,KAAK,GAAG;AACjB,aAAS,KAAK,GAAG;AACjB,aAAS,KAAK,GAAG;AAEjB,WAAO,CAACD,cAAaC,cAAaC,YAAW;EACjD,GAAE;AAQI,WAAU,6BACZ,aAAmB;AAEnB,UAAM,YAAY,cAAc;AAChC,UAAM,gBAAgB,cAAc,IAAI,IAAI,YAAY;AACxD,WAAO,EAAG,cAAc,iBAAiB,IAAK,GAAG,aAAa;EAClE;AAqBM,WAAU,aACZ,OACA,QAAmB;AAEnB,UAAM,CAAC,cAAc,aAAa,IAAI,6BAClC,MAAM,MAAM;AAGhB,QAAI,CAAC,QAAQ;AACT,eAAS,IAAI,WAAW,YAAY;AACpC,oBAAc,OAAO,QAAQ,aAAa;AAC1C,aAAO;IACX,OAAO;AACH,UAAI,OAAO,SAAS,cAAc;AAC9B,cAAM,IAAI,UAAU,4BAA4B;MACpD;AAEA,eAAS,OAAO,SAAS,GAAG,YAAY;AAIxC,UAAI,MAAM,WAAW,OAAO,QAAQ;AAChC,sBAAc,OAAO,QAAQ,aAAa;MAC9C,WACI,OAAO,aAAa,OAAO,UAAU,gBAAgB,MACrD,MAAM,aAAa,MAAM,QAC3B;AA6BE,sBAAc,OAAO,QAAQ,aAAa;MAC9C,WAAW,OAAO,cAAc,MAAM,aAAa,GAAG;AAWlD,uBAAe,OAAO,QAAQ,aAAa;MAC/C,OAAO;AAIH,cAAM,IAAI,UAAU,iCAAiC;MACzD;AAEA,aAAO;IACX;EACJ;AAEA,WAAS,cACL,OACA,QACA,eAAqB;AAErB,QAAI,aAAa;AACjB,QAAI,cAAc;AAElB,WAAO,aAAa,MAAM,SAAS,GAAG;AAGlC,YAAM,IAAI,MAAM,UAAU;AAC1B,oBAAc;AAId,YAAM,IAAI,MAAM,UAAU;AAC1B,oBAAc;AAId,YAAM,IAAI,MAAM,UAAU;AAC1B,oBAAc;AAEd,aAAO,WAAW,IAAI,YAAY,KAAK,CAAC;AACxC,qBAAe;AAEf,aAAO,WAAW,IAAI,aAAc,IAAI,MAAS,IAAM,KAAK,CAAE;AAC9D,qBAAe;AAEf,aAAO,WAAW,IAAI,aAAc,IAAI,OAAW,IAAM,KAAK,CAAE;AAChE,qBAAe;AAEf,aAAO,WAAW,IAAI,YAAY,IAAI,EAAQ;AAC9C,qBAAe;IACnB;AAEA,QAAI,kBAAkB,GAAG;AAGrB,YAAM,IAAI,MAAM,UAAU;AAC1B,oBAAc;AAEd,aAAO,WAAW,IAAI,YAAY,KAAK,CAAC;AACxC,qBAAe;AAEf,aAAO,WAAW,IAAI,aAAa,IAAI,MAAS,CAAC;AACjD,qBAAe;AAEf,aAAO,WAAW,IAAI;AACtB,qBAAe;AAEf,aAAO,WAAW,IAAI;IAC1B,WAAW,kBAAkB,GAAG;AAG5B,YAAM,IAAI,MAAM,UAAU;AAC1B,oBAAc;AAId,YAAM,IAAI,MAAM,UAAU;AAC1B,oBAAc;AAEd,aAAO,WAAW,IAAI,YAAY,KAAK,CAAC;AACxC,qBAAe;AAEf,aAAO,WAAW,IAAI,aAAc,IAAI,MAAS,IAAM,KAAK,CAAE;AAC9D,qBAAe;AAEf,aAAO,WAAW,IAAI,aAAa,IAAI,OAAW,CAAC;AACnD,qBAAe;AAEf,aAAO,WAAW,IAAI;IAC1B;EACJ;AAEA,WAAS,eACL,OACA,QACA,eAAqB;AAErB,QAAI,aAAa,MAAM,SAAS;AAChC,QAAI,cAAc,OAAO,SAAS;AAElC,QAAI,kBAAkB,GAAG;AAGrB,YAAM,IAAI,MAAM,UAAU;AAC1B,oBAAc;AAEd,aAAO,WAAW,IAAI;AACtB,qBAAe;AAEf,aAAO,WAAW,IAAI;AACtB,qBAAe;AAEf,aAAO,WAAW,IAAI,aAAa,IAAI,MAAS,CAAC;AACjD,qBAAe;AAEf,aAAO,WAAW,IAAI,YAAY,KAAK,CAAC;AACxC,qBAAe;IACnB,WAAW,kBAAkB,GAAG;AAG5B,YAAM,IAAI,MAAM,UAAU;AAC1B,oBAAc;AAId,YAAM,IAAI,MAAM,UAAU;AAC1B,oBAAc;AAEd,aAAO,WAAW,IAAI;AACtB,qBAAe;AAEf,aAAO,WAAW,IAAI,aAAa,IAAI,OAAW,CAAC;AACnD,qBAAe;AAEf,aAAO,WAAW,IAAI,aAAc,IAAI,MAAS,IAAM,KAAK,CAAE;AAC9D,qBAAe;AAEf,aAAO,WAAW,IAAI,YAAY,KAAK,CAAC;AACxC,qBAAe;IACnB;AAEA,WAAO,cAAc,GAAG;AAGpB,YAAM,IAAI,MAAM,UAAU;AAC1B,oBAAc;AAId,YAAM,IAAI,MAAM,UAAU;AAC1B,oBAAc;AAId,YAAM,IAAI,MAAM,UAAU;AAC1B,oBAAc;AAEd,aAAO,WAAW,IAAI,YAAY,IAAI,EAAQ;AAC9C,qBAAe;AAEf,aAAO,WAAW,IAAI,aAAc,IAAI,OAAW,IAAM,KAAK,CAAE;AAChE,qBAAe;AAEf,aAAO,WAAW,IAAI,aAAc,IAAI,MAAS,IAAM,KAAK,CAAE;AAC9D,qBAAe;AAEf,aAAO,WAAW,IAAI,YAAY,KAAK,CAAC;AACxC,qBAAe;IACnB;EACJ;AAEM,WAAU,aAAa,OAAa;AACtC,QAAI;AACJ,QAAI,MAAM,MAAM,SAAS,CAAC,MAAM,KAAK;AACjC,gBAAU;IACd,WAAW,MAAM,MAAM,SAAS,CAAC,MAAM,KAAK;AACxC,gBAAU;IACd,OAAO;AACH,gBAAU;IACd;AAEA,UAAM,SAAS,IAAI,WAAY,MAAM,SAAS,IAAK,IAAI,OAAO;AAC9D,QAAI,SAAS;AACb,QAAI,SAAS;AAEb,WAAO,SAAS,MAAM,UAAU,YAAY,IAAI,IAAI,IAAI;AACpD,YAAM,IAAI,YAAY,MAAM,WAAW,MAAM,CAAC;AAC9C,gBAAU;AAEV,YAAM,IAAI,YAAY,MAAM,WAAW,MAAM,CAAC;AAC9C,gBAAU;AAEV,YAAM,IAAI,YAAY,MAAM,WAAW,MAAM,CAAC;AAC9C,gBAAU;AAEV,YAAM,IAAI,YAAY,MAAM,WAAW,MAAM,CAAC;AAC9C,gBAAU;AAEV,aAAO,MAAM,IAAK,KAAK,KAAO,IAAI,OAAc;AAChD,gBAAU;AAEV,aAAO,MAAM,KAAM,IAAI,OAAW,KAAO,IAAI,OAAc;AAC3D,gBAAU;AAEV,aAAO,MAAM,KAAM,IAAI,MAAS,IAAK;AACrC,gBAAU;IACd;AAEA,QAAI,YAAY,GAAG;AACf,YAAM,IAAI,YAAY,MAAM,WAAW,MAAM,CAAC;AAC9C,gBAAU;AAEV,YAAM,IAAI,YAAY,MAAM,WAAW,MAAM,CAAC;AAC9C,gBAAU;AAEV,YAAM,IAAI,YAAY,MAAM,WAAW,MAAM,CAAC;AAE9C,aAAO,MAAM,IAAK,KAAK,KAAO,IAAI,OAAc;AAChD,gBAAU;AAEV,aAAO,MAAM,KAAM,IAAI,OAAW,KAAO,IAAI,OAAc;IAC/D,WAAW,YAAY,GAAG;AACtB,YAAM,IAAI,YAAY,MAAM,WAAW,MAAM,CAAC;AAC9C,gBAAU;AAEV,YAAM,IAAI,YAAY,MAAM,WAAW,MAAM,CAAC;AAE9C,aAAO,MAAM,IAAK,KAAK,KAAO,IAAI,OAAc;IACpD;AAEA,WAAO;EACX;;;ACrWA,WAAS,gBAAgB,MAAY;AACjC,QAAI,OAAO,IAAI;AACX,YAAM,IAAI,UAAU,oBAAoB,IAAI,EAAE;IAClD;AACA,QAAI,OAAO,IAAI;AAEX,aAAO,OAAO;IAClB;AAEA,QAAI,OAAO,IAAI;AACX,YAAM,IAAI,UAAU,oBAAoB,IAAI,EAAE;IAClD;AACA,QAAI,OAAO,IAAI;AAEX,aAAO,OAAO;IAClB;AAEA,QAAI,OAAO,IAAI;AACX,YAAM,IAAI,UAAU,oBAAoB,IAAI,EAAE;IAClD;AACA,QAAI,OAAO,KAAK;AAEZ,aAAO,OAAO;IAClB;AAEA,UAAM,IAAI,UAAU,oBAAoB,IAAI,EAAE;EAClD;AAIM,WAAU,YAAY,MAAgB;AACxC,QAAI,SAAS;AACb,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK,GAAG;AACrC,eAAU,UAAU,IAAK,gBAAgB,KAAK,CAAC,CAAE;IACrD;AACA,WAAO;EACX;AAEM,WAAU,gBACZC,SACA,OACA,OAAa;AAEb,UAAM,QAAQ;AACd,aAAS;AACT,WAAO,SAAS,SAAS,QAAQ,GAAG;AAChC,YAAM,QAAQ,QAAQ;AACtB,gBAAU;AACV,UAAI,QAAQ,IAAI;AACZ,QAAAA,QAAO,KAAK,IAAI,QAAQ;MAC5B,OAAO;AACH,QAAAA,QAAO,KAAK,IAAI,QAAQ;MAC5B;AACA,eAAS;IACb;AACA,WAAO,SAAS,OAAO;AACnB,MAAAA,QAAO,KAAK,IAAI;AAChB,eAAS;IACb;EACJ;;;AC1DO,MAAMC,mCAAO,MAAK;EAEzB;AAMM,WAAU,eAAe,MAAe;AAE1C,UAAM,IAAI,MAAM,8BAA8B,KAAK,KAAK,IAAI,CAAC;EACjE;;;ACPA,MAAM,EAAE,aAAa,cAAa,IAAK;AAAvC;AAWM,MAAO,MAAP,MAAU;IAGZ,YAAY,SAAyC;AAFrD;AAGI,UAAI,CAAC,SAAS,OAAO;AACjB,aAAK,IAAG;MACZ;IACJ;IAEA,MAAG;AAEC,yBAAK,aAAc,YAAY,MAAK;MAAE,GAAG,KAAK,GAAI;IACtD;IAEA,QAAK;AACD,UAAI,mBAAK,cAAa;AAClB,sBAAc,mBAAK,YAAW;AAC9B,2BAAK,aAAc;MACvB;IACJ;;AAlBA;;;ACjBE,WAAU,cAAc,GAAe,GAAa;AACtD,QAAI,EAAE,WAAW,EAAE,QAAQ;AACvB,aAAO;IACX;AAEA,aAAS,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK,GAAG;AAClC,UAAI,EAAE,CAAC,MAAM,EAAE,CAAC,GAAG;AACf,eAAO;MACX;IACJ;AAEA,WAAO;EACX;;;ACYA,MAAM,2BAA2B,OAC7B;IACI,QAAQ,OAAO,CAAC;IAChB,SAAS,OAAO;MACZ,OAAO;MACP,QAAQ,OAAa;AACjB,eAAO,OAAO,SAAS,OAAO,EAAE;MACpC;MACA,KAAK,OAAK;AACN,eAAO,MAAM,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG;MAC7C;KACH;KAEL,EAAE,cAAc,KAAI,CAAE;AAGpB,MAAO,kBAAP,cAA+B,MAAK;IACtC,YAAY,SAAe;AACvB,YAAM,OAAO;IACjB;;AAGE,MAAO,8BAAP,cAA2C,gBAAe;IAC5D,cAAA;AACI,YACI,+EAA+E;IAEvF;;AAGG,MAAM,0BAA0B,OACnC,0BACA,CAAA,GACA;IACI,gBAAgB,OAAK;AAIjB,UAAI,MAAM,YAAY,iCAAiC;AACnD,cAAM,IAAI,4BAA2B;MACzC,OAAO;AACH,cAAM,IAAI,gBAAgB,MAAM,OAAO;MAC3C;IACJ;GACH;AAIL,WAAS,gBAAgBC,SAAkB;AACvC,QAAI,QAAQ;AACZ,eAAW,QAAQA,SAAQ;AAEvB,UAAI,OAAO,MAAM,OAAO,IAAI;AACxB,eAAO;MACX;AACA,cAAQ,QAAQ,KAAK,OAAO;IAChC;AACA,WAAO;EACX;AAEA,MAAM,OAAO,WAAW,MAAM;AApF9B;AAsFM,MAAO,oBAAP,cAAiC,eAAc;IAA/C;;AACO,uDAA+B,oBAAI,IAAG;;IAErC,MAAM,qBAAqB,SAAe;AAChD,YAAM,SAAS,MAAM,KAAK,IAAI,aAAa,OAAO;AAClD,aAAO,IAAI,uBAAuB,OAAO,QAAQ;IACrD;IAEU,MAAM,YAAY,SAAe;AACvC,YAAM,SAAS,MAAM,KAAK,qBAAqB,OAAO;AAEtD,YAAM,WAAW,MAAM,OAAO,YAAY,CAAC;AAC3C,UAAI,CAAC,cAAc,UAAU,IAAI,GAAG;AAChC,cAAM,wBAAwB,YAAY,MAAM;MACpD;AAEA,aAAO;IACX;;;;IAKA,MAAM,OAAI;AACN,YAAM,SAAS,MAAM,KAAK,qBAAqB,sBAAsB;AAErE,YAAM,WAAW,MAAM,yBAAyB,YAAY,MAAM;AAClE,aAAO,SAAS,QACX,MAAM,IAAI,EACV,OAAO,CAAC,SAAS,CAAC,CAAC,IAAI,EACvB,IAAI,CAAC,SAAQ;AACV,cAAM,CAAC,cAAc,WAAW,UAAU,IAAI,KAAK,MAC/C,GAAG;AAEP,eAAO,EAAE,cAAc,WAAW,WAAU;MAChD,CAAC;IAGT;;;;IAKA,MAAM,YAAY,eAAuB,cAAoB;AACzD,YAAM,SAAS,MAAM,KAAK,YACtB,mBAAmB,aAAa,IAAI,YAAY,EAAE;AAKtD,UAAI,cAAc,WAAW,MAAM,GAAG;AAClC,cAAM,WAAW,OAAO;AACxB,YAAI;AACA,gBAAM,SAAS,YAAY,MAAM,OAAO,YAAY,CAAC,CAAC;AACtD,gBAAM,OAAO,gBAAgB,MAAM,OAAO,YAAY,MAAM,CAAC;AAC7D,0BAAgB,OAAO,IAAI;QAC/B,SAAS,GAAG;AACR,cACI,aAAa,2BACb,OAAO,aAAa,UACtB;UAIF,OAAO;AACH,kBAAM;UACV;QACJ;MACJ;AAEA,aAAO;IACX;;;;IAKA,MAAM,IACF,eACA,SACA,cAAqB;AAErB,qBAAe,MAAM,KAAK,IAAI,UAAU,iBACpC,SACA,YAAY;AAGhB,UAAI;AACA,wBAAgB,MAAM,KAAK,YAAY,eAAe,YAAY;AAClE,2BAAK,8BAA6B,IAAI,eAAe,YAAY;AACjE,eAAO;MACX,SAAS,GAAG;AACR,cAAM,KAAK,IAAI,UAAU,oBAAoB,YAAY;AACzD,cAAM;MACV;IACJ;;;;IAKA,MAAM,OAAO,eAAqB;AAC9B,YAAM,eACF,mBAAK,8BAA6B,IAAI,aAAa;AACvD,UAAI,cAAc;AACd,cAAM,KAAK,IAAI,UAAU,oBAAoB,YAAY;MAC7D;AAEA,YAAM,KAAK,YAAY,uBAAuB,aAAa,EAAE;IAGjE;;;;IAKA,MAAM,YAAS;AACX,YAAM,KAAK,IAAI,UAAU,oBAAmB;AAC5C,yBAAK,8BAA6B,MAAK;AAEvC,YAAM,KAAK,YAAY,yBAAyB;IAGpD;;AAvHS;;;ACtFb;AAYM,MAAO,6BAAP,MAAiC;IAgBnC,YAAY,QAAmB,QAAoB;AAf1C;AAUA;AAML,yBAAK,SAAU;AAEf,UAAI,QAAQ;AAKR,cAAM,SAAS,IAAI,gBAAe;AAClC,2BAAK,SAAQ,OAAO,KAChB,MAAM,OAAO,QAAQ,MAAS,GAC9B,CAAC,MAAM,OAAO,OAAO,CAAC,CAAC;AAE3B,eAAO,iBAAiB,SAAS,MAAK;AAClC,iBAAO,OAAO,OAAO,MAAM;AAC3B,6BAAK,SAAQ,MAAK;QACtB,CAAC;AACD,2BAAK,SAAU,OAAO;MAC1B,OAAO;AACH,2BAAK,SAAU,mBAAK,SAAQ;MAChC;IACJ;IAlCA,IAAI,QAAK;AACL,aAAO,mBAAK,SAAQ;IACxB;IAEA,IAAI,SAAM;AACN,aAAO,mBAAK,SAAQ;IACxB;IAGA,IAAI,SAAM;AACN,aAAO,mBAAK;IAChB;IAyBA,OAAI;AACA,aAAO,mBAAK,SAAQ,MAAK;IAC7B;;AAxCS;AAUA;;;AClBb,MAAAC,UAAAC,UAAA;AAKM,MAAO,4BAAP,MAAgC;IAiBlC,YAAY,QAAiB;AAhBpB,yBAAAD;AACA,yBAAAC;AAEA;AAcL,yBAAKD,UAAU;AAEf,yBAAKC,UAAU,mBAAKD,UAAQ,SAAS,UAAS;AAC9C,yBAAK,QAAS,IAAI,yBAAgB,eAA2B;QACzD,OAAO,CAAC,UAAU,mBAAKC,UAAQ,MAAM,KAAK;OAC7C;IACL;IAnBA,IAAI,QAAK;AACL,aAAO,mBAAK;IAChB;IAEA,IAAI,SAAM;AACN,aAAO,mBAAKD,UAAQ;IACxB;IAEA,IAAI,SAAM;AACN,aAAO,mBAAKA,UAAQ;IACxB;IAWA,SAAM;AACF,aAAO,mBAAKC,UAAQ,MAAM,IAAI,WAAW,CAAC,CAAI,CAAC,CAAC;IACpD;IAEA,OAAI;AACA,aAAO,mBAAKD,UAAQ,MAAK;IAC7B;;AA/BS,EAAAA,WAAA;AACA,EAAAC,WAAA;AAEA;;;ACfP,WAAU,UAAU,GAAS;AAC/B,QAAI,SAAS;AACb,cAAU;AAEV,QAAI,OAAO;AACX,WAAO,MAAM;AACT,YAAM,QAAQ,EAAE,QAAQ,KAAK,IAAI;AACjC,UAAI,UAAU,IAAI;AACd,kBAAU,EAAE,UAAU,IAAI;AAC1B;MACJ;AACA,gBAAU,EAAE,UAAU,MAAM,KAAK;AAEjC,gBAAU,OAAO;AACjB,aAAO,QAAQ;IACnB;AAEA,cAAU;AACV,WAAO;EACX;AAEM,WAAU,aAAa,SAAe;AACxC,UAAM,SAAmB,CAAA;AACzB,QAAI;AACJ,QAAI,YAAY;AAChB,QAAI,QAAQ;AAEZ,aAAS,IAAI,GAAG,MAAM,QAAQ,QAAQ,IAAI,KAAK,KAAK,GAAG;AACnD,UAAI,WAAW;AACX,oBAAY;AACZ;MACJ;AAEA,YAAM,OAAO,QAAQ,OAAO,CAAC;AAC7B,cAAQ,MAAM;QACV,KAAK;AACD,cAAI,CAAC,SAAS,MAAM,OAAO;AACvB,mBAAO,KAAK,QAAQ,UAAU,OAAO,CAAC,CAAC;AACvC,oBAAQ,IAAI;UAChB;AACA;QACJ,KAAK;QACL,KAAK;AACD,cAAI,CAAC,OAAO;AACR,oBAAQ;UACZ,WAAW,SAAS,OAAO;AACvB,oBAAQ;UACZ;AACA;QACJ,KAAK;AACD,sBAAY;AACZ;MACR;IACJ;AAEA,QAAI,QAAQ,QAAQ,QAAQ;AACxB,aAAO,KAAK,QAAQ,UAAU,KAAK,CAAC;IACxC;AAEA,WAAO;EACX;;;ACrDA;AAqBM,MAAO,yBAAP,MAA6B;IAM/B,YACI,OAGoC;AAT/B;AAWL,yBAAK,QAAS;IAClB;IAEA,MACI,SACA,QAAoB;AAEpB,cAAQ,eAAc;AAEtB,UAAI,OAAO,YAAY,UAAU;AAC7B,kBAAU,aAAa,OAAO;MAClC;AAEA,aAAO,mBAAK,QAAL,WAAY,SAAS;IAChC;IAEA,MAAM,UAAU,SAAmC;AAC/C,YAAM,UAAU,MAAM,KAAK,MAAM,OAAO;AACxC,aAAO,MAAM,QAAQ,OAAO,YAAY,IAAI,mBAAkB,CAAE;IACpE;IAEA,MAAM,cAAc,SAAmC;AACnD,YAAM,UAAU,MAAM,KAAK,MAAM,OAAO;AACxC,aAAO,MAAM,QAAQ,OAChB,YAAY,IAAI,kBAAiB,CAAE,EACnC,YAAY,IAAI,mBAAkB,CAAE;IAC7C;;AArCS;;;AC3Bb,MAAAC;AAIM,MAAO,mCAAP,cAAgD,uBAAsB;IAMxE,YAAY,KAAQ;AAChB,YAAM,OAAO,SAAS,WAAU;AAG5B,cAAM,SAAS,MAAM,mBAAKA,OAAK,aAC3B,QAAQ,QAAQ,KAAK,GAAG,CAAC,EAAE;AAG/B,YAAI,QAAQ,SAAS;AACjB,gBAAM,OAAO,MAAK;AAClB,gBAAM,OAAO;QACjB;AAEA,eAAO,IAAI,2BAA2B,QAAQ,MAAM;MACxD,CAAC;AAnBI,yBAAAA;AAoBL,yBAAKA,OAAO;IAChB;IApBA,IAAI,MAAG;AACH,aAAO,mBAAKA;IAChB;IAoBA,MAAM,IACF,SAAoC;AAEpC,UAAI,YAAY,QAAW;AACvB,kBAAU;MACd,WAAW,MAAM,QAAQ,OAAO,GAAG;AAC/B,kBAAU,QAAQ,KAAK,GAAG;MAC9B;AAEA,aAAO,IAAI;;QAEP,MAAM,mBAAKA,OAAK,aAAa,SAAS,OAAiB,EAAE;MAAC;IAElE;;AApCS,EAAAA,QAAA;;;ACLN,MAAM,aAAa;IACtB,SAAS;IACT,KAAK;IACL,QAAQ;IACR,QAAQ;IACR,gBAAgB;IAChB,KAAK;IACL,SAAS;IACT,eAAe;IACf,YAAY;;;;ACRT,MAAM,qBAAqB;IAC9B,OAAO;IACP,QAAQ;IACR,QAAQ;IACR,MAAM;IACN,YAAY;IACZ,kBAAkB;;AAOf,MAAM,yBAAyB,OAClC;IACI,IAAI,GAAE;IACN,MAAM,OAAO,GAAG;KAEpB,EAAE,cAAc,KAAI,CAAE;;;ACpB1B,MAAAC,UAAAC,UAAA,0BAAAC;AAoBM,MAAO,8BAAP,MAAkC;IAwBpC,YAAY,QAAmB,QAAoB;AAvB1C,yBAAAF;AACA,yBAAAC;AAEA;AAKA;AAKA;AAKA,yBAAAC;AAML,yBAAKF,UAAU;AAEf,UAAI;AACJ,UAAI;AACJ,yBAAK,SAAU,IAAI,mBAA+B,CAAC,eAAc;AAC7D,2BAAmB;MACvB,CAAC;AACD,yBAAK,SAAU,IAAI,mBAA+B,CAAC,eAAc;AAC7D,2BAAmB;MACvB,CAAC;AAED,YAAM,SAAS,IAAI,gBAAe;AAClC,yBAAKE,UAAU,OAAO;AAEtB,aAAO,SACF,YAAY,IAAI,wBAAwB,sBAAsB,CAAC,EAC/D,OACG,IAAI,eAAuC;QACvC,OAAO,OAAO,UAAS;AACnB,kBAAQ,MAAM,IAAI;YACd,KAAK,mBAAmB;AACpB,qBAAO,QAAQ,MAAM,KAAK,CAAC,CAAE;AAC7B;YACJ,KAAK,mBAAmB;AACpB,oBAAM,iBAAiB,QAAQ,MAAM,IAAI;AACzC;YACJ,KAAK,mBAAmB;AACpB,oBAAM,iBAAiB,QAAQ,MAAM,IAAI;AACzC;YACJ;AAGI;UACR;QACJ;OACH,CAAC,EAEL,KACG,MAAK;AACD,yBAAiB,MAAK;AACtB,yBAAiB,MAAK;AAEtB,eAAO,OACH,IAAI,MAAM,mCAAmC,CAAC;MAEtD,GACA,CAAC,MAAK;AACF,yBAAiB,MAAM,CAAC;AACxB,yBAAiB,MAAM,CAAC;AAExB,eAAO,OAAO,CAAC;MACnB,CAAC;AAGT,UAAI,QAAQ;AAKR,eAAO,iBAAiB,SAAS,MAAK;AAClC,iBAAO,OAAO,OAAO,MAAM;AAC3B,6BAAKF,UAAQ,MAAK;QACtB,CAAC;MACL;AAEA,yBAAKC,UAAU,mBAAKD,UAAQ,SAAS,UAAS;AAC9C,yBAAK,QAAS,IAAI,yBAAgB,eAA2B;QACzD,OAAO,OAAO,UAAS;AACnB,gBAAM,mBAAKC,UAAQ,MACf,uBAAuB,UAAU;YAC7B,IAAI,mBAAmB;YACvB,MAAM;WACT,CAAC;QAEV;QACA,OAAO;;UAEH,mBAAKA,UAAQ,MACT,uBAAuB,UAAU;YAC7B,IAAI,mBAAmB;YACvB,MAAM;WACT,CAAC;;OAEb;IACL;IAxGA,IAAI,QAAK;AACL,aAAO,mBAAK;IAChB;IAGA,IAAI,SAAM;AACN,aAAO,mBAAK;IAChB;IAGA,IAAI,SAAM;AACN,aAAO,mBAAK;IAChB;IAGA,IAAI,SAAM;AACN,aAAO,mBAAKC;IAChB;IAyFA,OAAI;AACA,aAAO,mBAAKF,UAAQ,MAAK;IAC7B;;AAhHS,EAAAA,WAAA;AACA,EAAAC,WAAA;AAEA;AAKA;AAKA;AAKA,EAAAC,WAAA;;;ACxCb,MAAAC,UAAAC,UAAAC,SAAAC,UAAAC,UAAA;AAmBM,MAAO,6BAAP,MAAiC;IAmBnC,YAAY,QAAiB;AAnB3B;AACO,yBAAAJ;AACA,yBAAAC;AAEA,yBAAAC;AAKA,yBAAAC;AAKA,yBAAAC,UAAU,IAAI,gBAAe;AAMlC,yBAAKJ,UAAU;AAEf,UAAI;AACJ,yBAAKG,UAAU,IAAI,mBAA+B,CAAC,eAAc;AAC7D,2BAAmB;MACvB,CAAC;AAED,aAAO,SACF,YAAY,IAAI,wBAAwB,sBAAsB,CAAC,EAC/D,OACG,IAAI,eAAuC;QACvC,OAAO,OAAO,UAAS;AACnB,kBAAQ,MAAM,IAAI;YACd,KAAK,mBAAmB;AACpB,iCAAKC,UAAQ,QAAQ,MAAM,KAAK,CAAC,CAAE;AACnC;YACJ,KAAK,mBAAmB;AACpB,oBAAM,iBAAiB,QAAQ,MAAM,IAAI;AACzC;UACR;QACJ;OACH,CAAC,EAEL,KACG,MAAK;AACD,yBAAiB,MAAK;AAEtB,2BAAKA,UAAQ,OACT,IAAI,MAAM,mCAAmC,CAAC;MAEtD,GACA,CAAC,MAAK;AACF,yBAAiB,MAAM,CAAC;AAExB,2BAAKA,UAAQ,OAAO,CAAC;MACzB,CAAC;AAGT,yBAAKH,UAAU,mBAAKD,UAAQ,SAAS,UAAS;AAC9C,yBAAKE,SAAS,IAAI,yBAAgB,eAA2B;QACzD,OAAO,CAAC,UAAU,sBAAK,sDAAL,WAAiB;OACtC;IACL;IAzDA,IAAI,QAAK;AACL,aAAO,mBAAKA;IAChB;IAGA,IAAI,SAAM;AACN,aAAO,mBAAKC;IAChB;IAGA,IAAI,SAAM;AACN,aAAO,mBAAKC,UAAQ;IACxB;IAwDA,MAAM,OAAO,MAAc,MAAY;AACnC,YAAM,mBAAKH,UAAQ,MACf,uBAAuB,UAAU;QAC7B,IAAI,mBAAmB;;;;QAIvB,MAAM,WAAW,GAAG,IAAI,IAAI,IAAI,QAAQ;OAC3C,CAAC;IAEV;IAEA,SAAM;AACF,aAAO,sBAAK,sDAAL,WAAiB,IAAI,WAAW,CAAC,CAAI,CAAC;IACjD;IAEA,OAAI;AACA,aAAO,mBAAKD,UAAQ,MAAK;IAC7B;;AA1FS,EAAAA,WAAA;AACA,EAAAC,WAAA;AAEA,EAAAC,UAAA;AAKA,EAAAC,WAAA;AAKA,EAAAC,WAAA;AAdP;AAgEF,kBAAW,SAAC,OAAiB;AACzB,WAAO,mBAAKH,UAAQ,MAChB,uBAAuB,UAAU;MAC7B,IAAI,mBAAmB;MACvB,MAAM;KACT,CAAC;EAEV;;;ACnFJ,MAAAI;AAmBM,MAAO,0BAAP,MAA8B;IAMhC,YACI,OAGqC;AAThC,yBAAAA;AAWL,yBAAKA,SAAS;IAClB;IAEA,MACI,SACA,QAAoB;AAEpB,cAAQ,eAAc;AAEtB,UAAI,OAAO,YAAY,UAAU;AAC7B,kBAAU,aAAa,OAAO;MAClC;AAEA,aAAO,mBAAKA,SAAL,WAAY,SAAS;IAChC;IAEA,MAAM,UACF,SAAmC;AAEnC,YAAM,UAAU,MAAM,KAAK,MAAM,OAAO;AACxC,YAAM,CAAC,QAAQ,QAAQ,QAAQ,IAAI,MAAM,QAAQ,IAAI;QACjD,QAAQ,OAAO,YAAY,IAAI,mBAAkB,CAAE;QACnD,QAAQ,OAAO,YAAY,IAAI,mBAAkB,CAAE;QACnD,QAAQ;OACX;AACD,aAAO,EAAE,QAAQ,QAAQ,SAAQ;IACrC;IAEA,MAAM,cACF,SAAmC;AAEnC,YAAM,UAAU,MAAM,KAAK,MAAM,OAAO;AACxC,YAAM,CAAC,QAAQ,QAAQ,QAAQ,IAAI,MAAM,QAAQ,IAAI;QACjD,QAAQ,OACH,YAAY,IAAI,kBAAiB,CAAE,EACnC,YAAY,IAAI,mBAAkB,CAAE;QACzC,QAAQ,OACH,YAAY,IAAI,kBAAiB,CAAE,EACnC,YAAY,IAAI,mBAAkB,CAAE;QACzC,QAAQ;OACX;AACD,aAAO,EAAE,QAAQ,QAAQ,SAAQ;IACrC;;AArDS,EAAAA,UAAA;;;AC1Bb,MAAAC;AAMM,MAAO,oCAAP,cAAiD,wBAAuB;IAU1E,YAAY,KAAQ;AAChB,YAAM,OAAO,SAAS,WAAU;AAC5B,cAAM,SAAS,MAAM,mBAAKA,OAAK,aAC3B,gBAAgB,QAAQ,KAAK,GAAG,CAAC,EAAE;AAGvC,YAAI,QAAQ,SAAS;AACjB,gBAAM,OAAO,MAAK;AAClB,gBAAM,OAAO;QACjB;AAEA,eAAO,IAAI,4BAA4B,QAAQ,MAAM;MACzD,CAAC;AArBI,yBAAAA;AAsBL,yBAAKA,OAAO;IAChB;IAtBA,IAAI,MAAG;AACH,aAAO,mBAAKA;IAChB;IAEA,IAAI,cAAW;AACX,aAAO,mBAAKA,OAAK,cAAc,WAAW,OAAO;IACrD;IAkBA,MAAM,IAAI,SAGT;AACG,UAAI,UAAU;AAEd,UAAI,SAAS,cAAc;AACvB,mBAAW,WAAW,QAAQ;MAClC;AAEA,iBAAW;AAEX,UAAI,SAAS;AACT,YAAI,OAAO,QAAQ,YAAY,UAAU;AACrC,qBAAW,QAAQ;QACvB,WAAW,MAAM,QAAQ,QAAQ,OAAO,GAAG;AACvC,qBAAW,QAAQ,QAAQ,KAAK,GAAG;QACvC;MACJ;AAEA,aAAO,IAAI,2BACP,MAAM,mBAAKA,OAAK,aAAa,OAAO,CAAC;IAE7C;;AAhDS,EAAAA,QAAA;;;ACPb,MAAAC,OAAA;AAKM,MAAO,uBAAP,MAA2B;IAgB7B,YAAY,KAAQ;AAfX,yBAAAA;AAKA;AAKA;AAML,yBAAKA,OAAO;AAEZ,yBAAK,eAAgB,IAAI,iCAAiC,GAAG;AAE7D,UAAI,IAAI,cAAc,WAAW,OAAO,GAAG;AACvC,2BAAK,gBAAiB,IAAI,kCAAkC,GAAG;MACnE;IACJ;IAtBA,IAAI,MAAG;AACH,aAAO,mBAAKA;IAChB;IAGA,IAAI,eAAY;AACZ,aAAO,mBAAK;IAChB;IAGA,IAAI,gBAAa;AACb,aAAO,mBAAK;IAChB;;AAbS,EAAAA,QAAA;AAKA;AAKA;;;ACXb,WAAS,qBAAqB,OAAa;AACvC,UAAM,SAAS,IAAI,WAAW,MAAM,MAAM;AAC1C,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,GAAG;AACtC,aAAO,CAAC,IAAI,MAAM,WAAW,CAAC;IAClC;AACA,WAAO;EACX;;AASM,WAAU,gBAAgB,OAAa;AACzC,UAAMC,UAAS,qBAAqB,KAAK;AACzC,WAAO,sBAAsBA,SAAQ,CAAC;EAC1C;AAEO,MAAM,oBAAoB;IAC7B,OAAO,gCAAgB,MAAM;IAC7B,QAAQ,gCAAgB,MAAM;IAC9B,OAAO,gCAAgB,MAAM;IAC7B,MAAM,gCAAgB,MAAM;IAC5B,QAAQ,gCAAgB,MAAM;IAC9B,MAAM,gCAAgB,MAAM;IAC5B,MAAM,gCAAgB,MAAM;IAC5B,IAAI,gCAAgB,MAAM;IAC1B,MAAM,gCAAgB,MAAM;;AAG1B,MAAO,eAAP,cAA4B,MAAK;;AAEhC,MAAM,sBAAsB,OAC/B,EAAE,SAAS,OAAO,GAAG,EAAC,GACtB;IACI,cAAc;IACd,gBAAgB,OAAK;AACjB,YAAM,IAAI,aAAa,MAAM,OAAO;IACxC;GACH;AAGL,iBAAsB,oBAClB,QACA,IACA,MAA2B;AAE3B,QAAI,OAAO,OAAO,UAAU;AACxB,WAAK,gCAAgB,EAAE;IAC3B;AAEA,UAAMA,UAAS,MAAM,OAAO,YAAY,CAAC;AACzC,YAAQ,sBAAsBA,SAAQ,CAAC,GAAG;MACtC,KAAK,kBAAkB;AACnB,cAAM,oBAAoB,YAAY,MAAM;AAC5C,cAAM,IAAI,MAAM,aAAa;MACjC,KAAK;AACD,eAAO,MAAM,KAAK,YAAY,MAAM;MACxC;AACI,cAAM,IAAI,MACN,aAAa,EAAE,eAAe,WAAWA,OAAM,CAAC,GAAG;IAE/D;EACJ;AAEA,kBAAuB,qBACnB,QACA,IACA,MAA2B;AAE3B,QAAI,OAAO,OAAO,UAAU;AACxB,WAAK,gCAAgB,EAAE;IAC3B;AAEA,WAAO,MAAM;AACT,YAAMA,UAAS,MAAM,OAAO,YAAY,CAAC;AACzC,cAAQ,sBAAsBA,SAAQ,CAAC,GAAG;QACtC,KAAK,kBAAkB;AACnB,gBAAM,oBAAoB,YAAY,MAAM;AAC5C,sBAAW;QACf,KAAK,kBAAkB;AAKnB,gBAAM,OAAO,YAAY,KAAK,IAAI;AAClC;QACJ,KAAK;AACD,gBAAM,MAAM,KAAK,YAAY,MAAM;AACnC;QACJ;AACI,gBAAM,IAAI,MACN,aAAa,EAAE,SAAS,kBAAkB,IAAI,eAAe,WAAWA,OAAM,CAAC,GAAG;MAE9F;IACJ;EACJ;;;ACpGO,MAAM,mBAAmB;IAC5B,MAAM,gBAAgB,MAAM;IAC5B,QAAQ,gBAAgB,MAAM;IAC9B,MAAM,gBAAgB,MAAM;IAC5B,QAAQ,gBAAgB,MAAM;IAC9B,OAAO,gBAAgB,MAAM;IAC7B,MAAM,gBAAgB,MAAM;IAC5B,SAAS,gBAAgB,MAAM;IAC/B,MAAM,gBAAgB,MAAM;IAC5B,MAAM,gBAAgB,MAAM;IAC5B,SAAS,gBAAgB,MAAM;;AAG5B,MAAM,uBAAuB,OAChC,EAAE,IAAI,KAAK,KAAK,IAAG,GACnB,EAAE,cAAc,KAAI,CAAE;AAO1B,iBAAsB,oBAClB,UACA,IACA,OAAmC;AAEnC,QAAI,OAAO,OAAO,UAAU;AACxB,WAAK,gBAAgB,EAAE;IAC3B;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,YAAM,SAAS,MACX,qBAAqB,UAAU,EAAE,IAAI,KAAK,MAAK,CAAE,CAAC;AAEtD;IACJ;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,cAAQ,WAAW,KAAK;IAC5B;AAIA,UAAM,SAAS,MACX,qBAAqB,UAAU,EAAE,IAAI,KAAK,MAAM,OAAM,CAAE,CAAC;AAE7D,UAAM,SAAS,MAAM,KAAK;EAC9B;;;AC5CO,MAAM,gBAAgB;IACzB,WAAW;IACX,MAAM;IACN,MAAM;;AAkBH,MAAM,uBAAuB,OAChC,EAAE,MAAM,KAAK,MAAM,KAAK,OAAO,IAAG,GAClC;IACI,cAAc;IACd,OAAO;MACH,IAAI,OAAI;AACJ,eAAQ,KAAK,QAAQ;MACzB;MACA,IAAI,aAAU;AACV,eAAO,KAAK,OAAO;MACvB;;IAEJ,gBAAgB,OAAK;AACjB,UAAI,MAAM,SAAS,KAAK,MAAM,SAAS,KAAK,MAAM,UAAU,GAAG;AAC3D,cAAM,IAAI,MAAM,aAAa;MACjC;AACA,aAAO;IACX;GACH;AAKE,MAAM,uBAAuB;IAChC,SAAS;IACT,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,OAAO;IACP,OAAO;IACP,QAAQ;IACR,KAAK;IACL,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,cAAc;IACd,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,SAAS;IACT,WAAW;IACX,OAAO;IACP,OAAO;IACP,SAAS;;AAMb,MAAM,uBAAwC,uBAC1C,OAAO,YACH,OAAO,QAAQ,oBAAoB,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM;IACvD;IACA;GACH,CAAC,GACJ;AAEC,MAAM,sBAAsB,OAC/B;IACI,OAAO,IAAG;IACV,KAAK;IACL,KAAK;IACL,MAAM;IACN,OAAO;IACP,KAAK;IACL,KAAK;IACL,MAAM;IACN,OAAO;IACP,OAAO;IACP,OAAO;KAEX;IACI,cAAc;IACd,OAAO;MACH,IAAI,OAAI;AACJ,eAAQ,KAAK,QAAQ;MACzB;MACA,IAAI,aAAU;AACV,eAAO,KAAK,OAAO;MACvB;;IAEJ,gBAAgB,OAAK;AACjB,UAAI,MAAM,OAAO;AACb,cAAM,IAAI,MAAM,qBAAqB,MAAM,KAAK,CAAC;MACrD;AACA,aAAO;IACX;GACH;AAKL,iBAAsB,aAClB,QACA,MACA,IAAW;AAEX,UAAM,SAAS,MAAM,OAAO,KAAI;AAChC,QAAI;AACA,UAAI,IAAI;AACJ,cAAM,oBAAoB,QAAQ,iBAAiB,SAAS,IAAI;AAChE,eAAO,MAAM,oBACT,QACA,kBAAkB,QAClB,mBAAmB;MAE3B,OAAO;AACH,cAAM,oBAAoB,QAAQ,iBAAiB,OAAO,IAAI;AAC9D,cAAM,WAAW,MAAM,oBACnB,QACA,kBAAkB,OAClB,oBAAoB;AAExB,eAAO;UACH,MAAM,SAAS;;UAEf,MAAM,OAAO,SAAS,IAAI;UAC1B,OAAO,OAAO,SAAS,KAAK;UAC5B,IAAI,OAAI;AACJ,mBAAO,SAAS;UACpB;UACA,IAAI,aAAU;AACV,mBAAO,SAAS;UACpB;;MAER;IACJ;AACI,aAAO,QAAO;IAClB;EACJ;AAEA,iBAAsB,YAClB,QACA,MAAY;AAEZ,UAAM,SAAS,MAAM,OAAO,KAAI;AAChC,QAAI;AACA,YAAM,oBAAoB,QAAQ,iBAAiB,MAAM,IAAI;AAC7D,aAAO,MAAM,oBACT,QACA,kBAAkB,MAClB,mBAAmB;IAE3B;AACI,aAAO,QAAO;IAClB;EACJ;;;AC/JO,MAAM,uBAAuB,OAAO,sBAAsB;IAC7D,MAAM,OAAO,GAAG;GACnB;AAIM,MAAM,wBAAwB,OAAO,qBAAqB;IAC7D,MAAM,OAAO,GAAG;GACnB;AAID,kBAAuB,iBACnB,QACA,MAAY;AAEZ,UAAM,SAAS,MAAM,OAAO,KAAI;AAChC,QAAI;AACA,YAAM,oBAAoB,QAAQ,iBAAiB,QAAQ,IAAI;AAC/D,uBAAiB,QAAQ,qBACrB,QACA,kBAAkB,QAClB,qBAAqB,GACtB;AAIC,YAAI,KAAK,UAAU,qBAAqB,SAAS;AAC7C;QACJ;AACA,cAAM;MACV;IACJ;AACI,aAAO,QAAO;IAClB;EACJ;AAEA,kBAAuB,iBACnB,QACA,MAAY;AAEZ,UAAM,SAAS,MAAM,OAAO,KAAI;AAChC,QAAI;AACA,YAAM,oBAAoB,QAAQ,iBAAiB,MAAM,IAAI;AAC7D,uBAAiB,QAAQ,qBACrB,QACA,kBAAkB,OAClB,oBAAoB,GACrB;AACC,cAAM;MACV;IACJ;AACI,aAAO,QAAO;IAClB;EACJ;AAEA,kBAAuB,eACnB,QACA,MACA,IAAW;AAEX,QAAI,IAAI;AACJ,aAAO,iBAAiB,QAAQ,IAAI;IACxC,OAAO;AACH,uBAAiB,QAAQ,iBAAiB,QAAQ,IAAI,GAAG;AAGrD,cAAM;UACF,MAAM,KAAK;UACX,MAAM,OAAO,KAAK,IAAI;UACtB,OAAO,OAAO,KAAK,KAAK;UACxB,IAAI,OAAI;AACJ,mBAAO,KAAK;UAChB;UACA,IAAI,aAAU;AACV,mBAAO,KAAK;UAChB;UACA,MAAM,KAAK;;MAEnB;IACJ;EACJ;;;AC1FO,MAAM,sBAAsB,OAC/B,EAAE,MAAM,OAAO,GAAG,EAAC,GACnB,EAAE,cAAc,KAAI,CAAE;AAK1B,kBAAuB,qBACnB,QACA,MAAY;AAEZ,UAAM,SAAS,MAAM,OAAO,KAAI;AAChC,QAAI,OAAO;AACX,QAAI;AACA,YAAM,oBAAoB,QAAQ,iBAAiB,SAAS,IAAI;AAChE,uBAAiB,UAAU,qBACvB,QACA,kBAAkB,MAClB,mBAAmB,GACpB;AACC,cAAM,OAAO;MACjB;AACA,aAAO;IACX,SAAS,GAAG;AACR,aAAO;AACP,YAAM;IACV;AACI,UAAI,CAAC,MAAM;AAEP,yBAAiB,UAAU,qBACvB,QACA,kBAAkB,MAClB,mBAAmB,GACpB;AACC,eAAK;QACT;MACJ;AACA,aAAO,QAAO;IAClB;EACJ;AAEM,WAAU,YACZ,QACA,MAAY;AAEZ,WAAO,eAAe,KAAK,qBAAqB,QAAQ,IAAI,CAAC;EACjE;;;ACvCO,MAAM,2BAA2B,KAAK;AAYtC,MAAM,oBAAoB,OAC7B,EAAE,QAAQ,IAAG,GACb,EAAE,cAAc,KAAI,CAAE;AAG1B,iBAAe,aACX,QACA,MACA,YACA,OAAa;AAIb,UAAM,kBAAkB,IAAI,gBAAe;AAC3C,SAAK,YAAY,IAAI,mBAAmB,YAAY,IAAI,CAAC,EACpD,OACG,IAAI,yBAAgB,eAAe;MAC/B,MAAM,OAAK;AACP,eAAO,oBACH,QACA,iBAAiB,MACjB,KAAK;MAEb;KACH,GACD,EAAE,QAAQ,gBAAgB,OAAM,CAAE,EAErC,KAAK,YAAW;AACb,YAAM,oBAAoB,QAAQ,iBAAiB,MAAM,KAAK;AAC9D,YAAM,OAAO,MAAK;IACtB,GAAGC,KAAI;AAEX,UAAM,oBACF,QACA,kBAAkB,IAClB,iBAAiB,EACnB,MAAM,CAAC,MAAK;AACV,sBAAgB,MAAK;AACrB,YAAM;IACV,CAAC;EACL;AAEA,iBAAsB,cAAc,EAChC,QACA,UACA,MACA,OAAO,cAAc,MACrB,aAAa,KACb,QAAS,KAAK,IAAG,IAAK,MAAQ,GAC9B,aAAa,yBAAwB,GAClB;AACnB,UAAM,SAAS,MAAM,OAAO,KAAI;AAChC,QAAI;AACA,YAAM,OAAQ,QAAQ,KAAM;AAC5B,YAAM,cAAc,GAAG,QAAQ,IAAI,KAAK,SAAQ,CAAE;AAClD,YAAM,oBAAoB,QAAQ,iBAAiB,MAAM,WAAW;AACpE,YAAM,aAAa,QAAQ,MAAM,YAAY,KAAK;IACtD;AACI,aAAO,QAAO;IAClB;EACJ;AAEO,MAAM,qBAAqB;IAC9B,MAAM;IACN,QAAQ;;;;IAIR,KAAK,KAAK;;;;IAIV,MAAM,KAAK;IACX,QAAQ;;AAgBL,MAAM,uBAAuB,OAChC,EAAE,IAAI,KAAK,MAAM,KAAK,OAAO,IAAG,EAAsB,GACtD,EAAE,cAAc,KAAI,CAAE;AAG1B,iBAAsB,cAAc,EAChC,QACA,UACA,MACA,OAAO,cAAc,MACrB,aAAa,KACb,QAAS,KAAK,IAAG,IAAK,MAAQ,GAC9B,aAAa,0BACb,SAAS,MAAK,GACK;AACnB,UAAM,SAAS,MAAM,OAAO,KAAI;AAChC,QAAI;AACA,YAAM,oBAAoB,QAAQ,iBAAiB,QAAQ,QAAQ;AAEnE,YAAM,OAAQ,QAAQ,KAAM;AAC5B,UAAI,QAA4B,mBAAmB;AACnD,UAAI,QAAQ;AACR,iBAAS,mBAAmB;MAChC;AACA,YAAM,OAAO,MACT,qBAAqB,UAAU;QAC3B,IAAI,iBAAiB;QACrB;QACA;OACH,CAAC;AAGN,YAAM,aAAa,QAAQ,MAAM,YAAY,KAAK;IACtD;AACI,aAAO,QAAO;IAClB;EACJ;AASM,WAAU,YAAY,SAA2B;AACnD,QAAI,QAAQ,IAAI;AACZ,aAAO,cAAc,OAAO;IAChC;AAEA,QAAI,QAAQ,QAAQ;AAChB,YAAM,IAAI,MAAM,+BAA+B;IACnD;AAEA,WAAO,cAAc,OAAO;EAChC;;;ACvKA,MAAAC,UAAAC,YAAA;AAUM,MAAO,sBAAP,MAA0B;IAW5B,YACI,QACA,UACA,YACA,MAAoB;AAftB;AACO,yBAAAD;AACA,yBAAAC;AACA;AACA,qCAAa,IAAI,eAAc;AAC/B;AAYL,yBAAKD,UAAU;AACf,yBAAKC,YAAY;AACjB,yBAAK,aAAc;AACnB,yBAAK,WAAY,IAAI,eAAe,UAAU;IAClD;IAdA,IAAI,WAAQ;AACR,aAAO,mBAAKA,YAAU;IAC1B;IAmBA,MAAM,QAAK;AACP,UAAI;AACA,cAAM,mBAAK,YAAW,KAAI;AAC1B,cAAMC,UAAS,mBAAK,WAAU,MAAK;AACnC,YAAIA,SAAQ;AACR,gBAAM,sBAAK,0CAAL,WAAYA;QACtB;MACJ;AACI,2BAAK,YAAW,UAAS;MAC7B;IACJ;IAEA,MAAM,MAAM,MAAgB;AACxB,UAAI;AACA,cAAM,mBAAK,YAAW,KAAI;AAC1B,mBAAWA,WAAU,mBAAK,WAAU,KAAK,IAAI,GAAG;AAC5C,gBAAM,sBAAK,0CAAL,WAAYA;QACtB;MACJ;AACI,2BAAK,YAAW,UAAS;MAC7B;IACJ;IAEA,MAAM,YAAY,QAAc;AAG5B,YAAM,KAAK,MAAK;AAChB,aAAO,MAAM,mBAAKD,YAAU,YAAY,MAAM;IAClD;IAEA,UAAO;AAGH,yBAAK,WAAU,MAAK;AACpB,yBAAK,aAAY,UAAS;IAC9B;IAEA,MAAM,QAAK;AACP,YAAM,mBAAKA,YAAU,OAAM;IAC/B;;AAlES,EAAAD,WAAA;AACA,EAAAC,aAAA;AACA;AACA;AACA;AALP;AAuBF,aAAM,SAACC,SAAkB;AAErB,WAAO,WAAW,eAAe,MAAM,mBAAKF,WAASE,OAAM;EAC/D;AApCJ,aAAAC,UAAA;AAgFM,MAAO,gBAAP,MAAoB;IAKtB,YAAY,QAAmB,YAAkB;AAJxC,gCAAQ,IAAI,eAAc;AAC1B,yBAAAA;AACA;AAGL,yBAAKA,UAAU;AACf,yBAAK,SAAU,IAAI,oBACf,OAAO,SAAS,UAAS,GACzB,IAAI,uBAAuB,OAAO,QAAQ,GAC1C,YACA,mBAAK,MAAK;IAElB;IAEA,MAAM,OAAI;AACN,YAAM,mBAAK,OAAM,KAAI;AACrB,aAAO,mBAAK;IAChB;IAEA,MAAM,QAAK;AACP,YAAM,mBAAK,SAAQ,MAAK;AACxB,YAAM,mBAAKA,UAAQ,MAAK;IAC5B;;AAtBS;AACA,EAAAA,WAAA;AACA;;;ACnEP,WAAU,QAAQ,MAAY;AAChC,UAAM,MAAM,KAAK,YAAY,GAAG;AAChC,QAAI,QAAQ,IAAI;AACZ,YAAM,IAAI,MAAM,cAAc;IAClC;AACA,QAAI,QAAQ,GAAG;AACX,aAAO;IACX;AACA,WAAO,KAAK,UAAU,GAAG,GAAG;EAChC;AA1BA;AAqCM,MAAO,UAAP,MAAc;IA8BhB,YAAY,KAAU,QAAiB;AA7B7B;AACA;AAED;AACA;AACA;AACA;AACA;AAuBL,WAAK,OAAO;AACZ,WAAK,UAAU,IAAI,cAAc,QAAQ,IAAI,cAAc;AAE3D,yBAAK,eAAgB,IAAI,cAAc,WAAW,MAAM;AACxD,yBAAK,iBAAkB,IAAI,cAAc,WAAW,MAAM;AAC1D,yBAAK,iBAAkB,IAAI,cAAc,WAAW,cAAc;AAClE,yBAAK,wBAAyB,IAAI,cAC9B,WAAW,aAAa;AAG5B,yBAAK,0BACD,KAAK,KAAK,cAAc,WAAW,OAAO,KAAK,CAAC,KAAK;IAC7D;IAjCA,IAAI,eAAY;AACZ,aAAO,mBAAK;IAChB;IAEA,IAAI,iBAAc;AACd,aAAO,mBAAK;IAChB;IAEA,IAAI,iBAAc;AACd,aAAO,mBAAK;IAChB;IAEA,IAAI,wBAAqB;AACrB,aAAO,mBAAK;IAChB;IAEA,IAAI,0BAAuB;AACvB,aAAO,mBAAK;IAChB;;;;;;IAsBA,MAAM,MAAM,MAAY;AACpB,aAAO,MAAM,aAAa,KAAK,SAAS,MAAM,mBAAK,cAAa;IACpE;;;;;;IAOA,MAAM,KAAK,MAAY;AACnB,UAAI,CAAC,mBAAK,gBAAe;AACrB,cAAM,IAAI,MAAM,eAAe;MACnC;AAEA,aAAO,MAAM,YAAY,KAAK,SAAS,IAAI;IAC/C;;;;;;IAOA,MAAM,YAAY,MAAY;AAC1B,UAAI;AACA,cAAM,KAAK,MAAM,OAAO,GAAG;AAC3B,eAAO;MACX,QAAQ;AACJ,eAAO;MACX;IACJ;IAEA,QAAQ,MAAY;AAChB,aAAO,eAAe,KAAK,SAAS,MAAM,KAAK,cAAc;IACjE;IAEA,MAAM,QAAQ,MAAY;AACtB,YAAM,UAA0B,CAAA;AAChC,uBAAiB,SAAS,KAAK,QAAQ,IAAI,GAAG;AAC1C,gBAAQ,KAAK,KAAK;MACtB;AACA,aAAO;IACX;;;;;;;IAQA,KAAK,UAAgB;AACjB,aAAO,YAAY,KAAK,SAAS,QAAQ;IAC7C;;;;;;IAOA,MAAM,MAAM,SAA4B;AACpC,UAAI,KAAK,yBAAyB;AAI9B,cAAM,KAAK,KAAK,WAAW,aAAa,UAAU;UAC9C;UACA;UACA,UAAU,QAAQ,QAAQ,QAAQ,CAAC;SACtC;MACL;AAEA,YAAM,YAAY;QACd,IAAI,KAAK;QACT,QAAQ,KAAK;QACb,GAAG;OACN;IACL;IAEA,aAAU;AACN,aAAO,KAAK,QAAQ,KAAI;IAC5B;IAEA,UAAO;AACH,aAAO,KAAK,QAAQ,MAAK;IAC7B;;AAjIS;AACA;AACA;AACA;AACA;;;AC1Bb,WAAS,UAAU,OAAa;AAC5B,QAAI,CAAC,SAAS,UAAU,KAAK;AACzB,aAAO;IACX;AACA,WAAO,OAAO,SAAS,OAAO,EAAE;EACpC;AAEM,MAAO,kBAAP,cAA+B,eAAc;IAC/C,MAAM,qBAAkB;AACpB,YAAM,yBAAyB,MAAM,KAAK,IAAI,QAC1C,0BAA0B;AAE9B,YAAM,cAAc,MAAM,KAAK,IAAI,QAAQ,sBAAsB;AACjE,YAAM,cAAc,MAAM,KAAK,IAAI,QAAQ,sBAAsB;AAEjE,aAAO;QACH,wBACI,0BAA0B,KACpB,uBAAuB,MAAM,GAAG,IAChC,CAAA;QACV,aAAa,UAAU,WAAW;QAClC,aAAa,UAAU,WAAW;;IAE1C;IAEA,MAAM,QAAQ,MAAY;AACtB,UAAI,QAAQ,GAAG;AACX,cAAM,IAAI,UAAU,gBAAgB,IAAI,EAAE;MAC9C;AAEA,YAAM,SAAS,MAAM,KAAK,IAAI,oBAAoB,SAAS,IAAI,EAAE;AACjE,UAAI,WAAW,gCAAgC,IAAI;GAAM;AACrD,cAAM,IAAI,MAAM,MAAM;MAC1B;AACA,aAAO;IACX;IAEA,MAAM,UAAO;AACT,YAAM,SAAS,MAAM,KAAK,IAAI,oBAAoB,MAAM;AACxD,UAAI,WAAW,4BAA4B;AACvC,cAAM,IAAI,MAAM,MAAM;MAC1B;AACA,aAAO;IACX;;;;AC5DJ;AAyDM,MAAO,MAAP,MAAU;IAmCZ,YAAY,WAAuB;AAlC1B;AA6BA;AACA;AACA;AACA;AAGL,yBAAK,YAAa;AAElB,WAAK,aAAa,IAAI,qBAAqB,IAAI;AAC/C,WAAK,QAAQ,IAAI,SAAS,IAAI;AAC9B,WAAK,UAAU,IAAI,kBAAkB,IAAI;AACzC,WAAK,QAAQ,IAAI,gBAAgB,IAAI;IACzC;IAxCA,IAAI,YAAS;AACT,aAAO,mBAAK;IAChB;IAEA,IAAI,SAAM;AACN,aAAO,mBAAK,YAAW;IAC3B;IAEA,IAAI,iBAAc;AACd,aAAO,mBAAK,YAAW;IAC3B;IAEA,IAAI,SAAM;AACN,aAAO,mBAAK,YAAW;IAC3B;IAEA,IAAI,eAAY;AACZ,aAAO,mBAAK,YAAW;IAC3B;IAEA,IAAW,iBAAc;AACrB,aAAO,mBAAK,YAAW;IAC3B;IAEA,IAAW,iBAAc;AACrB,aAAO,KAAK,OAAO;IACvB;IAgBA,cAAc,SAAmB;AAC7B,aACI,KAAK,eAAe,SAAS,OAAO,KACpC,KAAK,eAAe,SAAS,OAAO;IAE5C;;;;IAKA,MAAM,aAAa,SAAe;AAC9B,aAAO,mBAAK,YAAW,QAAQ,OAAO;IAC1C;IAEA,MAAM,oBAAoB,SAAe;AACrC,YAAM,SAAS,MAAM,KAAK,aAAa,OAAO;AAC9C,aAAO,MAAM,OAAO,SACf,YAAY,IAAI,kBAAiB,CAAE,EACnC,YAAY,IAAI,mBAAkB,CAAE;IAC7C;IAEA,QAAQ,KAAW;AACf,aAAO,KAAK,WAAW,aAClB,cAAc,CAAC,WAAW,GAAG,CAAC,EAC9B,KAAK,CAAC,WAAW,OAAO,KAAI,CAAE;IACvC;IAEA,GACI,WACA,SAAkD;AAElD,YAAM,OAAO,CAAC,IAAI;AAClB,UAAI,SAAS,WAAW;AACpB,aAAK,KAAK,IAAI;MAClB;AACA,UAAI,SAAS,OAAO;AAChB,aAAK,KAAK,IAAI;MAClB;AACA,UAAI,MAAM,QAAQ,SAAS,GAAG;AAC1B,mBAAW,YAAY,WAAW;AAE9B,eAAK,KAAK,UAAU,QAAkB,CAAC;QAC3C;MACJ,OAAO;AAEH,aAAK,KAAK,UAAU,SAAmB,CAAC;MAC5C;AAEA,WAAK,KAAK,YAAY;AAEtB,aAAO,KAAK,WAAW,aAAa,cAAc,IAAI;IAC1D;IAEA,MAAM,OAAI;AACN,YAAM,SAAS,MAAM,KAAK,aAAa,OAAO;AAC9C,aAAO,IAAI,QAAQ,MAAM,MAAM;IACnC;IAEA,MAAM,cAAW;AACb,aAAO,YAAY,IAAI;IAC3B;IAEA,MAAM,QAAK;AACP,YAAM,mBAAK,YAAW,MAAK;IAC/B;;AA3GS;;;AC7DN,MAAM,eAAe;IACxB,SAAS;IACT,OAAO;IACP,QAAQ;IACR,UAAU;;AAJd;AASM,MAAO,aAAP,MAAO,WAAS;IA8DlB,YACI,SACA,OACA,QACA,UAA+B;AAxB1B;AAKA;AAKA;AAKA,oCAAmC,CAAA;AAWxC,yBAAK,UAAW;AAChB,yBAAK,QAAS;AACd,yBAAK,SAAU;AACf,yBAAK,WAAY;IACrB;IAvEA,OAAO,MAAM,QAAc;AACvB,UAAI;AACJ,UAAI;AACJ,UAAI;AACJ,UAAI,WAAyB,CAAA;AAE7B,YAAM,SAAS,OAAO,MAAM,IAAI;AAChC,UAAI,OAAO,SAAS,GAAG;AACnB,cAAM,QAAQ,OAAO,CAAC;AACtB,mBAAW,QAAQ,MAAM,MAAM,GAAG,GAAG;AAEjC,cAAI,CAAC,MAAM;AACP;UACJ;AAEA,gBAAM,WAAW,KAAK,MAAM,GAAG;AAC/B,cAAI,SAAS,WAAW,GAAG;AACvB;UACJ;AAEA,gBAAM,CAAC,KAAK,KAAK,IAAI;AACrB,kBAAQ,KAAK;YACT,KAAK,aAAa;AACd,wBAAU;AACV;YACJ,KAAK,aAAa;AACd,sBAAQ;AACR;YACJ,KAAK,aAAa;AACd,uBAAS;AACT;YACJ,KAAK,aAAa;AACd,yBAAW,MAAO,MAAM,GAAG;AAC3B;UACR;QACJ;MACJ;AAEA,aAAO,IAAI,WAAU,SAAS,OAAO,QAAQ,QAAQ;IACzD;IAGA,IAAI,UAAO;AACP,aAAO,mBAAK;IAChB;IAGA,IAAI,QAAK;AACL,aAAO,mBAAK;IAChB;IAGA,IAAI,SAAM;AACN,aAAO,mBAAK;IAChB;IAGA,IAAI,WAAQ;AACR,aAAO,mBAAK;IAChB;;AAlBS;AAKA;AAKA;AAKA;AAzDP,MAAO,YAAP;;;ACEA,WAAU,WACZ,OACA,YACA,QAAc;AAEd,QAAI,SAAS;AAKb,aAAS,IAAI,YAAY,IAAI,aAAa,QAAQ,KAAK,GAAG;AACtD,iBAAW;AACX,YAAM,QAAQ,mBAAmB,OAAO,CAAC;AACzC,gBAAU;IACd;AAEA,WAAO;EACX;AAYM,WAAU,WACZ,OACA,YACA,QACA,OACA,cAAsB;AAEtB,QAAI,cAAc;AACd,aAAO,QAAQ,IAAI;AACf,6BAAqB,OAAO,YAAY,KAAK;AAC7C,sBAAc;AACd,kBAAU;MACd;IACJ,OAAO;AACH,UAAI,WAAW,aAAa,SAAS;AACrC,aAAO,QAAQ,IAAI;AACf,0BAAkB,OAAO,UAAU,KAAK;AACxC,oBAAY;AACZ,kBAAU;MACd;IACJ;EACJ;AAuBA,MAAM,uBAAuB;AAC7B,MAAM,uBAAuB,OAAO;AACpC,MAAM,uBAAuB;AAC7B,MAAM,uBAAuB,OAAO;AAE9B,WAAU,mBAAmB,KAAe;AAC9C,UAAM,IAAI,WAAW,KAAK,sBAAsB,oBAAoB;AACpE,UAAM,IAAI,WAAW,KAAK,sBAAsB,oBAAoB;AACpE,WAAO,CAAC,GAAG,CAAC;EAChB;AAEA,WAAS,eAAe,GAAW,GAAS;AACxC,UAAM,IAAI,IAAI;AACd,QAAI,IAAI,GAAG;AACP,aAAO;IACX;AACA,WAAO,KAAK,IAAI,IAAI,IAAI,CAAC;EAC7B;AAOM,WAAU,WAAW,GAAW,GAAS;AAC3C,QAAI,eAAe,GAAG,CAAC;AACvB,QAAI,CAAC,KAAK,IAAI,GAAG;AACb,aAAO;IACX;AAEA,UAAM,IAAI,CAAA;AACV,QAAI,IAAI;AACR,WAAO,GAAG;AACN,OAAC,GAAG,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;AAClB,QAAE,KAAK,EAAE,GAAG,EAAC,CAAE;IACnB;AAEA,QAAI,MAAM,GAAG;AACT,aAAO;IACX;AAEA,QAAI,IAAI;AACR,QAAI,IAAI;AACR,aAAS,IAAI,EAAE,SAAS,GAAG,KAAK,GAAG,KAAK,GAAG;AACvC,OAAC,GAAG,CAAC,IAAI,CAAC,GAAG,IAAI,IAAI,KAAK,MAAM,EAAE,CAAC,EAAG,IAAI,EAAE,CAAC,EAAG,CAAC,CAAC;IACtD;AACA,WAAO,eAAe,GAAG,CAAC;EAC9B;AAEA,MAAM,uBAAuB,OAAO;AACpC,MAAM,uBAAuB,uBAAuB;AAE9C,WAAU,sBAAmB;AAC/B,WAAO,IAAI,IAAI,uBAAuB,uBAAuB;EACjE;AASM,WAAU,qBACZ,YACA,QAAmB;AAwBnB,QAAI;AACJ,UAAM,eAAe,oBAAmB;AACxC,QAAI,CAAC,QAAQ;AACT,eAAS,IAAI,WAAW,YAAY;AACpC,mBAAa;IACjB,OAAO;AACH,UAAI,OAAO,SAAS,cAAc;AAC9B,cAAM,IAAI,UAAU,4BAA4B;MACpD;AAEA,mBAAa;IACjB;AAEA,UAAM,aAAa,IAAI,SACnB,OAAO,QACP,OAAO,YACP,OAAO,MAAM;AAEjB,QAAI,eAAe;AAGnB,eAAW,UAAU,cAAc,sBAAsB,IAAI;AAC7D,oBAAgB;AAGhB,UAAM,CAAC,CAAC,IAAI,mBAAmB,UAAU;AAGzC,UAAM,QAAQ,CAAC,WAAW,OAAO,IAAI,MAAM,GAAG,GAAG,KAAK,EAAE;AACxD,eAAW,SAAS,cAAc,OAAO,IAAI;AAC7C,oBAAgB;AAGhB,eAAW,QAAQ,cAAc,sBAAsB,GAAG,IAAI;AAC9D,oBAAgB;AAGhB,UAAM,KAAK,MAAM,QAAQ;AACzB,eAAW,QAAQ,cAAc,sBAAsB,IAAI,IAAI;AAC/D,oBAAgB;AAGhB,eAAW,UAAU,cAAc,OAAO,IAAI;AAC9C,oBAAgB;AAEhB,QAAI,eAAe,cAAc;AAC7B,aAAO;IACX,OAAO;AACH,aAAO;IACX;EACJ;AASM,WAAU,OACZ,MACA,UACA,SAAe;AAEf,QAAI,YAAY,IAAI;AAChB,aAAO;IACX;AAEA,QAAI,IAAI;AACR,WAAO,OAAO;AAEd,WAAO,WAAW,IAAI;AAClB,UAAI,OAAO,QAAQ,GAAG,QAAQ,MAAM,IAAI;AACpC,YAAK,IAAI,OAAQ;MACrB;AAEA,aAAQ,OAAO,OAAQ;AACvB,mBAAa;IACjB;AAEA,WAAO;EACX;AAEO,MAAM,qBAAqB;AAE3B,MAAM,gBAAgB;AACtB,MAAM,oBAAoB;AAC1B,MAAM,YAAY;AAClB,MAAM,WAAW;AAGjB,MAAM,mBAAmB,IAAI,WAAW;IAC3C;IACA,KAAO;IACP;IACA;;IAEA;IACA;IACA,IAAI,KAAK;IACT;IACA;IACA;IACA;IACA;IACA;IACA;IACA;GACH;AAQK,WAAU,QACZ,YACA,MAAgB;AAEhB,UAAM,CAAC,GAAG,CAAC,IAAI,mBAAmB,UAAU;AAG5C,UAAM,SAAS,IAAI,WAAW,GAAG;AACjC,QAAI,QAAQ;AAEZ,WAAO,KAAK,IAAI;AAChB,aAAS;AAET,WAAO,KAAK,IAAI;AAChB,aAAS;AAET,UAAM,aACF,OAAO,SAAS,iBAAiB,SAAS,KAAK,SAAS;AAC5D,WAAO,QAAQ,YAAY;AACvB,aAAO,KAAK,IAAI;AAChB,eAAS;IACb;AAEA,WAAO,KAAK,IAAI;AAChB,aAAS;AAET,WAAO,IAAI,kBAAkB,KAAK;AAClC,aAAS,iBAAiB;AAE1B,WAAO,IAAI,MAAM,KAAK;AAItB,UAAM,YAAY,OAAO,WAAW,QAAQ,GAAG,OAAO,MAAM,GAAG,GAAG,CAAC;AAInE,eAAW,QAAQ,GAAG,OAAO,QAAQ,WAAW,KAAK;AAErD,WAAO;EACX;;;ACvUO,MAAM,aAAa;IACtB,MAAM;;IACN,OAAO;;IACP,SAAS;;IACT,MAAM;;IACN,MAAM;;IACN,OAAO;;;AAKJ,MAAM,kBAAkB,OAC3B;IACI,SAAS;IACT,MAAM;IACN,MAAM;IACN,eAAe;IACf,UAAU;IACV,OAAO;KAEX,EAAE,cAAc,KAAI,CAAE;AAOnB,MAAM,YAAY,OAAO,iBAAiB;IAC7C,SAAS,OAAO,eAAe;GAClC;AAqBK,WAAU,kBAAkB,SAAmB;AACjD,WAAO,QAAQ,OAAO,CAAC,QAAQ,SAAS,SAAS,MAAM,CAAC;EAC5D;AAEM,MAAO,2BAAP,cAAwC,gBAG7C;IACG,cAAA;AACI,YAAM,eAAe,IAAI,WAAW,gBAAgB,IAAI;AACxD,YAAM;QACF,WAAW,OAAO,OAAO,eAAc;AACnC,gBAAM,MAAM,WAAW,OAAOC,WAAS;AACnC,kBAAM,OAAOA;AACb,iBAAK,gBAAgB,KAAK,QAAQ;AAElC,4BAAgB,UAAU,MAAM,YAAY;AAC5C,kBAAM,WAAW,eAAe,QAC5B,YACA,YAAY;AAGhB,gBAAI,KAAK,eAAe;AAIpB,oBAAM,WAAW,eAAe,QAC5B,YACA,KAAK,OAAO;YAEpB;UACJ,CAAC;QACL;OACH;IACL;;;;AC3CG,MAAM,cAAc;IACvB,OAAO;IACP,WAAW;IACX,WAAW;;AAuBR,MAAM,4BAA8C,iBACvD,iBACA,gBAA4C;AAE5C,qBAAiB,OAAO,gBAAgB,YAAW,GAAI;AACnD,YAAM,SAAS,MAAM,eAAc;AAEnC,UAAI,OAAO,SAAS,YAAY,OAAO;AACnC;MACJ;AAEA,YAAM,YAAY,QAAQ,IAAI,QAAQ,OAAO,OAAO;AACpD,YAAM;QACF,SAAS,WAAW;QACpB,MAAM,YAAY;QAClB,MAAM;QACN,SAAS;;IAEjB;EACJ;AAEO,MAAM,4BAA8C,iBACvD,iBACA,gBAA4C;AAE5C,UAAM,SAAS,MAAM,eAAc;AAEnC,QAAI,OAAO,SAAS,YAAY,OAAO;AACnC;IACJ;AAEA,QAAI;AACJ,qBAAiB,OAAO,gBAAgB,YAAW,GAAI;AACnD,mBAAa;AACb;IACJ;AAEA,QAAI,CAAC,YAAY;AACb,mBAAa,MAAM,gBAAgB,YAAW;IAClD;AAEA,UAAM,kBAAkB,oBAAmB;AAC3C,UAAM,CAAC,qBAAqB,IACxB,6BAA6B,eAAe;AAEhD,UAAM,aAAa,WAAW,MAAM,SAC9B,WAAW,WAAW,IAAI,IAC1B;AACN,UAAM,kBAAkB,IAAI,WACxB,yBACK,WAAW,SAAS,WAAW,SAAS,IAAI;IAC7C,CAAC;AAGT,yBAAqB,WAAW,QAAQ,eAAe;AACvD,iBAAa,gBAAgB,SAAS,GAAG,eAAe,GAAG,eAAe;AAE1E,QAAI,WAAW,QAAQ;AACnB,sBAAgB,qBAAqB,IAAI;AACzC,sBAAgB,IAAI,YAAY,wBAAwB,CAAC;IAC7D;AAEA,UAAM;MACF,SAAS,WAAW;MACpB,MAAM,YAAY;MAClB,MAAM;MACN,SAAS;;EAEjB;AAEO,MAAM,6BAA0D;IACnE;IACA;;AA9IJ;AAiJM,MAAO,6BAAP,MAAiC;IAQnC,YACI,gBACA,iBAAmC;AAVrC;AACO;AAEA;AAET,0CAAkB,IAAI,gBAAe;AACrC;AAUA,0CAAkB,MAA6B;AAC3C,eAAO,mBAAK,iBAAgB;MAChC;AANI,WAAK,iBAAiB;AACtB,yBAAK,kBAAmB;IAC5B;IAyBA,MAAM,QAAQ,QAAqB;AAC/B,UAAI,CAAC,mBAAK,YAAW;AACjB,2BAAK,WAAY,sBAAK,+DAAL;MACrB;AAEA,yBAAK,iBAAgB,QAAQ,MAAM;AAEnC,YAAM,SAAS,MAAM,mBAAK,WAAU,KAAI;AACxC,UAAI,OAAO,MAAM;AACb,cAAM,IAAI,MAAM,yCAAyC;MAC7D;AAEA,aAAO,OAAO;IAClB;IAEA,UAAO;AACH,WAAK,mBAAK,YAAW,SAAQ;IACjC;;AArDS;AAET;AACA;AAUA;AAhBE;AAoBK,2BAAoB,mBAAA;AACvB,eAAW,iBAAiB,KAAK,gBAAgB;AAC7C,uBAAiB,UAAU,cACvB,mBAAK,mBACL,mBAAK,gBAAe,GACrB;AAGC,2BAAK,iBAAkB,IAAI,gBAAe;AAG1C,cAAM;MACV;IAIJ;EACJ;;;ACvLJ,mBAAAC,YAAAC,sBAAA,qBAAAC,UAAA,gBAAAC,UAAA;AAmCM,MAAO,4BAAP,MAAgC;IA0ClC,YAAY,SAA4B;AA1CtC;AAGO;AAEA;AACA;AACA;AACA;AAEA,yBAAAH;AACT,yBAAAC;AAKA;AACS;AAET,yBAAAC,UAAU;AAED,yCAAiB,IAAI,gBAAe;AAKpC,yBAAAC;AAKT;AASA;;;;;;;;+CAAuB;AAGnB,yBAAK,aAAc,QAAQ;AAC3B,WAAK,UAAU,QAAQ;AACvB,WAAK,WAAW,QAAQ;AACxB,WAAK,eAAe,QAAQ;AAC5B,WAAK,UAAU,QAAQ;AAEvB,yBAAKH,YAAY,IAAI,mBAAmB,CAAC,eAAc;AACnD,2BAAKC,sBAAsB;MAC/B,CAAC;AAED,WAAK,WAAW,IAAI,yBAAgB,eAA2B;QAC3D,OAAO,CAAC,eAAc;AAClB,6BAAK,qBAAsB;AAC3B,qBAAW,OAAO,iBAAiB,SAAS,MAAK;AAC7C,+BAAK,8BAA6B,OAC9B,WAAW,OAAO,MAAM;UAEhC,CAAC;QACL;QACA,OAAO,OAAO,SAAQ;AAClB,gBAAM,OAAO,KAAK;AAClB,gBAAM,YAAY,mBAAK,aAAY,QAAQ;AAC3C,mBACQ,QAAQ,GAAG,MAAM,WACrB,QAAQ,MACR,QAAQ,KAAK,OAAO,WACtB;AACE,kBAAM,QAAQ,KAAK,SAAS,OAAO,GAAG;AACtC,kBAAM,sBAAK,qDAAL,WAAiB;UAC3B;QACJ;OACH;AAED,yBAAKE,UAAU,IAAI,gBAAgB,IAAI;AACvC,yBAAK,sBAAuB,QAAQ;IACxC;IAlEA,IAAI,WAAQ;AACR,aAAO,mBAAKH;IAChB;IAQA,IAAI,SAAM;AACN,aAAO,mBAAK,gBAAe;IAC/B;IAGA,IAAI,SAAM;AACN,aAAO,mBAAKG;IAChB;IA2EA,MAAM,QAAQ,MAAgB;AAC1B,YAAM,mBAAKF,sBAAoB,QAAQ,IAAI;IAC/C;IAEO,IAAI,OAAa;AACpB,yBAAK,sBAAL,mBAAK,wBAAwB;AAC7B,yBAAK,8BAA6B,QAAO;IAC7C;IAEA,MAAM,QAAK;AACP,UAAI,mBAAKC,WAAS;AACd;MACJ;AACA,yBAAKA,UAAU;AAEf,yBAAK,8BAA6B,OAAO,IAAI,MAAM,eAAe,CAAC;AAEnE,UAAI;AACA,2BAAK,qBAAoB,MAAM,IAAI,MAAM,eAAe,CAAC;MAC7D,QAAQ;MAER;AAEA,YAAM,mBAAK,aAAY,WACnB,WAAW,OACX,KAAK,SACL,KAAK,UACL,eAAe;IAEvB;IAEA,UAAO;AACH,yBAAKD,sBAAoB,MAAK;AAC9B,yBAAK,gBAAe,QAAQ,MAAS;IACzC;;AAvIS;AAOA,EAAAD,aAAA;AACT,EAAAC,uBAAA;AAKA;AAGA,EAAAC,WAAA;AAES;AAKA,EAAAC,WAAA;AAKT;AASA;AAxCE;AAgFI,kBAAW,eAAC,MAAgB;AAC9B,UAAM,SAAS,KAAK;AACpB,WAAO,mBAAK,wBAAuB,QAAQ;AAGvC,YAAM,WAAW,IAAI,gBAAe;AACpC,yBAAK,6BAA8B;AACnC,YAAM,SAAS;IACnB;AAEA,QAAI,mBAAK,0BAAyB,UAAU;AACxC,yBAAK,sBAAuB;IAChC,OAAO;AACH,yBAAK,sBAAL,mBAAK,wBAAwB;IACjC;AAEA,UAAM,mBAAK,aAAY,WACnB,WAAW,OACX,KAAK,SACL,KAAK,UACL,IAAI;EAEZ;AAzIJ;AAmLM,MAAO,kBAAP,MAAsB;IA2BxB,YAAY,YAAqC;AA1BxC;AA2BL,yBAAK,aAAc;IACvB;IA1BA,IAAI,UAAO;AACP,aAAO,mBAAK,aAAY;IAC5B;IACA,IAAI,WAAQ;AACR,aAAO,mBAAK,aAAY;IAC5B;IACA,IAAI,eAAY;AACZ,aAAO,mBAAK,aAAY;IAC5B;IACA,IAAI,UAAO;AACP,aAAO,mBAAK,aAAY;IAC5B;IAEA,IAAI,WAAQ;AACR,aAAO,mBAAK,aAAY;IAC5B;IACA,IAAI,WAAQ;AACR,aAAO,mBAAK,aAAY;IAC5B;IAEA,IAAI,SAAM;AACN,aAAO,mBAAK,aAAY;IAC5B;IAMA,QAAK;AACD,aAAO,mBAAK,aAAY,MAAK;IACjC;;AAhCS;;;ACpLb,+BAAAC,UAAAC,UAAA;AA+FM,MAAO,sBAAP,MAA0B;IAyB5B,YACI,YAIA,SAAmC;AA9BrC;AAGO;;wCAAgB,IAAI,sBAAsB,CAAC;AAI3C;;;mCAAW,oBAAI,IAAG;AAElB,yBAAAD;AAEA;AAET,yBAAAC,UAAU;AACD,wCAAgB,IAAI,gBAAe;AAKnC,kDAA0B,oBAAI,IAAG;AAIjC,+CAAuB,IAAI,gBAAe;AAS/C,WAAK,UAAU;AAEf,UAAI,KAAK,QAAQ,yBAAyB,GAAG;AACzC,aAAK,QAAQ,yBAAyB;MAC1C;AAEA,iBAAW,SACN,OACG,IAAI,eAA8B;QAC9B,OAAO,OACH,QACA,eACA;AACA,kBAAQ,OAAO,SAAS;YACpB,KAAK,WAAW;AACZ,oBAAM,sBAAK,gDAAL,WAAkB;AACxB;YACJ,KAAK,WAAW;AACZ,oCAAK,+CAAL,WAAiB;AACjB;YACJ,KAAK,WAAW;AACZ,oBAAM,sBAAK,+CAAL,WAAiB;AACvB;YACJ,KAAK,WAAW;AAIZ,oCAAK,gDAAL,WAAkB,QAAQ,MAAM,CAAC,MAAK;AAClC,2BAAW,MAAM,CAAC;cACtB,CAAC;AACD;YACJ;AAKI,oBAAM,IAAI,MACN,oBAAoB,OAAO,QAAQ,SAC/B,EAAE,CACL,EAAE;UAEf;QACJ;OACH,GACD;QACI,eAAe,QAAQ,sBAAsB;QAC7C,QAAQ,mBAAK,sBAAqB;OACrC,EAEJ,KACG,MAAK;AACD,8BAAK,4CAAL;MACJ,GACA,CAAC,MAAK;AACF,YAAI,CAAC,mBAAKA,WAAS;AACf,6BAAK,eAAc,OAAO,CAAC;QAC/B;AACA,8BAAK,4CAAL;MACJ,CAAC;AAGT,yBAAKD,UAAU,WAAW,SAAS,UAAS;IAChD;IA/EA,IAAI,eAAY;AACZ,aAAO,mBAAK,eAAc;IAC9B;IA0RA,MAAM,aAAa,SAAe;AAC9B,UAAI,KAAK,QAAQ,2BAA2B;AACxC,mBAAW;MACf;AAEA,YAAM,CAAC,SAAS,WAAW,IACvB,mBAAK,eAAc,IAAG;AAC1B,YAAM,KAAK,WACP,WAAW,MACX,SACA,KAAK,QAAQ,wBACb,OAAO;AAIX,YAAM,EAAE,UAAU,oBAAmB,IAAK,MAAM;AAChD,YAAM,aAAa,IAAI,0BAA0B;QAC7C,YAAY;QACZ;QACA;QACA,cAAc;QACd;QACA;OACH;AACD,yBAAK,UAAS,IAAI,SAAS,UAAU;AAErC,aAAO,WAAW;IACtB;IAEA,iBAAiB,SAAiB,SAAiC;AAC/D,yBAAK,yBAAwB,IAAI,SAAS,OAAO;IACrD;IAEA,oBAAoB,SAAe;AAC/B,yBAAK,yBAAwB,OAAO,OAAO;IAC/C;IAEA,sBAAmB;AACf,yBAAK,yBAAwB,MAAK;IACtC;IAEA,MAAM,WACF,SACA,MACA,MAEA,SAA4B;AAE5B,UAAI,OAAO,YAAY,UAAU;AAC7B,kBAAU,WAAW,OAAO;MAChC;AAEA,UAAI,QAAQ,SAAS,KAAK,QAAQ,gBAAgB;AAC9C,cAAM,IAAI,UAAU,mBAAmB;MAC3C;AAEA,YAAM,WAAW,eAAe,MAAM,mBAAKA,WAAS;QAChD;QACA;QACA;QACA;QACA,UAAU,KAAK,QAAQ,oBACjB,kBAAkB,OAAO,IACzB;QACN,OAAO,UAAU;OACpB;IACL;IAEA,MAAM,QAAK;AAEP,YAAM,QAAQ,IACV,MAAM,KAAK,mBAAK,UAAS,OAAM,GAAI,CAAC,WAAW,OAAO,MAAK,CAAE,CAAC;AAMlE,yBAAKC,UAAU;AAEf,yBAAK,sBAAqB,MAAK;AAC/B,UAAI,KAAK,QAAQ,oBAAoB;AACjC,2BAAKD,UAAQ,YAAW;MAC5B,OAAO;AACH,cAAM,mBAAKA,UAAQ,MAAK;MAC5B;IAGJ;;AA/XS;AAIA;AAEA,EAAAA,WAAA;AAIT,EAAAC,WAAA;AACS;AAKA;AAIA;AAvBP;AAgGI,mBAAY,eAAC,QAAqB;AAEpC,QACI,OAAO,SAAS,KAChB,mBAAK,eAAc,OACf,OAAO,MACP,IAAI,MAAM,oBAAoB,CAAC,GAErC;AAME;IACJ;AAUA,UAAM,SAAS,mBAAK,UAAS,IAAI,OAAO,IAAI;AAC5C,QAAI,QAAQ;AACR,YAAM,OAAO,MAAK;AAClB,aAAO,QAAO;AACd,yBAAK,UAAS,OAAO,OAAO,IAAI;AAChC;IACJ;EAKJ;AAEA,kBAAW,SAAC,QAAqB;AAC7B,QAAI;AACJ,QAAI,KAAK,QAAQ,2BAA2B,GAAG;AAC3C,UAAI,OAAO,QAAQ,WAAW,GAAG;AAC7B,cAAM,IAAI,MACN,+CAA+C;MAEvD;AACA,iBAAW,sBAAsB,OAAO,SAAS,CAAC;IACtD,OAAO;AACH,UAAI,OAAO,QAAQ,WAAW,GAAG;AAC7B,cAAM,IAAI,MACN,+CAA+C;MAEvD;AACA,iBAAW;IACf;AAEA,QACI,mBAAK,eAAc,QAAQ,OAAO,MAAM;MACpC,UAAU,OAAO;MACjB,qBAAqB;KACG,GAC9B;AAEE;IACJ;AAEA,UAAM,SAAS,mBAAK,UAAS,IAAI,OAAO,IAAI;AAC5C,QAAI,QAAQ;AAKR,aAAO,IAAI,QAAQ;AACnB;IACJ;AAIA,SAAK,KAAK,WACN,WAAW,OACX,OAAO,MACP,OAAO,MACP,eAAe;EAEvB;AAEA,gBAAS,SAAC,SAAiB,UAAkB,UAAgB;AACzD,QAAI;AACJ,QAAI,KAAK,QAAQ,2BAA2B,GAAG;AAG3C,gBAAU,IAAI,WAAW,CAAC;AAC1B,4BAAsB,SAAS,GAAG,QAAQ;IAC9C,OAAO;AACH,gBAAU;IACd;AAEA,WAAO,KAAK,WAAW,WAAW,MAAM,SAAS,UAAU,OAAO;EACtE;AAEM,kBAAW,eAAC,QAAqB;AAInC,UAAM,CAAC,OAAO,IAAI,mBAAK,eAAc,IAAG;AACxC,uBAAK,eAAc,QAAQ,SAAS,MAAS;AAE7C,UAAM,WAAW,OAAO;AACxB,QAAI,sBAAsB,OAAO;AACjC,QAAI,UAAU,WAAW,OAAO,OAAO;AAEvC,QAAI,QAAQ,SAAS,IAAI,GAAG;AACxB,gBAAU,QAAQ,UAAU,GAAG,QAAQ,SAAS,CAAC;IACrD;AAGA,QAAI,KAAK,QAAQ,2BAA2B,GAAG;AAC3C,UAAI,wBAAwB,GAAG;AAC3B,cAAM,IAAI,MAAM,uCAAuC;MAC3D;AACA,4BAAsB;IAC1B,OAAO;AACH,UAAI,wBAAwB,GAAG;AAC3B,cAAM,IAAI,MACN,oDAAoD;MAE5D;IACJ;AAEA,UAAM,UAAU,mBAAK,yBAAwB,IAAI,OAAO;AACxD,QAAI,CAAC,SAAS;AACV,YAAM,KAAK,WACP,WAAW,OACX,GACA,UACA,eAAe;AAEnB;IACJ;AAEA,UAAM,aAAa,IAAI,0BAA0B;MAC7C,YAAY;MACZ;MACA;MACA,cAAc;MACd;MACA;KACH;AAED,QAAI;AACA,YAAM,QAAQ,WAAW,MAAM;AAC/B,yBAAK,UAAS,IAAI,SAAS,UAAU;AACrC,YAAM,sBAAK,6CAAL,WACF,SACA,UACA,KAAK,QAAQ;IAErB,QAAQ;AACJ,YAAM,KAAK,WACP,WAAW,OACX,GACA,UACA,eAAe;IAEvB;EACJ;AAEM,mBAAY,eAAC,QAAqB;AACpC,UAAM,SAAS,mBAAK,UAAS,IAAI,OAAO,IAAI;AAC5C,QAAI,CAAC,QAAQ;AACT,YAAM,IAAI,MAAM,4BAA4B,OAAO,IAAI,EAAE;IAC7D;AAEA,QAAI,UAAU;AAEd,UAAM,WAA4B;OAC7B,YAAW;AACR,cAAM,OAAO,QAAQ,OAAO,OAAO;AACnC,cAAM,sBAAK,6CAAL,WACF,OAAO,MACP,OAAO,MACP,OAAO,QAAQ;AAEnB,kBAAU;MACd,GAAE;;AAGN,QAAI,KAAK,QAAQ,eAAe;AAC5B,eAAS,MACJ,YAAW;AACR,cAAM,MAAM,KAAK,QAAQ,aAAc;AACvC,YAAI,CAAC,SAAS;AACV,gBAAM,IAAI,MACN,iBAAiB,OAAO,OAAO,sBAAsB,KAAK,QAAQ,aAAa,eAAe;QAEtG;MACJ,GAAE,CAAE;IAEZ;AAEA,UAAM,QAAQ,KAAK,QAAQ;EAC/B;AA2FA,eAAQ,WAAA;AACJ,eAAW,UAAU,mBAAK,UAAS,OAAM,GAAI;AACzC,aAAO,QAAO;IAClB;AAEA,uBAAK,eAAc,QAAO;EAC9B;;;AC9cG,MAAM,mCAAmC;AAGzC,MAAM,8BAA+C,uBACxD;IACI,WAAW;IACX,WAAW;IACX,WAAW;IACX,WAAW;IACX,WAAW;IACX;IACA,WAAW;;;IAGX;IACA,WAAW;IACX;IACA;IACA,WAAW;IACX;IACA;IACA;IACA;IACA,WAAW;KACY;AACxB,MAAM,0CAA0C,KAAK,OAAO;AAnDnE,mBAAAC,cAAA;AAyJM,MAAO,sBAAP,MAAO,oBAAkB;IAqK3B,YAAY,EACR,QACA,YACA,SACA,QACA,WAAW,6BACX,wBACA,GAAG,QAAO,GACgC;AA3C9C;AAKS,yBAAAA;AAET;AAKA;AASA;AASA;AAcI,yBAAK,SAAU;AACf,yBAAK,aAAc;AACnB,yBAAK,SAAU,UAAU,MAAM,MAAM;AACrC,yBAAK,iBAAkB;AAEvB,UAAI,SAAS,SAAS,WAAW,UAAU,GAAG;AAC1C,YAAI,0BAA0B,GAAG;AAC7B,gBAAM,IAAI,UACN,qFAAqF;QAE7F;AAEA,YAAI,CAAC,mBAAK,SAAQ,SAAS,SAAS,WAAW,UAAU,GAAG;AACxD,mCAAyB;QAC7B;MACJ,OAAO;AACH,iCAAyB;MAC7B;AAEA,UAAIC;AACJ,UAAI;AACJ,UAAI,WAAW,kCAAkC;AAC7C,QAAAA,qBAAoB;AACpB,oCAA4B;MAChC,OAAO;AACH,QAAAA,qBAAoB;AACpB,oCAA4B;MAChC;AAEA,yBAAKD,cAAc,IAAI,oBAAoB,YAAY;QACnD,mBAAAC;QACA;QACA;QACA,GAAG;OACN;AAED,yBAAK,kBAAmB;IAC5B;;;;IA/MA,aAAa,aAAa,EACtB,QACA,YACA,iBACA,iBAAiB,4BACjB,WAAW,6BACX,yBAAyB,yCACzB,GAAG,QAAO,GACmB;AAE7B,UAAI,UAAU;AAEd,UAAI,iBAAiB,OAAO;AAE5B,YAAM,WAAW,IAAI,gBAAe;AACpC,YAAM,gBAAgB,IAAI,2BACtB,gBACA,eAAe;AAKnB,YAAM,kBAAkB,IAAI,gBAAe;AAC3C,YAAM,OAAO,WAAW,SACnB,OACG,IAAI,eAAe;QACf,MAAM,MAAM,QAAM;AACd,kBAAQ,OAAO,SAAS;YACpB,KAAK,WAAW;AACZ,wBAAU,KAAK,IAAI,SAAS,OAAO,IAAI;AACvC,+BAAiB,KAAK,IAClB,gBACA,OAAO,IAAI;AAEf,uBAAS,QAAQ,WAAW,OAAO,OAAO,CAAC;AAC3C;YACJ,KAAK,WAAW,MAAM;AAClB,oBAAM,WACF,MAAM,cAAc,QAAQ,MAAM;AACtC,oBAAM,WAAW,QAAQ;AACzB;YACJ;YACA;AAMI;UACR;QACJ;OACH,GACD;;QAEI,eAAe;QACf,QAAQ,gBAAgB;OAC3B,EAEJ,KACG,MAAK;AAED,iBAAS,OACL,IAAI,MAAM,gCAAgC,CAAC;MAEnD,GACA,CAAC,MAAK;AACF,iBAAS,OAAO,CAAC;MACrB,CAAC;AAGT,YAAM,SAAS,WAAW,SAAS,UAAS;AAC5C,qBAAe,WAAW,MAAmB;AAGxC,aAAuB,WAAW,kBAAkB,KAAK,OAAO;AAChE,aAAuB,QAAQ,KAAK,UAAU;AAC/C,cAAM,WAAW,eAAe,MAC5B,QACA,IAAqB;MAE7B;AAEA,YAAM,iBAAiB,SAAS,MAAK;AACrC,UAAI,0BAA0B,GAAG;AAC7B,cAAM,QAAQ,SAAS,QAAQ,WAAW,UAAU;AACpD,YAAI,UAAU,IAAI;AACd,yBAAe,OAAO,OAAO,CAAC;QAClC;MACJ;AAEA,UAAI;AACJ,UAAI;AACA,cAAM,WAAW;UACb,SAAS,WAAW;UACpB,MAAM;UACN,MAAM;;;UAGN,SAAS,WACL,kBAAkB,eAAe,KAAK,GAAG,CAAC,EAAE;SAEnD;AAED,iBAAS,MAAM,SAAS;MAC5B;AAGI,wBAAgB,MAAK;AACrB,eAAO,YAAW;AAGlB,cAAM;MACV;AAEA,aAAO,IAAI,oBAAmB;QAC1B;QACA;QACA;QACA;QACA;QACA,UAAU;QACV;QACA,GAAG;OACN;IACL;IAGA,IAAI,aAAU;AACV,aAAO,mBAAK;IAChB;IAKA,IAAI,SAAM;AACN,aAAO,mBAAK;IAChB;IAGA,IAAI,kBAAe;AACf,aAAO,mBAAK;IAChB;IAEA,IAAI,iBAAc;AACd,aAAO,mBAAKD,cAAY,QAAQ;IACpC;IAGA,IAAI,SAAM;AACN,aAAO,mBAAK;IAChB;IAEA,IAAI,eAAY;AACZ,aAAO,mBAAKA,cAAY;IAC5B;IAGA,IAAI,iBAAc;AACd,aAAO,mBAAK;IAChB;IAkDA,QAAQ,SAAe;AACnB,aAAO,mBAAKA,cAAY,aAAa,OAAO;IAChD;IAEA,iBACI,SACA,SAAgB;AAEhB,UAAI,CAAC,SAAS;AACV,cAAM,KAAK,KAAK,OAAM,EAAG,SAAQ,EAAG,UAAU,CAAC;AAC/C,kBAAU,yBAAyB,EAAE;MACzC;AACA,yBAAKA,cAAY,iBAAiB,SAAS,OAAO;AAClD,aAAO;IACX;IAEA,oBAAoB,SAAe;AAC/B,yBAAKA,cAAY,oBAAoB,OAAO;IAChD;IAEA,sBAAmB;AACf,yBAAKA,cAAY,oBAAmB;IACxC;IAEA,QAAK;AACD,aAAO,mBAAKA,cAAY,MAAK;IACjC;;AA7GA;AAKS,EAAAA,eAAA;AAET;AAKA;AASA;AASA;AAhKE,MAAO,qBAAP;;;AC1JN;AAIM,MAAO,eAAP,MAAmB;IAGrB,YAAY,QAAuB;AAF1B;AAGL,yBAAK,SAAU;IACnB;IAEA,MAAM,QAAK;AACP,YAAM,aACF,MAAM,mBAAK,SAAQ,iBAAiB,iBAAiB;AACzD,UAAI;AACA,cAAM,WAAW,MAAM,WAAW,WAAU;AAC5C,eAAO,CAAC,SAAS,WAAW,QAAQ;MACxC;AACI,cAAM,WAAW,QAAO;MAC5B;IACJ;IAEA,MAAM,cAAW;AACb,YAAM,aACF,MAAM,mBAAK,SAAQ,iBAAiB,oBAAoB;AAC5D,UAAI;AACA,cAAM,WAAW,MAAM,WAAW,WAAU;AAC5C,eAAO,SACF,MAAM,IAAI,EACV,OAAO,OAAO,EACd,IAAI,CAAC,SAAQ;AACV,gBAAM,QAAQ,KAAK,MAAM,GAAI;AAC7B,iBAAO;YACH,MAAM,MAAM,CAAC;YACb,SAAS,MAAM,CAAC;YAChB,SAAS,MAAM,CAAC;;QAExB,CAAC;MACT;AACI,cAAM,WAAW,QAAO;MAC5B;IACJ;;AApCS;;;ACab,MAAME,QAAO,WAAW,MAAM;AACvB,MAAM,OAAO,WAAW,MAAM;AAjBrC,MAAAC,cAAAC,YAAAC;AAmBM,MAAO,kBAAP,MAAsB;IAKxB,YAAY,YAA4C;AAJxD,yBAAAF;AACA,yBAAAC;AACA,yBAAAC;AAYA,wCAAa,QAAQ,WAAkC,MAAI;AACvD,cAAM,OAAO,OAAO,KAAK,KAAK,YAAY,CAAC,CAAC;AAC5C,cAAM,SAAS,YAAY,IAAI;AAC/B,YAAI,WAAW,GAAG;AACd,iBAAO;QACX,OAAO;AACH,gBAAM,UAAU,IAAI,YAAW;AAC/B,cAAI,SAAS;AACb,gBAAM,WAAW,mBAAKD,YAAU,eAAe,MAAM;AACrD,iBAAO,MAAM;AACT,kBAAM,EAAE,MAAM,MAAK,IAAK,SAAS,KAAI;AACrC,gBAAI,MAAM;AACN;YACJ;AACA,sBAAU,QAAQ,OAAO,OAAO,KAAK,KAAK,GAAG,EAAE,QAAQ,KAAI,CAAE;UACjE;AACA,oBAAU,QAAQ,OAAM;AACxB,iBAAO;QACX;MACJ,CAAC;AA5BG,yBAAKD,cAAc;AACnB,yBAAKC,YAAY,IAAI,uBAAuB,WAAW,QAAQ;AAC/D,yBAAKC,UAAU,WAAW,SAAS,UAAS;IAChD;IAEA,YAAY,QAAc;AACtB,aAAO,mBAAKD,YAAU,YAAY,MAAM;IAC5C;IAuBA,MAAM,WAAQ;AACV,YAAM,WAAW,MAAM,KAAK,YAAY,CAAC;AACzC,UAAI,cAAc,UAAUF,KAAI,GAAG;AAI/B;MACJ;AAEA,UAAI,cAAc,UAAU,IAAI,GAAG;AAC/B,cAAM,SAAS,MAAM,KAAK,WAAU;AACpC,cAAM,IAAI,MAAM,MAAM;MAC1B;AAEA,YAAM,IAAI,MAAM,wBAAwB,WAAW,QAAQ,CAAC,EAAE;IAClE;IAEA,MAAM,YAAY,OAAa;AAG3B,YAAM,UAAU,WAAW,KAAK;AAChC,YAAMI,UAAS,IAAI,WAAW,IAAI,QAAQ,MAAM;AAChD,sBAAgBA,SAAQ,GAAG,QAAQ,MAAM;AACzC,MAAAA,QAAO,IAAI,SAAS,CAAC;AACrB,YAAM,mBAAKD,UAAQ,MAAMC,OAAM;IACnC;IAEA,UAAO;AACH,yBAAKD,UAAQ,YAAW;AACxB,aAAO;QACH,UAAU,mBAAKD,YAAU,QAAO;QAChC,UAAU,mBAAKD,cAAY;QAC3B,QAAQ,mBAAKA,cAAY;QACzB,OAAO,MAAM,mBAAKA,cAAY,MAAK;;IAE3C;IAEA,MAAM,UAAO;AACT,WAAK,UAAU,mBAAKC,WAAS;AAC7B,WAAK,SAAS,mBAAKC,SAAO;AAC1B,YAAM,mBAAKF,cAAY,MAAK;IAChC;;AA5EA,EAAAA,eAAA;AACA,EAAAC,aAAA;AACA,EAAAC,WAAA;;;AClBE,MAAO,eAAP,cAA4B,MAAK;IACnC,YAAY,SAAe;AACvB,YAAM,OAAO;AACb,WAAK,OAAO;IAChB;;AAGE,MAAO,oBAAP,cAAiC,MAAK;IACxC,YAAY,SAAe;AACvB,YAAM,OAAO;AACb,WAAK,OAAO;IAChB;;AAGE,MAAO,wBAAP,cAAqC,MAAK;IAC5C,YAAY,SAAe;AACvB,YAAM,OAAO;AACb,WAAK,OAAO;IAChB;;AAxBJ,MAAAE;AA2BM,MAAO,mBAAP,MAAuB;IAGzB,YAAY,QAAuB;AAF1B,yBAAAA;AAGL,yBAAKA,UAAU;IACnB;;;;IAKA,MAAM,KAAK,SAAiB,UAAgB;AACxC,YAAM,aAAa,MAAM,mBAAKA,UAAQ,iBAClC,aAAa,QAAQ,IAAI,OAAO,EAAE;AAEtC,UAAI;AACA,cAAM,WAAW,MAAM,WAAW,YAAY,CAAC;AAE/C,YAAI,cAAc,UAAU,IAAI,GAAG;AAC/B,gBAAM,IAAI,MAAM,MAAM,WAAW,WAAU,CAAE;QACjD;AACA,cAAM,SAAS,YAAY,QAAQ;AAEnC,cAAM,WAAW,YAAY,MAAM;MACvC;AACI,cAAM,WAAW,QAAO;MAC5B;IACJ;;;;IAKA,MAAM,QAAQ,SAAe;AACzB,YAAM,aAAa,MAAM,mBAAKA,UAAQ,iBAClC,gBAAgB,OAAO,EAAE;AAE7B,UAAI;AACA,cAAM,WAAW,MAAM,WAAW,WAAU;AAC5C,gBAAQ,UAAU;UACd,KAAK,wBAAwB,OAAO;AAChC,kBAAM,IAAI,sBAAsB,QAAQ;UAC5C,KAAK,wBAAwB,OAAO;;UACpC,KAAK,6BAA6B,OAAO;AACrC,kBAAM,IAAI,kBAAkB,QAAQ;UACxC,KAAK,gBAAgB,OAAO;AACxB;UACJ;AACI,kBAAM,IAAI,aAAa,QAAQ;QACvC;MACJ;AACI,cAAM,WAAW,QAAO;MAC5B;IACJ;;;;IAKA,MAAM,WAAW,SAAe;AAC5B,YAAM,aAAa,MAAM,mBAAKA,UAAQ,iBAClC,mBAAmB,OAAO,EAAE;AAEhC,UAAI;AACA,cAAM,WAAW,WAAU;MAC/B;AACI,cAAM,WAAW,QAAO;MAC5B;IACJ;;AAhES,EAAAA,WAAA;;;ACrBP,WAAU,gBAAmB,OAAY,OAAa;AACxD,QAAI,QAAQ,KAAK,SAAS,MAAM,QAAQ;AACpC;IACJ;AACA,UAAM,KAAK,IAAI,MAAM,MAAM,SAAS,CAAC;AACrC,UAAM,UAAU;EACpB;AAUA,WAAS,mBACL,SACA,QAAkD;AAElD,WAAO,QAAQ,OAAO,CAAC,WAAW,OAAO,SAAS,OAAO,KAAK,CAAC;EACnE;AA5BA,MAAAC,UAAA;AA8BM,MAAO,+BAAP,MAAmC;IAQrC,YAAY,QAAuB;AARjC;AACF,qCAA6C,CAAA;AAEpC,yBAAAA;AAET;AACA,qCAAyB,CAAA;AAGrB,yBAAKA,UAAU;IACnB;IA4FA,MAAM,eACF,SAA8C;AAE9C,eAAS,QAAQ,eAAc;AAE/B,UAAI,UAA6C,CAAA;AACjD,YAAM,cAAc,IAAI,aAAY;AAGpC,YAAM,iBAAiB,IAAI,aAAY;AAGvC,YAAM,eAAe,IAAI,mBAAkB;AAG3C,YAAM,UAAU,IAAI,mBAAkB;AAEtC,YAAM,gBAAgB,SAAS,iBAAiB;QAC5C;QACA;;AAEJ,YAAM,WAAW;QACb;QACA;QACA;QACA;QACA;;AAIJ,yBAAK,YAAW,KAAK,QAAQ;AAG7B,mBAAa,MAAM,CAAC,UAAW,UAAU,KAAM;AAE/C,UAAI;AACJ,UAAI,CAAC,mBAAK,UAAS;AAEf,2BAAK,SAAU,sBAAK,qDAAL;AAEf,YAAI;AACA,mBAAS,MAAM,mBAAK;QACxB,SAAS,GAAG;AACR,6BAAK,SAAU;AACf,gBAAM;QACV;MACJ,OAAO;AACH,iBAAS,MAAM,mBAAK;AAEpB,qBAAa,KAAK,mBAAmB,KAAK,SAAS,aAAa,CAAC;MACrE;AAEA,YAAM,MAAM,IAAI,IAAI,OAAO;AAE3B,YAAM,OAAO,YAAW;AACpB,wBAAgB,mBAAK,aAAY,mBAAK,YAAW,QAAQ,QAAQ,CAAC;AAClE,cAAM,sBAAK,gEAAL,WAAyB;AAC/B,YAAI,MAAK;MACb;AAEA,UAAI,SAAS,QAAQ;AACjB,YAAI,QAAQ,OAAO,SAAS;AACxB,gBAAM,KAAI;AACV,gBAAM,QAAQ,OAAO;QACzB;AAEA,gBAAQ,OAAO,iBAAiB,SAAS,MAAM,KAAK,KAAI,CAAE;MAC9D;AAEA,aAAO;QACH,aAAa,YAAY;QACzB,gBAAgB,eAAe;QAC/B,cAAc,aAAa;QAC3B,SAAS,QAAQ;QACjB,IAAI,UAAO;AACP,iBAAO;QACX;QACA;;IAER;;AAlLS,EAAAA,WAAA;AAET;AACA;AANE;AAYI,eAAQ,eAAC,QAAuB;AAClC,UAAM,WAAW,MAAM,OAAO,WAAU;AACxC,UAAM,OAAO,gBAAgB,gBAAgB,QAAQ;AAErD,UAAM,UAAU,KAAK,QAAQ,MAAK;AAClC,UAAM,QAAkC,CAAA;AACxC,eAAW,cAAc,MAAM;AAC3B,YAAM,QAAQ,QAAQ,UAClB,CAAC,WAAW,OAAO,gBAAgB,WAAW,WAAW;AAG7D,UAAI,UAAU,IAAI;AACd,cAAM,KAAK,UAAU;AACrB;MACJ;AAEA,sBAAgB,SAAS,KAAK;IAClC;AAEA,SAAK,UAAU;AAEf,QAAI,MAAM,QAAQ;AACd,iBAAW,YAAY,mBAAK,aAAY;AACpC,cAAM,WAAW,mBACb,OACA,SAAS,aAAa;AAE1B,YAAI,SAAS,QAAQ;AACjB,mBAAS,YAAY,KAAK,QAAQ;QACtC;MACJ;IACJ;AACA,QAAI,QAAQ,QAAQ;AAChB,iBAAW,YAAY,mBAAK,aAAY;AACpC,cAAM,WAAW,mBACb,SACA,SAAS,aAAa;AAE1B,YAAI,SAAS,QAAQ;AACjB,mBAAS,eAAe,KAAK,OAAO;QACxC;MACJ;IACJ;AAEA,eAAW,YAAY,mBAAK,aAAY;AACpC,YAAM,WAAW,mBACb,KAAK,SACL,SAAS,aAAa;AAE1B,eAAS,aAAa,KAAK,QAAQ;IACvC;EACJ;AAEM,mBAAY,eAAC,QAAuB;AACtC,QAAI;AACA,aAAO,MAAM;AACT,cAAM,sBAAK,qDAAL,WAAc;MACxB;IACJ,SAAS,GAAG;AACR,yBAAK,SAAU;AAEf,iBAAW,YAAY,mBAAK,aAAY;AACpC,iBAAS,QAAQ,KAAK,CAAU;MACpC;IACJ;EACJ;AAEM,eAAQ,iBAAA;AACV,UAAM,SAAS,MAAM,mBAAKA,UAAQ;MAC9B;;MAEA,EAAE,OAAO,KAAI;IAAE;AAInB,UAAM,sBAAK,qDAAL,WAAc;AAGpB,SAAK,sBAAK,yDAAL,WAAkB;AAEvB,WAAO;EACX;AAEM,0BAAmB,eAAC,QAAuB;AAC7C,QAAI,mBAAK,YAAW,WAAW,GAAG;AAC9B,yBAAK,SAAU;AACf,YAAM,OAAO,QAAO;IACxB;EACJ;;;ACtHG,MAAM,8BAA+C,uBACxD;IACI,WAAW;IACX,WAAW;IACX,WAAW;IACX,WAAW;IACX,WAAW;IACX;IACA,WAAW;;;IAGX;IACA,WAAW;IACX;IACA;IACA,WAAW;IACX;IACA;IACA;IACA;KACuB;AAhC/B,MAAAC,UAAAC,WAAAC,UAAAC;AAkCM,MAAO,qBAAP,MAAyB;;IA0B3B,YACI,QACA,QACA,QACA,aACA,cAA2B;AA9B/B,yBAAAH;AAES;AAEA;AAEA,4CAAyB,IAAI,OAAO;AAEpC;AAET,yBAAAC,WAAwB,CAAA;AAExB,yBAAAC,UAAU,IAAI,gBAAe;AAC7B,yBAAAC;AAmBI,yBAAKH,UAAU;AACf,WAAK,SAAS;AACd,WAAK,SAAS;AACd,WAAK,cAAc;AAEnB,yBAAKG,gBAAgB,QAAQ,KAAK,CAAC,mBAAKD,UAAQ,SAAS,YAAY,CAAC;IAC1E;IAxBA,IAAI,eAAY;AACZ,aAAO,mBAAKC;IAChB;IAEA,IAAI,iBAAc;AAGd,aAAO;IACX;IAkBA,MAAM,QAAQ,SAAe;AACzB,YAAM,SAAS,MAAM,mBAAKH,UAAQ,uBAC9B,EAAE,aAAa,KAAK,YAAW,GAC/B,OAAO;AAEX,yBAAKC,WAAS,KAAK,MAAM;AACzB,aAAO;IACX;IAEA,MAAM,iBACF,SACA,SAAgB;AAEhB,aAAO,MAAM,mBAAKD,UAAQ,UAAU,iBAAiB,SAAS,OAAO;IACzE;IAEA,MAAM,oBAAoB,SAAe;AACrC,YAAM,mBAAKA,UAAQ,UAAU,oBAAoB,OAAO;IAC5D;IAEA,MAAM,sBAAmB;AACrB,YAAM,mBAAKA,UAAQ,UAAU,oBAAmB;IACpD;IAEA,MAAM,QAAK;AACP,iBAAW,UAAU,mBAAKC,YAAU;AAChC,cAAM,OAAO,MAAK;MACtB;AACA,yBAAKA,WAAS,SAAS;AACvB,yBAAKC,UAAQ,QAAO;IACxB;;AAtEA,EAAAF,WAAA;AAUA,EAAAC,YAAA;AAEA,EAAAC,WAAA;AACA,EAAAC,iBAAA;;;AChDJ;AAkCM,MAAO,mBAAP,MAAO,iBAAe;IA0FxB,YAAY,WAA0C;AA1FpD;AAoFO;AAEA,sCAAW,IAAI,iBAAiB,IAAI;AACpC,kCAAO,IAAI,aAAa,IAAI;AAC5B,yCAAiB,IAAI,6BAA6B,IAAI;AAG3D,WAAK,YAAY;IACrB;IAvFA,OAAO,gBACH,OACA,gBAA4D;MACxD;MACA;OACH;AAED,YAAM,UAAoC,CAAA;AAC1C,iBAAW,QAAQ,MAAM,MAAM,IAAI,GAAG;AAClC,YAAI,CAAC,MAAM;AACP;QACJ;AAEA,cAAM,QAAQ,KAAK,MAAM,GAAG,EAAE,OAAO,OAAO;AAC5C,cAAM,SAAS,MAAM,CAAC;AACtB,cAAM,QAAQ,MAAM,CAAC;AACrB,YAAI,CAAC,cAAc,SAAS,KAAK,GAAG;AAChC;QACJ;AAEA,YAAI;AACJ,YAAI;AACJ,YAAI;AACJ,YAAI;AACJ,iBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,GAAG;AACtC,gBAAM,CAAC,KAAKC,MAAK,IAAI,MAAM,CAAC,EAAG,MAAM,GAAG;AACxC,kBAAQ,KAAK;YACT,KAAK;AACD,wBAAUA;AACV;YACJ,KAAK;AACD,sBAAQA;AACR;YACJ,KAAK;AACD,uBAASA;AACT;YACJ,KAAK;AACD,4BAAc,OAAOA,MAAM;AAC3B;UACR;QACJ;AACA,YAAI,CAAC,aAAa;AACd,gBAAM,IAAI,MAAM,8BAA8B,MAAM,EAAE;QAC1D;AACA,gBAAQ,KAAK;UACT;UACA;UACA,gBAAgB,UAAU;UAC1B;UACA;UACA;UACA;SACH;MACL;AACA,aAAO;IACX;IAEA,OAAO,oBACH,QACA,SAAe;AAEf,UAAI,CAAC,QAAQ;AACT,eAAO,QAAQ,OAAO;MAC1B;AACA,UAAI,iBAAiB,QAAQ;AACzB,eAAO,qBAAqB,OAAO,WAAW,IAAI,OAAO;MAC7D;AACA,UAAI,YAAY,QAAQ;AACpB,eAAO,eAAe,OAAO,MAAM,IAAI,OAAO;MAClD;AACA,UAAI,SAAS,QAAQ;AACjB,eAAO,YAAY,OAAO;MAC9B;AACA,UAAI,SAAS,QAAQ;AACjB,eAAO,cAAc,OAAO;MAChC;AACA,YAAM,IAAI,UAAU,yBAAyB;IACjD;IAYA,MAAM,iBACF,SACA,SAAiD;AAEjD,YAAM,aAAa,MAAM,KAAK,UAAU,QAAQ,OAAO;AACvD,YAAM,SAAS,IAAI,gBAAgB,UAAU;AAE7C,UAAI;AACA,cAAM,OAAO,YAAY,OAAO;MACpC,SAAS,GAAG;AACR,cAAM,OAAO,QAAO;AACpB,cAAM;MACV;AAEA,UAAI;AAGA,cAAM,WAAW,MAAM,OAAO,SAAQ,GAAI,SAAS,MAAM;AACzD,eAAO;MACX,SAAS,GAAG;AACR,cAAM,OAAO,QAAO;AACpB,cAAM;MACV;IACJ;;;;IAKA,MAAM,aAAU;AACZ,YAAM,aAAa,MAAM,KAAK,iBAAiB,cAAc;AAC7D,UAAI;AACA,cAAM,SAAS,YAAY,MAAM,WAAW,YAAY,CAAC,CAAC;AAC1D,cAAM,UAAU,YAAY,MAAM,WAAW,YAAY,MAAM,CAAC;AAChE,eAAO;MACX;AACI,cAAM,WAAW,QAAO;MAC5B;IACJ;IAEA,MAAM,gBAAgB,gBAAsB;AACxC,YAAM,UAAU,MAAM,KAAK,WAAU;AACrC,UAAI,UAAU,gBAAgB;AAC1B,cAAM,IAAI,MACN,uBAAuB,OAAO,gCAAgC,cAAc,GAAG;MAEvF;IACJ;;;;IAKA,MAAM,aAAU;AACZ,YAAM,aAAa,MAAM,KAAK,iBAAiB,WAAW;AAC1D,YAAM,WAAW,QAAO;IAC5B;;;;IAKA,MAAM,oBAAiB;AACnB,YAAM,aAAa,MAAM,KAAK,iBAAiB,oBAAoB;AACnE,UAAI;AACA,cAAM,WAAW,MAAM,WAAW,WAAU;AAC5C,eAAO,SAAS,MAAM,GAAG;MAC7B;AACI,cAAM,WAAW,QAAO;MAC5B;IACJ;;;;;;IAOA,MAAM,WACF,gBAA4D;MACxD;MACA;OACH;AAED,YAAM,aAAa,MAAM,KAAK,iBAAiB,gBAAgB;AAC/D,UAAI;AACA,cAAM,WAAW,MAAM,WAAW,WAAU;AAC5C,eAAO,iBAAgB,gBAAgB,UAAU,aAAa;MAClE;AACI,cAAM,WAAW,QAAO;MAC5B;IACJ;;;;IAKA,MAAM,aACF,SAA8C;AAE9C,aAAO,mBAAK,gBAAe,eAAe,OAAO;IACrD;;;;IAKA,MAAM,gBAAgB,QAAkD;AACpE,YAAM,aAAa,MAAM,KAAK,iBAC1B,WAAW,YACL,2BACA,iBAAgB,oBAAoB,QAAQ,WAAW,CAAC;AAElE,UAAI;AACA,cAAM,WAAW,WAAU;MAC/B;AACI,cAAM,WAAW,QAAO;MAC5B;IACJ;;;;;;;;IASA,MAAM,kBACF,QAAsC;AAkBtC,YAAM,aAAa,MAAM,KAAK,uBAC1B,QACA,eAAe;AAGnB,YAAM,SAAS,IAAI,gBAAgB,UAAU;AAC7C,UAAI;AACA,cAAM,iBAAiB,MAAM,OAAO,WAAU;AAC9C,cAAM,WAAW,eAAe,MAAM,GAAG;AACzC,eAAO,EAAE,aAAa,WAAW,aAAa,SAAQ;MAC1D;AACI,cAAM,OAAO,QAAO;MACxB;IACJ;;;;;;;IAQA,MAAM,uBACF,QACA,SAAe;AAEf,UAAI;AACJ,UAAI;AACJ,UAAI,CAAC,QAAQ;AACT,cAAM,KAAK,gBAAgB,EAAE;AAC7B,wBAAgB;MACpB,WAAW,iBAAiB,QAAQ;AAChC,wBAAgB,qBAAqB,OAAO,WAAW;AACvD,sBAAc,OAAO;MACzB,WAAW,YAAY,QAAQ;AAC3B,cAAM,KAAK,gBAAgB,EAAE;AAC7B,wBAAgB,qBAAqB,OAAO,MAAM;MACtD,WAAW,SAAS,QAAQ;AACxB,cAAM,KAAK,gBAAgB,EAAE;AAC7B,wBAAgB;MACpB,WAAW,SAAS,QAAQ;AACxB,cAAM,KAAK,gBAAgB,EAAE;AAC7B,wBAAgB;MACpB,OAAO;AACH,cAAM,IAAI,UAAU,yBAAyB;MACjD;AAEA,YAAM,aAAa,MAAM,KAAK,iBAAiB,aAAa;AAE5D,UAAI;AACA,cAAM,WAAW,YAAY,OAAO;MACxC,SAAS,GAAG;AACR,cAAM,WAAW,QAAO;AACxB,cAAM;MACV;AAEA,UAAI;AACA,YAAI,gBAAgB,QAAW;AAC3B,gBAAM,QAAQ,MAAM,WAAW,YAAY,CAAC;AAC5C,wBAAc,sBAAsB,OAAO,CAAC;QAChD;AAEA,cAAM,WAAW,SAAQ;AAEzB,cAAM,SAAS,WAAW,QAAO;AAEjC,eAAO;UACH;UACA;UACA,UAAU,OAAO;UACjB,UAAU,OAAO;UACjB,IAAI,SAAM;AACN,mBAAO,OAAO;UAClB;UACA,MAAM,QAAK;AACP,kBAAM,OAAO,MAAK;UACtB;;MAER,SAAS,GAAG;AACR,cAAM,WAAW,QAAO;AACxB,cAAM;MACV;IACJ;;;;;;;;;;;IA8CA,MAAM,QACF,QACA,OACA,SAAiD;AAEjD,UAAI,UAAU,cAAc;AACxB,cAAM,KAAK,gBAAgB,EAAE;MACjC;AAEA,aAAO,sBAAK,iDAAL,WAAuB,QAAQ,OAAO;IACjD;IAEA,MAAM,kBACF,aACA,SAAiD;AAEjD,YAAM,gBAAgB,MAAM,KAAK,WAAU;AAC3C,UAAI,iBAAiB,IAAI;AACrB,eAAO,sBAAK,iDAAL,WACH,EAAE,YAAW,GACb,cACA;MAER,OAAO;AACH,cAAM,WAAW,MAAM,KAAK,aAAa,OAAO;AAChD,eAAO,IAAI,QAAc,CAAC,SAAS,WAAU;AACzC,mBAAS,eAAe,CAAC,YAAW;AAChC,gBACI,QAAQ,KACJ,CAAC,WAAW,OAAO,gBAAgB,WAAW,GAEpD;AACE,uBAAS,KAAI;AACb,sBAAO;YACX;UACJ,CAAC;AACD,mBAAS,QAAQ,CAAC,MAAK;AACnB,qBAAS,KAAI;AACb,mBAAO,CAAC;UACZ,CAAC;QACL,CAAC;MACL;IACJ;;;;IAKA,MAAM,gBACF,QAAsC;AAEtC,YAAM,EAAE,aAAa,SAAQ,IAAK,MAAM,KAAK,kBAAkB,MAAM;AAErE,YAAM,UAAU,MAAM,KAAK,WAAU;AACrC,YAAM,OAAO,QAAQ,KACjB,CAACC,YAAWA,QAAO,gBAAgB,WAAW;AAGlD,YAAM,SAAS,IAAI,UACf,MAAM,SACN,MAAM,OACN,MAAM,QACN,QAAQ;AAGZ,YAAM,sBAAsB,IAAI,gBAAe;AAC/C,YAAM,eAAe,KAAK,kBAAkB,aAAa;QACrD,OAAO;QACP,QAAQ,oBAAoB;OAC/B;AAED,YAAM,YAAY,IAAI,mBAClB,MACA,MAAM,UAAU,IAChB,QACA,aACA,YAAY;AAGhB,WAAK,UAAU,aAAa,QAAQ,MAAM,oBAAoB,MAAK,CAAE;AAErE,aAAO;IACX;IAEA,MAAM,UAAU,QAAsC;AAClD,YAAM,YAAY,MAAM,KAAK,gBAAgB,MAAM;AACnD,aAAO,IAAI,IAAI,SAAS;IAC5B;;AAvWS;AAxFP;AA4TI,wBAAiB,eACnB,QACA,OACA,SAAiD;AAEjD,QAAI;AACJ,QAAI,CAAC,QAAQ;AACT,aAAO;IACX,WAAW,iBAAiB,QAAQ;AAChC,aAAO;IACX,WAAW,YAAY,QAAQ;AAC3B,aAAO;IACX,WAAW,SAAS,QAAQ;AACxB,aAAO;IACX,WAAW,SAAS,QAAQ;AACxB,aAAO;IACX,OAAO;AACH,YAAM,IAAI,UAAU,yBAAyB;IACjD;AAIA,UAAM,UAAU,iBAAgB,oBAC5B,QACA,YAAY,IAAI,IAAI,KAAK,EAAE;AAG/B,UAAM,aAAa,MAAM,KAAK,iBAAiB,SAAS,OAAO;AAC/D,QAAI;AACA,YAAM,WAAW,SAAQ;IAC7B;AACI,YAAM,WAAW,QAAO;IAC5B;EACJ;AA5VA,gBADS,kBACF,gBAAe;AACtB,gBAFS,kBAEF,qBAAoB;AAC3B,gBAHS,kBAGF,yBAAwB;AAH7B,MAAO,kBAAP;AAkcN,iBAAsB,WAClB,aACG,SAAoC;AAEvC,UAAM,eAAe,IAAI,gBAAe;AACxC,aAAS,QAAK;AACV,mBAAa,OAAO,KAAK,MAAM;IACnC;AAEA,QAAI;AACA,iBAAW,UAAU,SAAS;AAC1B,YAAI,CAAC,QAAQ;AACT;QACJ;AACA,YAAI,OAAO,SAAS;AAChB,gBAAM,OAAO;QACjB;AACA,eAAO,iBAAiB,SAAS,KAAK;MAC1C;AAEA,aAAO,MAAM,QAAQ,KAAK,CAAC,SAAQ,GAAI,aAAa,OAAO,CAAC;IAChE;AACI,iBAAW,UAAU,SAAS;AAC1B,YAAI,CAAC,QAAQ;AACT;QACJ;AACA,eAAO,oBAAoB,SAAS,KAAK;MAC7C;IACJ;EACJ;;;ACjgBA,MAAAC,eAAA;WAAAA,cAAA;;;;;;;;;;;;;;;;;ACAM,MAAO,kBAAP,cAA+B,MAAK;IACtC,YAAY,OAAa;AACrB,YAAM,oDAAoD;QACtD;OACH;IACL;;;;ACLE,WAAU,YAAY,GAAY,MAAY;AAIhD,WACI,OAAO,MAAM,YAAY,MAAM,QAAQ,UAAU,KAAK,EAAE,SAAS;EAEzE;AAeM,WAAU,qBACZ,QAAuB;AAEvB,WACI,OAAO,cAAc,UACrB,OAAO,iBAAiB,UACxB,OAAO,iBAAiB;EAEhC;AAEA,WAAS,wBACL,WACA,QAA0B;AAE1B,WACI,UAAU,mBAAmB,OAAO,aACpC,UAAU,sBAAsB,OAAO,gBACvC,UAAU,sBAAsB,OAAO;EAE/C;AAQM,WAAU,iBACZ,QACA,QAA0B;AAE1B,eAAW,iBAAiB,OAAO,gBAAgB;AAC/C,iBAAW,cAAc,cAAc,YAAY;AAC/C,mBAAW,aAAa,WAAW,YAAY;AAC3C,cAAI,wBAAwB,WAAW,MAAM,GAAG;AAC5C,mBAAO,EAAE,eAAe,YAAY,UAAS;UACjD;QACJ;MACJ;IACJ;AACA,WAAO;EACX;AAEA,WAAS,UAAU,OAAa;AAC5B,WAAO,MAAM,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG;EAC7C;AAEM,WAAU,gBAAgB,QAAiB;AAC7C,QAAI,OAAO,cAAc;AACrB,aAAO,OAAO;IAClB;AAEA,WAAO,UAAU,OAAO,QAAQ,IAAI,MAAM,UAAU,OAAO,SAAS;EACxE;AAOM,WAAU,iBAAiB,WAAiC;AAC9D,QAAI,UAAU,WAAW,GAAG;AACxB,YAAM,IAAI,UAAU,oBAAoB;IAC5C;AAEA,QAAI;AACJ,QAAI;AAEJ,eAAW,YAAY,WAAW;AAC9B,cAAQ,SAAS,WAAW;QACxB,KAAK;AACD,uBAAa;AACb,cAAI,aAAa;AACb,mBAAO,EAAE,YAAY,YAAW;UACpC;AACA;QACJ,KAAK;AACD,wBAAc;AACd,cAAI,YAAY;AACZ,mBAAO,EAAE,YAAY,YAAW;UACpC;AACA;MACR;IACJ;AAEA,QAAI,CAAC,YAAY;AACb,YAAM,IAAI,UAAU,0BAA0B;IAClD;AACA,QAAI,CAAC,aAAa;AACd,YAAM,IAAI,UAAU,2BAA2B;IACnD;AACA,UAAM,IAAI,MAAM,aAAa;EACjC;AAUM,WAAU,YACZ,QACA,QAAuB;AAEvB,QAAI,OAAO,aAAa,UAAa,OAAO,aAAa,OAAO,UAAU;AACtE,aAAO;IACX;AAEA,QACI,OAAO,cAAc,UACrB,OAAO,cAAc,OAAO,WAC9B;AACE,aAAO;IACX;AAEA,QACI,OAAO,iBAAiB,UACxB,gBAAgB,MAAM,MAAM,OAAO,cACrC;AACE,aAAO;IACX;AAEA,QAAI,qBAAqB,MAAM,GAAG;AAC9B,aAAO,iBAAiB,QAAQ,MAAM,KAAK;IAC/C;AAEA,WAAO;EACX;AAYM,WAAU,aACZ,QACA,SACA,kBAA6C;AAE7C,QAAI,oBAAoB,iBAAiB,SAAS,GAAG;AACjD,UAAI,aAAa,QAAQ,gBAAgB,GAAG;AACxC,eAAO;MACX;IACJ;AAEA,eAAW,UAAU,SAAS;AAC1B,YAAM,SAAS,YAAY,QAAQ,MAAM;AACzC,UAAI,QAAQ;AACR,eAAO;MACX;IACJ;AACA,WAAO;EACX;;;ACtJO,MAAM,4BAA4B;IACrC,WAAW;IACX,cAAc;IACd,cAAc;;AAGZ,WAAU,+BACZ,SAA+C;AAE/C,QAAI,CAAC,WAAW,QAAQ,WAAW,GAAG;AAClC,aAAO,CAAC,yBAAyB;IACrC,OAAO;AACH,aAAO,QAAQ,IAAI,CAAC,YAAY;QAC5B,GAAG;QACH,WAAW,OAAO,aAAa,0BAA0B;QACzD,cACI,OAAO,gBAAgB,0BAA0B;QACrD,cACI,OAAO,gBAAgB,0BAA0B;QACvD;IACN;EACJ;AA/CA,MAAAC,UAAA,2BAAAC,YAAAC,YAAA;AAiDM,MAAO,4BAAP,MAAgC;IA4BlC,YACI,QACA,YACA,aACA,YAAe;AAhCjB;AAGO,yBAAAF;AAKA;AAKA;AAKA,yBAAAC;AAKA,yBAAAC;AAWL,yBAAKF,UAAU;AACf,yBAAK,aAAc;AACnB,yBAAK,cAAe;AAEpB,UAAIG,UAAS;AAEb,YAAM,SAAS,IAAI,oBAGjB;QACE,OAAO,YAAW;AACd,cAAI;AACA,YAAAA,UAAS;AACT,kBAAM,OAAO,IAAI,MAAK;UAC1B,QAAQ;UAER;QACJ;QACA,SAAS,MAAK;AACV,UAAAA,UAAS;AACT,qBAAW,oBACP,cACA,mBAAmB;QAE3B;OACH;AAED,eAAS,oBAAoB,GAAqB;AAC9C,YAAI,EAAE,WAAW,OAAO,KAAK;AACzB,iBAAO,QAAO,EAAG,MAAM,WAAW;QACtC;MACJ;AAEA,iBAAW,iBAAiB,cAAc,mBAAmB;AAE7D,yBAAKF,YAAY,OAAO,aACpB,IAAI,eACA;QACI,MAAM,OAAO,eAAc;AACvB,gBAAM,SAAS,MAAM,sBAAK,qDAAL;AACrB,cAAI,QAAQ;AACR,uBAAW,QAAQ,MAAM;UAC7B,OAAO;AACH,uBAAW,MAAK;UACpB;QACJ;SAEJ,EAAE,eAAe,EAAC,CAAE,CACvB;AAGL,YAAM,WAAW,YAAY,aAAa;AAC1C,yBAAKC,YAAY,SACb,OAAO,eACH,IAAI,yBAAgB,eAAe;QAC/B,OAAO,OAAO,UAAS;AACnB,cAAI;AACA,kBAAM,OAAO,IAAI,YACb,YAAY,gBACZ,kBAAkB,KAAK,CAAC;AAO5B,gBAAI,aAAa,MAAM,SAAS,cAAc,GAAG;AAC7C,oBAAM,OAAO,IAAI,YACb,YAAY,gBACZ,eAAe;YAEvB;UACJ,SAAS,GAAG;AACR,gBAAIC,SAAQ;AACR;YACJ;AACA,kBAAM;UACV;QACJ;OACH,CAAC,GAEN,IAAI,yBAAwB,CAAE;IAEtC;IAjHA,IAAI,SAAM;AACN,aAAO,mBAAKH;IAChB;IAGA,IAAI,aAAU;AACV,aAAO,mBAAK;IAChB;IAGA,IAAI,cAAW;AACX,aAAO,mBAAK;IAChB;IAGA,IAAI,WAAQ;AACR,aAAO,mBAAKC;IAChB;IAGA,IAAI,WAAQ;AACR,aAAO,mBAAKC;IAChB;;AAvBS,EAAAF,WAAA;AAKA;AAKA;AAKA,EAAAC,aAAA;AAKA,EAAAC,aAAA;AAvBP;AAuHI,kBAAW,iBAAA;AACb,QAAI;AACA,aAAO,MAAM;AAET,cAAM,SAAS,MAAM,mBAAKF,UAAQ,IAAI,WAClC,mBAAK,aAAY,gBACjB,mBAAK,aAAY,UAAU;AAG/B,YAAI,OAAO,KAAM,eAAe,IAAI;AAChC;QACJ;AAGA,cAAMI,UAAS,IAAI,WAAW,OAAO,KAAM,MAAM;AACjD,cAAM,SAAS,IAAI,wBAAwBA,OAAM;AAGjD,cAAM,SAAS,gBAAgB,YAC3B,MAAM;AAGV,YAAI,OAAO,WAAW,OAAO,UAAU,aAAa;AAChD;QACJ;AAEA,YAAI,OAAO,kBAAkB,GAAG;AAC5B,gBAAMC,UAAS,MAAM,mBAAKL,UAAQ,IAAI,WAClC,mBAAK,aAAY,gBACjB,OAAO,aAAa;AAExB,iBAAO,UAAU,IAAI,WAAWK,QAAO,KAAM,MAAM;QACvD,OAAO;AACH,iBAAO,UAAU;QACrB;AAEA,eAAO;MACX;IACJ,SAAS,GAAG;AAKR,UAAI,YAAY,GAAG,cAAc,GAAG;AAChC,cAAM,IAAI,QAAc,CAAC,YAAW;AAChC,qBAAW,MAAK;AACZ,oBAAO;UACX,GAAG,GAAG;QACV,CAAC;AAED,YAAI,QAAQ;AACR,iBAAO;QACX;MACJ;AAEA,YAAM;IACV;EACJ;AAjOJ,qCAAAC,UAAA;AAoOM,MAAO,yBAAP,MAAO,uBAAqB;;;;;;;IA0B9B,YACI,QACA,YACA,YAAe;AA7BjB;AAGO;AACA;AAEA;AAKA,yBAAAA;AAoBL,yBAAK,MAAO;AACZ,yBAAKA,UAAU,gBAAgB,MAAM;AACrC,yBAAK,YAAa;AAClB,yBAAK,aAAc;IACvB;IA5BA,IAAI,MAAG;AACH,aAAO,mBAAK;IAChB;IAGA,IAAI,SAAM;AACN,aAAO,mBAAKA;IAChB;IAEA,IAAI,OAAI;AACJ,aAAO,mBAAK,MAAK;IACrB;;;;IAmEA,MAAM,UAAO;AACT,YAAM,EAAE,YAAY,YAAW,IAAK,MAAM,sBAAK,qDAAL;AAC1C,aAAO,IAAI,0BACP,MACA,YACA,aACA,mBAAK,YAAW;IAExB;;AA1FS;AACA;AAEA;AAKA,EAAAA,WAAA;AAXP;AAqCI,sBAAe,iBAAA;AAIjB,QAAI,CAAC,mBAAK,MAAK,QAAQ;AACnB,YAAM,mBAAK,MAAK,KAAI;IACxB;AAEA,UAAM,EAAE,eAAe,YAAY,UAAS,IAAK,mBAAK;AAEtD,QACI,mBAAK,MAAK,eAAe,uBACzB,cAAc,oBAChB;AAGE,YAAM,mBAAK,MAAK,oBACZ,cAAc,kBAAkB;IAExC;AAEA,QAAI,CAAC,WAAW,SAAS;AACrB,UAAI;AACA,cAAM,mBAAK,MAAK,eAAe,WAAW,eAAe;MAC7D,SAAS,GAAG;AACR,YAAI,YAAY,GAAG,cAAc,GAAG;AAChC,gBAAM,IAAI,uBAAsB,gBAAgB,CAAC;QACrD;AAEA,cAAM;MACV;IACJ;AAEA,QACI,WAAW,UAAU,qBAAqB,UAAU,kBACtD;AACE,YAAM,mBAAK,MAAK,yBACZ,WAAW,iBACX,UAAU,gBAAgB;IAElC;AAEA,WAAO,iBAAiB,UAAU,SAAS;EAC/C;AA/EA,gBADS,wBACF,mBAAkB;AADvB,MAAO,wBAAP;;;ACxON,mCAAAC,cAAA;AAeM,MAAO,iCAAP,MAAO,+BAA6B;IAgCtC,YACI,KACA,SACA,UAA6D,CAAA,GAAE;AAnCjE;AAWO;AACA;AACA,yBAAAA;AAEA,uCAAe,IAAI,aAAY;AAGxC,yCAAc,mBAAK,cAAa;AAEvB,0CAAkB,IAAI,aAAY;AAG3C,4CAAiB,mBAAK,iBAAgB;AAE7B,wCAAgB,IAAI,mBAAkB;AAG/C,0CAAe,mBAAK,eAAc;AAElC,qCAA4C,CAAA;AAkC5C,yCAAiB,CAAC,MAAyB;AACvC,cAAM,SAAS,sBAAK,4DAAL,WAAoB,EAAE;AACrC,YAAI,CAAC,QAAQ;AACT;QACJ;AAIA,YAAI,KAAK,QAAQ,KAAK,CAAC,SAAS,KAAK,QAAQ,OAAO,GAAG,GAAG;AACtD;QACJ;AAEA,cAAM,OAAO,KAAK,QAAQ,MAAK;AAC/B,aAAK,KAAK,MAAM;AAChB,aAAK,UAAU;AAEf,2BAAK,cAAa,KAAK,CAAC,MAAM,CAAC;AAC/B,2BAAK,eAAc,KAAK,KAAK,OAAO;MACxC;AAEA,4CAAoB,CAAC,MAAyB;AAC1C,cAAM,QAAQ,KAAK,QAAQ,UACvB,CAAC,WAAW,OAAO,QAAQ,EAAE,MAAM;AAEvC,YAAI,UAAU,IAAI;AACd,gBAAM,SAAS,KAAK,QAAQ,KAAK;AAEjC,gBAAM,OAAO,KAAK,QAAQ,MAAK;AAC/B,0BAAgB,MAAM,KAAK;AAC3B,eAAK,UAAU;AAEf,6BAAK,iBAAgB,KAAK,CAAC,MAAM,CAAC;AAClC,6BAAK,eAAc,KAAK,KAAK,OAAO;QACxC;MACJ;AA7DI,yBAAK,UAAW,+BAA+B,QAAQ,OAAO;AAC9D,yBAAK,mBAAoB,QAAQ;AACjC,yBAAKA,cAAc;AAEnB,WAAK,UAAU,QACV,IAAI,CAAC,WAAW,sBAAK,4DAAL,WAAoB,OAAO,EAC3C,OAAO,CAAC,WAAW,CAAC,CAAC,MAAM;AAEhC,yBAAK,eAAc,KAAK,KAAK,OAAO;AAEpC,yBAAKA,cAAY,iBAAiB,WAAW,mBAAK,eAAc;AAChE,yBAAKA,cAAY,iBAAiB,cAAc,mBAAK,kBAAiB;IAC1E;IA9CA,aAAa,OACT,KACA,UAA6D,CAAA,GAAE;AAE/D,YAAM,UAAU,MAAM,IAAI,WAAU;AACpC,aAAO,IAAI,+BAA8B,KAAK,SAAS,OAAO;IAClE;IA2FA,OAAI;AACA,yBAAKA,cAAY,oBAAoB,WAAW,mBAAK,eAAc;AACnE,yBAAKA,cAAY,oBACb,cACA,mBAAK,kBAAiB;AAG1B,yBAAK,cAAa,QAAO;AACzB,yBAAK,iBAAgB,QAAO;AAC5B,yBAAK,eAAc,QAAO;IAC9B;;AAnGS;AACA;AACA,EAAAA,eAAA;AAEA;AAKA;AAKA;AAzBP;AAmDF,qBAAc,SAAC,QAAiB;AAC5B,UAAM,aAAa,aACf,QACA,mBAAK,WACL,mBAAK,kBAAiB;AAE1B,QAAI,CAAC,YAAY;AACb,aAAO;IACX;AAEA,WAAO,IAAI,sBAAsB,QAAQ,YAAY,mBAAKA,aAAW;EACzE;AAEA;AAoBA;AApFE,MAAO,gCAAP;;;AChBN,MAAAC;AAcM,MAAO,gCAAP,MAAO,8BAA4B;;;;;IAiBrC,YAAY,YAAe;AANlB,yBAAAA;AAOL,yBAAKA,cAAc;IACvB;;;;IAKA,MAAM,cACF,UAA6D,CAAA,GAAE;AAE/D,YAAM,UAAU,+BAA+B,QAAQ,OAAO;AAE9D,UAAI;AACA,cAAM,SAAS,MAAM,mBAAKA,cAAY,cAAc;UAChD;UACA,kBAAkB,QAAQ;SAC7B;AAED,cAAM,aAAa,aACf,QACA,SACA,QAAQ,gBAAgB;AAE5B,YAAI,CAAC,YAAY;AAGb,iBAAO;QACX;AAMA,2BAAKA,cAAY,cACb,IAAI,mBAAmB,WAAW,EAAE,OAAM,CAAE,CAAC;AAGjD,eAAO,IAAI,sBACP,QACA,YACA,mBAAKA,aAAW;MAExB,SAAS,GAAG;AAER,YAAI,YAAY,GAAG,eAAe,GAAG;AACjC,iBAAO;QACX;AAEA,cAAM;MACV;IACJ;;;;IAKA,MAAM,WACF,UAA6D,CAAA,GAAE;AAE/D,YAAM,UAAU,+BAA+B,QAAQ,OAAO;AAE9D,YAAM,UAAU,MAAM,mBAAKA,cAAY,WAAU;AAEjD,YAAM,SAAkC,CAAA;AACxC,iBAAW,UAAU,SAAS;AAC1B,cAAM,aAAa,aACf,QACA,SACA,QAAQ,gBAAgB;AAE5B,YAAI,YAAY;AACZ,iBAAO,KACH,IAAI,sBACA,QACA,YACA,mBAAKA,aAAW,CACnB;QAET;MACJ;AAEA,aAAO;IACX;IAEA,aACI,UAA6D,CAAA,GAAE;AAE/D,aAAO,8BAA8B,OAAO,mBAAKA,eAAa,OAAO;IACzE;;AA7FS,EAAAA,eAAA;AALT;;;;;gBANS,+BAMO,WAA2B,uBACvC,OAAO,WAAW,cAAc,eAAe,WAAW,UAAU,MAC9D,IAAI,8BAA6B,WAAW,UAAU,GAAG,IACzD,QAAU;AATlB,MAAO,+BAAP;;;ACdN,MAAAC,eAAA;WAAAA,cAAA;;;AAIA,WAAS,eAAY;AACjB,WAAO,IAAI,QAAqB,CAAC,SAAS,WAAU;AAChD,YAAM,UAAU,UAAU,KAAK,SAAS,CAAC;AACzC,cAAQ,UAAU,MAAK;AACnB,eAAO,QAAQ,KAAM;MACzB;AACA,cAAQ,kBAAkB,MAAK;AAC3B,cAAM,KAAK,QAAQ;AACnB,WAAG,kBAAkB,kBAAkB,EAAE,eAAe,KAAI,CAAE;MAClE;AACA,cAAQ,YAAY,MAAK;AACrB,cAAM,KAAK,QAAQ;AACnB,gBAAQ,EAAE;MACd;IACJ,CAAC;EACL;AAEA,iBAAe,QAAQ,KAAe;AAClC,UAAM,KAAK,MAAM,aAAY;AAE7B,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAU;AACnC,YAAM,cAAc,GAAG,YAAY,kBAAkB,WAAW;AAChE,YAAM,QAAQ,YAAY,YAAY,gBAAgB;AACtD,YAAM,aAAa,MAAM,IAAI,GAAG;AAChC,iBAAW,UAAU,MAAK;AACtB,eAAO,WAAW,KAAM;MAC5B;AACA,iBAAW,YAAY,MAAK;AACxB,gBAAO;MACX;AACA,kBAAY,UAAU,MAAK;AACvB,eAAO,YAAY,KAAM;MAC7B;AACA,kBAAY,aAAa,MAAK;AAC1B,WAAG,MAAK;MACZ;IACJ,CAAC;EACL;AAEA,iBAAe,aAAU;AACrB,UAAM,KAAK,MAAM,aAAY;AAE7B,WAAO,IAAI,QAAsB,CAAC,SAAS,WAAU;AACjD,YAAM,cAAc,GAAG,YAAY,kBAAkB,UAAU;AAC/D,YAAM,QAAQ,YAAY,YAAY,gBAAgB;AACtD,YAAM,aAAa,MAAM,OAAM;AAC/B,iBAAW,UAAU,MAAK;AACtB,eAAO,WAAW,KAAM;MAC5B;AACA,iBAAW,YAAY,MAAK;AACxB,gBAAQ,WAAW,MAAsB;MAC7C;AACA,kBAAY,UAAU,MAAK;AACvB,eAAO,YAAY,KAAM;MAC7B;AACA,kBAAY,aAAa,MAAK;AAC1B,WAAG,MAAK;MACZ;IACJ,CAAC;EACL;AA/DA;AAqEA,MAAqB,wBAArB,MAA0C;IAGtC,YAAY,UAAU,SAAO;AAFpB;AAGL,yBAAK,UAAW;IACpB;;;;;;;;IASA,MAAM,cAAW;AACb,YAAM,EAAE,YAAY,UAAS,IAAK,MAAM,OAAO,OAAO,YAClD;QACI,MAAM;QACN,eAAe;;QAEf,gBAAgB,IAAI,WAAW,CAAC,GAAM,GAAM,CAAI,CAAC;QACjD,MAAM;SAEV,MACA,CAAC,QAAQ,QAAQ,CAAC;AAGtB,YAAM,aAAa,IAAI,WACnB,MAAM,OAAO,OAAO,UAAU,SAAS,SAAS,CAAC;AAErD,YAAM,QAAQ,UAAU;AAExB,aAAO;QACH,QAAQ;QACR,MAAM,GAAG,mBAAK,SAAQ,IAAI,WAAW,SAAS,QAAQ;;IAE9D;;;;;;IAOA,OAAO,cAAW;AACd,iBAAW,OAAO,MAAM,WAAU,GAAI;AAClC,cAAM;UACF,QAAQ;UACR,MAAM,GAAG,mBAAK,SAAQ,IAAI,WAAW,SAAS,QAAQ;;MAE9D;IACJ;;AAjDS;;;AC/Db,SAAO,WAAW;AAAA,IAChB,KAAAC;AAAA,IACA,iBAAAA;AAAA,IACA,kBAAAA;AAAA,IACA;AAAA,EACF;AAEA,UAAQ,IAAI,qBAAqB,OAAO,KAAK,OAAO,QAAQ,CAAC;",
  "names": ["esm_exports", "NOOP", "value", "result", "buffer", "field", "deserialize", "init", "buffer", "field", "context", "index", "size", "buffer", "buffer", "buffer", "buffer", "buffer", "buffer", "buffer", "buffer", "buffer", "buffer", "buffer", "buffer", "field", "ReadableStream", "_position", "_writable", "_readable", "_resolver", "_readableController", "chunk", "chunk", "console", "_resolver", "chunk", "chunk", "chunk", "buffer", "struct", "struct", "charToIndex", "indexToChar", "paddingChar", "buffer", "NOOP", "buffer", "_socket", "_writer", "_adb", "_socket", "_writer", "_exited", "_socket", "_writer", "_input", "_stdout", "_exited", "_spawn", "_adb", "_adb", "buffer", "NOOP", "_writer", "_readable", "buffer", "_socket", "chunk", "_readable", "_readableController", "_closed", "_socket", "_writer", "_closed", "_dispatcher", "calculateChecksum", "OKAY", "_connection", "_buffered", "_writer", "buffer", "_client", "_client", "_client", "_sockets", "_closed", "_disconnected", "value", "device", "esm_exports", "_device", "_readable", "_writable", "closed", "buffer", "result", "_serial", "_usbManager", "_usbManager", "esm_exports", "esm_exports"]
}
