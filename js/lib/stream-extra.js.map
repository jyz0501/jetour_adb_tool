{
  "version": 3,
  "sources": ["../../node_modules/@yume-chan/async/src/promise-resolver.ts", "../../node_modules/@yume-chan/async/src/maybe-promise.ts", "../../node_modules/@yume-chan/struct/src/bipedal.ts", "../../node_modules/@yume-chan/struct/src/buffer.ts", "../../node_modules/@yume-chan/struct/src/readable.ts", "../../node_modules/@yume-chan/struct/src/struct.ts", "../../node_modules/@yume-chan/stream-extra/src/stream.ts", "../../node_modules/@yume-chan/stream-extra/src/push-readable.ts", "../../node_modules/@yume-chan/stream-extra/src/try-close.ts", "../../node_modules/@yume-chan/stream-extra/src/buffered.ts", "../../node_modules/@yume-chan/stream-extra/src/buffered-transform.ts", "../../node_modules/@yume-chan/stream-extra/src/concat.ts", "../../node_modules/@yume-chan/stream-extra/src/consumable/readable.ts", "../../node_modules/@yume-chan/stream-extra/src/consumable/wrap-byte-readable.ts", "../../node_modules/@yume-chan/stream-extra/src/consumable/wrap-writable.ts", "../../node_modules/@yume-chan/stream-extra/src/consumable/writable.ts", "../../node_modules/@yume-chan/stream-extra/src/task.ts", "../../node_modules/@yume-chan/stream-extra/src/consumable.ts", "../../node_modules/@yume-chan/stream-extra/src/maybe-consumable/index.ts", "../../node_modules/@yume-chan/stream-extra/src/maybe-consumable/utils.ts", "../../node_modules/@yume-chan/stream-extra/src/maybe-consumable/wrap-writable.ts", "../../node_modules/@yume-chan/stream-extra/src/maybe-consumable/writable.ts", "../../node_modules/@yume-chan/stream-extra/src/distribution.ts", "../../node_modules/@yume-chan/stream-extra/src/wrap-readable.ts", "../../node_modules/@yume-chan/stream-extra/src/duplex.ts", "../../node_modules/@yume-chan/stream-extra/src/encoding.ts", "../../node_modules/@yume-chan/stream-extra/src/inspect.ts", "../../node_modules/@yume-chan/stream-extra/src/pipe-from.ts", "../../node_modules/@yume-chan/stream-extra/src/split-string.ts", "../../node_modules/@yume-chan/stream-extra/src/struct-deserialize.ts", "../../node_modules/@yume-chan/stream-extra/src/struct-serialize.ts", "../../node_modules/@yume-chan/stream-extra/src/wrap-writable.ts"],
  "sourcesContent": ["export type PromiseResolverState = 'running' | 'resolved' | 'rejected';\n\nexport class PromiseResolver<T> {\n    #promise: Promise<T>;\n    public get promise(): Promise<T> { return this.#promise; }\n\n    #resolve!: (value: T | PromiseLike<T>) => void;\n    #reject!: (reason?: any) => void;\n\n    #state: PromiseResolverState = 'running';\n    public get state(): PromiseResolverState { return this.#state; }\n\n    public constructor() {\n        this.#promise = new Promise<T>((resolve, reject) => {\n            this.#resolve = resolve;\n            this.#reject = reject;\n        });\n    }\n\n    public resolve = (value: T | PromiseLike<T>): void => {\n        this.#resolve(value);\n        this.#state = 'resolved';\n    };\n\n    public reject = (reason?: any): void => {\n        this.#reject(reason);\n        this.#state = 'rejected';\n    };\n}\n", "export type MaybePromise<T> = T | Promise<T>;\n\nexport type MaybePromiseLike<T> = T | PromiseLike<T>;\n\nexport function isPromiseLike<T>(value: unknown): value is PromiseLike<T> {\n    return typeof value === \"object\" && value !== null && \"then\" in value;\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport { isPromiseLike } from \"@yume-chan/async\";\n\nfunction advance<T>(\n    iterator: Iterator<unknown, T, unknown>,\n    next: unknown,\n): MaybePromiseLike<T> {\n    while (true) {\n        const { done, value } = iterator.next(next);\n        if (done) {\n            return value;\n        }\n        if (isPromiseLike(value)) {\n            return value.then(\n                (value) => advance(iterator, { resolved: value }),\n                (error: unknown) => advance(iterator, { error }),\n            );\n        }\n        next = value;\n    }\n}\n\nexport type BipedalGenerator<This, T, A extends unknown[]> = (\n    this: This,\n    then: <U>(value: MaybePromiseLike<U>) => Iterable<unknown, U, unknown>,\n    ...args: A\n) => Generator<unknown, T, unknown>;\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function bipedal<This, T, A extends unknown[]>(\n    fn: BipedalGenerator<This, T, A>,\n    bindThis?: This,\n): { (this: This, ...args: A): MaybePromiseLike<T> } {\n    function result(this: This, ...args: A): MaybePromiseLike<T> {\n        const iterator = fn.call(\n            this,\n            function* <U>(\n                value: MaybePromiseLike<U>,\n            ): Generator<\n                PromiseLike<U>,\n                U,\n                { resolved: U } | { error: unknown }\n            > {\n                if (isPromiseLike(value)) {\n                    const result = yield value;\n                    if (\"resolved\" in result) {\n                        return result.resolved;\n                    } else {\n                        throw result.error;\n                    }\n                }\n\n                return value;\n            },\n            ...args,\n        ) as never;\n        return advance(iterator, undefined);\n    }\n\n    if (bindThis) {\n        return result.bind(bindThis);\n    } else {\n        return result;\n    }\n}\n", "import type {\n    BipedalFieldDeserializer,\n    ByobFieldSerializer,\n    Field,\n} from \"./field/index.js\";\nimport { field } from \"./field/index.js\";\n\nexport const EmptyUint8Array = new Uint8Array(0);\n\nfunction copyMaybeDifferentLength(\n    dest: Uint8Array,\n    source: Uint8Array,\n    index: number,\n    length: number,\n) {\n    if (source.length < length) {\n        dest.set(source, index);\n        // Clear trailing bytes\n        dest.fill(0, index + source.length, index + length);\n    } else if (source.length === length) {\n        dest.set(source, index);\n    } else {\n        dest.set(source.subarray(0, length), index);\n    }\n}\n\nexport interface Converter<From, To> {\n    convert: (value: From) => To;\n    back: (value: To) => From;\n}\n\nexport interface BufferLengthConverter<K, KT> extends Converter<KT, number> {\n    field: K;\n}\n\n/**\n * Create a fixed-length `Uint8Array` field.\n *\n * @param length Length of the field\n */\nexport function buffer(\n    length: number,\n): Field<Uint8Array, never, never, Uint8Array>;\n/**\n * Create a custom-typed field, backed by a fixed-length `Uint8Array`.\n *\n * @param length Length of the field\n * @param converter A value converter to convert between `Uint8Array` and the target type\n */\nexport function buffer<U>(\n    length: number,\n    converter: Converter<Uint8Array, U>,\n): Field<U, never, never, Uint8Array>;\n\n/**\n * Create a variable-length `Uint8Array` field.\n * The length is determined by another number-typed field.\n *\n * @param lengthField Name of the length field. Must be declared before this field\n */\nexport function buffer<K extends string>(\n    lengthField: K,\n): Field<Uint8Array, K, Record<K, number>, Uint8Array>;\n/**\n * Create a custom-typed field, backed by a variable-length `Uint8Array`.\n * The length is determined by another number-typed field.\n *\n * @param lengthField Name of the length field. Must be declared before this field\n * @param converter A value converter to convert between `Uint8Array` and the target type\n */\nexport function buffer<K extends string, U>(\n    lengthField: K,\n    converter: Converter<Uint8Array, U>,\n): Field<U, K, Record<K, number>, Uint8Array>;\n\n/**\n * Create a variable-length `Uint8Array` field.\n * The length is determined by converting another field to `number`.\n *\n * @param length\n * Name of the length field,\n * and a converter to convert between source type and `number`.\n * Must be declared before this field\n */\nexport function buffer<K extends string, KT>(\n    length: BufferLengthConverter<K, KT>,\n): Field<Uint8Array, K, Record<K, KT>, Uint8Array>;\n/**\n * Create a custom-typed field, backed by a variable-length `Uint8Array`.\n * The length is determined by converting another field to `number`.\n *\n * @param length\n * Name of the length field,\n * and a converter to convert between source type and `number`.\n * Must be declared before this field\n * @param converter\n * A value converter to convert between `Uint8Array` and the target type\n */\nexport function buffer<K extends string, KT, U>(\n    length: BufferLengthConverter<K, KT>,\n    converter: Converter<Uint8Array, U>,\n): Field<U, K, Record<K, KT>, Uint8Array>;\n\n/**\n * Create a length field, and a variable-length `Uint8Array` field.\n * This is a shortcut when the length field is directly before the data field.\n *\n * @param length The length field declaration\n */\nexport function buffer<LengthOmitInit extends string, LengthDependencies>(\n    length: Field<number, LengthOmitInit, LengthDependencies, number>,\n): Field<Uint8Array, LengthOmitInit, LengthDependencies, Uint8Array>;\n/**\n * Create a length field, and a custom-typed field, backed by a variable-length `Uint8Array`.\n * This is a shortcut when the length field is directly before the data field.\n *\n * @param length The length field declaration\n * @param converter A value converter to convert between `Uint8Array` and the target type\n */\nexport function buffer<LengthOmitInit extends string, LengthDependencies, U>(\n    length: Field<number, LengthOmitInit, LengthDependencies, number>,\n    converter: Converter<Uint8Array, U>,\n): Field<U, LengthOmitInit, LengthDependencies, Uint8Array>;\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function buffer(\n    lengthOrField:\n        | string\n        | number\n        | Field<number, string, unknown, number>\n        | BufferLengthConverter<string, unknown>,\n    converter?: Converter<Uint8Array, unknown>,\n): Field<unknown, string, Record<string, unknown>, Uint8Array> {\n    // Fixed length\n    if (typeof lengthOrField === \"number\") {\n        let serialize: ByobFieldSerializer<Uint8Array>;\n        let deserialize: BipedalFieldDeserializer<\n            unknown,\n            Record<string, unknown>\n        >;\n        let init: ((value: unknown) => Uint8Array) | undefined;\n\n        if (lengthOrField === 0) {\n            serialize = () => {};\n\n            if (converter) {\n                // eslint-disable-next-line require-yield\n                deserialize = function* () {\n                    return converter.convert(EmptyUint8Array);\n                };\n            } else {\n                // eslint-disable-next-line require-yield\n                deserialize = function* () {\n                    return EmptyUint8Array;\n                };\n            }\n        } else {\n            serialize = (value, { buffer, index }) =>\n                copyMaybeDifferentLength(buffer, value, index, lengthOrField);\n\n            if (converter) {\n                deserialize = function* (then, reader) {\n                    const array = reader.readExactly(lengthOrField);\n                    return converter.convert(yield* then(array));\n                };\n                init = (value) => converter.back(value);\n            } else {\n                // eslint-disable-next-line require-yield\n                deserialize = function* (_then, reader) {\n                    const array = reader.readExactly(lengthOrField);\n                    return array;\n                };\n            }\n        }\n\n        return field(lengthOrField, \"byob\", serialize, deserialize, { init });\n    }\n\n    // Declare length field\n    // Some field types are `function`s\n    if (\n        (typeof lengthOrField === \"object\" ||\n            typeof lengthOrField === \"function\") &&\n        \"serialize\" in lengthOrField\n    ) {\n        let deserialize: BipedalFieldDeserializer<\n            unknown,\n            Record<string, unknown>\n        >;\n        let init: ((value: unknown) => Uint8Array) | undefined;\n\n        if (converter) {\n            deserialize = function* (then, reader, context) {\n                const length = yield* then(\n                    lengthOrField.deserialize(reader, context),\n                );\n                const array =\n                    length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n                return converter.convert(yield* then(array));\n            };\n            init = (value) => converter.back(value);\n        } else {\n            deserialize = function* (then, reader, context) {\n                const length = yield* then(\n                    lengthOrField.deserialize(reader, context),\n                );\n                const array =\n                    length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n                return array;\n            };\n        }\n\n        return field(\n            lengthOrField.size,\n            \"default\",\n            (value, { littleEndian }) => {\n                if (lengthOrField.type === \"default\") {\n                    const lengthBuffer = lengthOrField.serialize(value.length, {\n                        littleEndian,\n                    });\n\n                    if (value.length === 0) {\n                        return lengthBuffer;\n                    }\n\n                    const result = new Uint8Array(\n                        lengthBuffer.length + value.length,\n                    );\n                    result.set(lengthBuffer, 0);\n                    result.set(value, lengthBuffer.length);\n                    return result;\n                } else {\n                    const result = new Uint8Array(\n                        lengthOrField.size + value.length,\n                    );\n                    lengthOrField.serialize(value.length, {\n                        buffer: result,\n                        index: 0,\n                        littleEndian,\n                    });\n                    result.set(value, lengthOrField.size);\n                    return result;\n                }\n            },\n            deserialize,\n            { init },\n        );\n    }\n\n    // Reference existing length field\n    if (typeof lengthOrField === \"string\") {\n        let deserialize: BipedalFieldDeserializer<\n            unknown,\n            Record<string, unknown>\n        >;\n        let init: (\n            value: unknown,\n            dependencies: Record<string, unknown>,\n        ) => Uint8Array;\n\n        if (converter) {\n            deserialize = function* (then, reader, { dependencies }) {\n                const length = dependencies[lengthOrField] as number;\n                const array =\n                    length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n                return converter.convert(yield* then(array));\n            };\n            init = (value, dependencies) => {\n                const array = converter.back(value);\n                dependencies[lengthOrField] = array.length;\n                return array;\n            };\n        } else {\n            // eslint-disable-next-line require-yield\n            deserialize = function* (_then, reader, { dependencies }) {\n                const length = dependencies[lengthOrField] as number;\n                const array =\n                    length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n                return array;\n            };\n            init = (value, dependencies) => {\n                const array = value as Uint8Array;\n                dependencies[lengthOrField] = array.length;\n                return array;\n            };\n        }\n\n        return field(0, \"default\", (source) => source, deserialize, { init });\n    }\n\n    let deserialize: BipedalFieldDeserializer<unknown, Record<string, unknown>>;\n    let init: (\n        value: unknown,\n        dependencies: Record<string, unknown>,\n    ) => Uint8Array;\n\n    // Reference existing length field + length converter\n    if (converter) {\n        deserialize = function* (then, reader, { dependencies }) {\n            const rawLength = dependencies[lengthOrField.field];\n            const length = lengthOrField.convert(rawLength);\n            const array =\n                length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n            return converter.convert(yield* then(array));\n        };\n        init = (value, dependencies) => {\n            const array = converter.back(value);\n            dependencies[lengthOrField.field] = lengthOrField.back(\n                array.length,\n            );\n            return array;\n        };\n    } else {\n        // eslint-disable-next-line require-yield\n        deserialize = function* (_then, reader, { dependencies }) {\n            const rawLength = dependencies[lengthOrField.field];\n            const length = lengthOrField.convert(rawLength);\n            const array =\n                length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n            return array;\n        };\n        init = (value, dependencies) => {\n            const array = value as Uint8Array;\n            dependencies[lengthOrField.field] = lengthOrField.back(\n                array.length,\n            );\n            return array;\n        };\n    }\n\n    return field(0, \"default\", (source) => source, deserialize, { init });\n}\n", "// TODO: allow over reading (returning a `Uint8Array`, an `offset` and a `length`) to avoid copying\n\nimport type { MaybePromiseLike } from \"@yume-chan/async\";\n\nexport class ExactReadableEndedError extends Error {\n    constructor() {\n        super(\"ExactReadable ended\");\n    }\n}\n\nexport interface ExactReadable {\n    readonly position: number;\n\n    /**\n     * Read data from the underlying data source.\n     *\n     * The stream must return exactly `length` bytes or data. If that's not possible\n     * (due to end of file or other error condition), it must throw an {@link ExactReadableEndedError}.\n     */\n    readExactly(length: number): Uint8Array;\n}\n\nexport class Uint8ArrayExactReadable implements ExactReadable {\n    #data: Uint8Array;\n    #position: number;\n\n    get position() {\n        return this.#position;\n    }\n\n    constructor(data: Uint8Array) {\n        this.#data = data;\n        this.#position = 0;\n    }\n\n    readExactly(length: number): Uint8Array {\n        if (this.#position + length > this.#data.length) {\n            throw new ExactReadableEndedError();\n        }\n\n        const result = this.#data.subarray(\n            this.#position,\n            this.#position + length,\n        );\n\n        this.#position += length;\n        return result;\n    }\n}\n\nexport interface AsyncExactReadable {\n    readonly position: number;\n\n    /**\n     * Read data from the underlying data source.\n     *\n     * The stream must return exactly `length` bytes or data. If that's not possible\n     * (due to end of file or other error condition), it must throw an {@link ExactReadableEndedError}.\n     */\n    readExactly(length: number): MaybePromiseLike<Uint8Array>;\n}\n", "import { bipedal } from \"./bipedal.js\";\nimport type {\n    Field,\n    FieldByobSerializeContext,\n    FieldDefaultSerializeContext,\n    FieldDeserializeContext,\n    FieldDeserializer,\n} from \"./field/index.js\";\nimport type { AsyncExactReadable } from \"./readable.js\";\nimport { ExactReadableEndedError } from \"./readable.js\";\nimport type {\n    StructDeserializer,\n    StructLike,\n    StructSerializeContext,\n    StructSerializer,\n} from \"./types.js\";\n\nexport type StructField =\n    | Field<unknown, string, unknown, unknown>\n    | (StructSerializer<unknown> & StructDeserializer<unknown>);\n\nexport type StructFields = Record<string, StructField>;\n\nexport type FieldsValue<T extends StructFields> = {\n    [K in keyof T]: T[K] extends FieldDeserializer<infer U, unknown>\n        ? U\n        : never;\n};\n\nexport type FieldOmitInit<T extends StructField> =\n    T extends Field<unknown, infer U, unknown, unknown>\n        ? string extends U\n            ? never\n            : U\n        : never;\n\nexport type FieldsOmitInits<T extends StructFields> = {\n    [K in keyof T]: FieldOmitInit<T[K]>;\n}[keyof T];\n\nexport type FieldsInit<T extends StructFields> = Omit<\n    FieldsValue<T>,\n    FieldsOmitInits<T>\n>;\n\nexport class StructDeserializeError extends Error {\n    constructor(message: string) {\n        super(message);\n    }\n}\n\nexport class StructNotEnoughDataError extends StructDeserializeError {\n    constructor() {\n        super(\n            \"The underlying readable was ended before the struct was fully deserialized\",\n        );\n    }\n}\n\nexport class StructEmptyError extends StructDeserializeError {\n    constructor() {\n        super(\"The underlying readable doesn't contain any more struct\");\n    }\n}\n\nexport type ExtraToIntersection<\n    Extra extends Record<PropertyKey, unknown> | undefined,\n> = Extra extends undefined ? unknown : Extra;\n\nexport interface Struct<\n    Fields extends StructFields,\n    Extra extends Record<PropertyKey, unknown> | undefined = undefined,\n    PostDeserialize = FieldsValue<Fields> & Extra,\n> extends StructSerializer<FieldsInit<Fields>>,\n        StructDeserializer<PostDeserialize> {\n    littleEndian: boolean;\n    fields: Fields;\n    extra: Extra;\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function struct<\n    Fields extends Record<\n        string,\n        | Field<unknown, string, Partial<FieldsValue<Fields>>, unknown>\n        | StructLike<unknown>\n    >,\n    Extra extends Record<PropertyKey, unknown> | undefined = undefined,\n    PostDeserialize = FieldsValue<Fields> & ExtraToIntersection<Extra>,\n>(\n    fields: Fields,\n    options: {\n        littleEndian: boolean;\n        extra?: (Extra & ThisType<FieldsValue<Fields>>) | undefined;\n        postDeserialize?:\n            | ((\n                  this: FieldsValue<Fields> & ExtraToIntersection<Extra>,\n                  value: FieldsValue<Fields> & ExtraToIntersection<Extra>,\n              ) => PostDeserialize)\n            | undefined;\n    },\n): Struct<Fields, Extra, PostDeserialize> {\n    const fieldList = Object.entries(fields);\n\n    let size = 0;\n    let byob = true;\n    for (const [, field] of fieldList) {\n        size += field.size;\n        if (byob && field.type !== \"byob\") {\n            byob = false;\n        }\n    }\n\n    const littleEndian = options.littleEndian;\n    const extra = options.extra\n        ? Object.getOwnPropertyDescriptors(options.extra)\n        : undefined;\n\n    return {\n        littleEndian,\n        fields,\n        extra: options.extra,\n\n        type: byob ? \"byob\" : \"default\",\n        size,\n        serialize(\n            source: FieldsInit<Fields>,\n            bufferOrContext?: Uint8Array | StructSerializeContext,\n        ): Uint8Array | number {\n            const temp: Record<string, unknown> = { ...source };\n\n            for (const [key, field] of fieldList) {\n                if (key in temp && \"init\" in field) {\n                    const result = field.init?.(temp[key], temp as never);\n                    temp[key] = result;\n                }\n            }\n\n            const sizes = new Array<number>(fieldList.length);\n            const buffers = new Array<Uint8Array | undefined>(fieldList.length);\n            {\n                const context: FieldDefaultSerializeContext = { littleEndian };\n                for (const [index, [key, field]] of fieldList.entries()) {\n                    if (field.type === \"byob\") {\n                        sizes[index] = field.size;\n                    } else {\n                        buffers[index] = field.serialize(temp[key], context);\n                        sizes[index] = buffers[index].length;\n                    }\n                }\n            }\n\n            const size = sizes.reduce((sum, size) => sum + size, 0);\n\n            let externalBuffer: boolean;\n            let buffer: Uint8Array;\n            let index: number;\n            if (bufferOrContext instanceof Uint8Array) {\n                if (bufferOrContext.length < size) {\n                    throw new Error(\"Buffer too small\");\n                }\n                externalBuffer = true;\n                buffer = bufferOrContext;\n                index = 0;\n            } else if (\n                typeof bufferOrContext === \"object\" &&\n                \"buffer\" in bufferOrContext\n            ) {\n                externalBuffer = true;\n                buffer = bufferOrContext.buffer;\n                index = bufferOrContext.index ?? 0;\n                if (buffer.length - index < size) {\n                    throw new Error(\"Buffer too small\");\n                }\n            } else {\n                externalBuffer = false;\n                buffer = new Uint8Array(size);\n                index = 0;\n            }\n\n            const context = {\n                buffer,\n                index,\n                littleEndian,\n            } satisfies FieldByobSerializeContext;\n            for (const [index, [key, field]] of fieldList.entries()) {\n                if (buffers[index]) {\n                    buffer.set(buffers[index], context.index);\n                } else {\n                    field.serialize(temp[key], context);\n                }\n                context.index += sizes[index]!;\n            }\n\n            if (externalBuffer) {\n                return size;\n            } else {\n                return buffer;\n            }\n        },\n        deserialize: bipedal(function* (\n            this: Struct<Fields, Extra, PostDeserialize>,\n            then,\n            reader: AsyncExactReadable,\n        ) {\n            const startPosition = reader.position;\n\n            const result = {} as Record<string, unknown>;\n            const context: FieldDeserializeContext<\n                Partial<FieldsValue<Fields>>\n            > = {\n                dependencies: result as never,\n                littleEndian: littleEndian,\n            };\n\n            try {\n                for (const [key, field] of fieldList) {\n                    result[key] = yield* then(\n                        field.deserialize(reader, context),\n                    );\n                }\n            } catch (e) {\n                if (!(e instanceof ExactReadableEndedError)) {\n                    throw e;\n                }\n\n                if (reader.position === startPosition) {\n                    throw new StructEmptyError();\n                } else {\n                    throw new StructNotEnoughDataError();\n                }\n            }\n\n            if (extra) {\n                Object.defineProperties(result, extra);\n            }\n\n            if (options.postDeserialize) {\n                return options.postDeserialize.call(\n                    result as never,\n                    result as never,\n                );\n            } else {\n                return result;\n            }\n        }),\n    } as never;\n}\n", "import type {\n    AbortSignal,\n    ReadableStreamIteratorOptions,\n    ReadableStream as ReadableStreamType,\n    TransformStream as TransformStreamType,\n    WritableStream as WritableStreamType,\n} from \"./types.js\";\n\nexport * from \"./types.js\";\nexport { ReadableStream };\n\n/** A controller object that allows you to abort one or more DOM requests as and when desired. */\nexport interface AbortController {\n    /**\n     * Returns the AbortSignal object associated with this object.\n     */\n    readonly signal: AbortSignal;\n\n    /**\n     * Invoking this method will set this object's AbortSignal's aborted flag and signal to any observers that the associated activity is to be aborted.\n     */\n    abort(reason?: unknown): void;\n}\n\ninterface AbortControllerConstructor {\n    prototype: AbortController;\n    new (): AbortController;\n}\n\ninterface GlobalExtension {\n    AbortController: AbortControllerConstructor;\n    ReadableStream: typeof ReadableStreamType;\n    WritableStream: typeof WritableStreamType;\n    TransformStream: typeof TransformStreamType;\n}\n\nexport const { AbortController } = globalThis as unknown as GlobalExtension;\n\nexport type ReadableStream<T> = ReadableStreamType<T>;\nexport type WritableStream<T> = WritableStreamType<T>;\nexport type TransformStream<I, O> = TransformStreamType<I, O>;\n\nconst ReadableStream = /* #__PURE__ */ (() => {\n    const { ReadableStream } = globalThis as unknown as GlobalExtension;\n\n    if (!ReadableStream.from) {\n        ReadableStream.from = function (iterable) {\n            const iterator =\n                Symbol.asyncIterator in iterable\n                    ? iterable[Symbol.asyncIterator]()\n                    : iterable[Symbol.iterator]();\n\n            return new ReadableStream({\n                async pull(controller) {\n                    const result = await iterator.next();\n                    if (result.done) {\n                        controller.close();\n                        return;\n                    }\n                    controller.enqueue(result.value);\n                },\n                async cancel(reason) {\n                    await iterator.return?.(reason);\n                },\n            });\n        };\n    }\n\n    if (\n        !ReadableStream.prototype[Symbol.asyncIterator] ||\n        !ReadableStream.prototype.values\n    ) {\n        ReadableStream.prototype.values = async function* <R>(\n            this: ReadableStream<R>,\n            options?: ReadableStreamIteratorOptions,\n        ) {\n            const reader = this.getReader();\n            try {\n                while (true) {\n                    const { done, value } = await reader.read();\n                    if (done) {\n                        return;\n                    }\n                    yield value;\n                }\n            } finally {\n                // Calling `iterator.return` will enter this `finally` block.\n                // We don't need to care about the parameter to `iterator.return`,\n                // it will be returned as the final `result.value` automatically.\n                if (!options?.preventCancel) {\n                    await reader.cancel();\n                }\n                reader.releaseLock();\n            }\n        };\n\n        ReadableStream.prototype[Symbol.asyncIterator] =\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            ReadableStream.prototype.values;\n    }\n\n    return ReadableStream;\n})();\n\nexport const { WritableStream, TransformStream } =\n    globalThis as unknown as GlobalExtension;\n", "import { PromiseResolver } from \"@yume-chan/async\";\n\nimport type { AbortSignal, QueuingStrategy } from \"./stream.js\";\nimport { AbortController, ReadableStream } from \"./stream.js\";\n\nexport interface PushReadableStreamController<T> {\n    abortSignal: AbortSignal;\n\n    enqueue(chunk: T): Promise<void>;\n\n    close(): void;\n\n    error(e?: unknown): void;\n}\n\nexport type PushReadableStreamSource<T> = (\n    controller: PushReadableStreamController<T>,\n) => void | Promise<void>;\n\nexport type PushReadableLogger<T> = (\n    event:\n        | {\n              source: \"producer\";\n              operation: \"enqueue\";\n              value: T;\n              phase: \"start\" | \"waiting\" | \"ignored\" | \"complete\";\n          }\n        | {\n              source: \"producer\";\n              operation: \"close\" | \"error\";\n              explicit: boolean;\n              phase: \"start\" | \"ignored\" | \"complete\";\n          }\n        | {\n              source: \"consumer\";\n              operation: \"pull\" | \"cancel\";\n              phase: \"start\" | \"complete\";\n          },\n) => void;\n\nexport class PushReadableStream<T> extends ReadableStream<T> {\n    /**\n     * Create a new `PushReadableStream` from a source.\n     *\n     * @param source If `source` returns a `Promise`, the stream will be closed\n     * when the `Promise` is resolved, and be errored when the `Promise` is rejected.\n     * @param strategy\n     */\n    constructor(\n        source: PushReadableStreamSource<T>,\n        strategy?: QueuingStrategy<T>,\n        logger?: PushReadableLogger<T>,\n    ) {\n        let waterMarkLow: PromiseResolver<void> | undefined;\n        let zeroHighWaterMarkAllowEnqueue = false;\n        const abortController = new AbortController();\n\n        super(\n            {\n                start: (controller) => {\n                    const result = source({\n                        abortSignal: abortController.signal,\n                        enqueue: async (chunk) => {\n                            logger?.({\n                                source: \"producer\",\n                                operation: \"enqueue\",\n                                value: chunk,\n                                phase: \"start\",\n                            });\n\n                            if (abortController.signal.aborted) {\n                                // In original `ReadableStream`, calling `enqueue` or `close`\n                                // on an cancelled stream will throw an error,\n                                //\n                                // But in `PushReadableStream`, `enqueue` is an async function,\n                                // the producer can't just check `abortSignal.aborted`\n                                // before calling `enqueue`, as it might change when waiting\n                                // for the backpressure to be reduced.\n                                //\n                                // So IMO it's better to handle this for the producer\n                                // by simply ignoring the `enqueue` call.\n                                //\n                                // Note that we check `abortSignal.aborted` instead of `stopped`,\n                                // as it's not allowed for the producer to call `enqueue` after\n                                // they called `close` or `error`.\n                                //\n                                // Obviously, the producer should listen to the `abortSignal` and\n                                // stop producing, but most pushing data sources don't support that.\n                                logger?.({\n                                    source: \"producer\",\n                                    operation: \"enqueue\",\n                                    value: chunk,\n                                    phase: \"ignored\",\n                                });\n                                return;\n                            }\n\n                            if (controller.desiredSize === null) {\n                                // `desiredSize` being `null` means the stream is in error state,\n                                // `controller.enqueue` will throw an error for us.\n                                controller.enqueue(chunk);\n                                // istanbul ignore next\n                                return;\n                            }\n\n                            if (zeroHighWaterMarkAllowEnqueue) {\n                                // When `highWaterMark` is set to `0`,\n                                // `controller.desiredSize` will always be `0`,\n                                // even if the consumer has called `reader.read()`.\n                                // (in this case, each `reader.read()`/`pull`\n                                // should allow one `enqueue` of any size)\n                                //\n                                // If the consumer has already called `reader.read()`,\n                                // before the producer tries to `enqueue`,\n                                // `controller.desiredSize` is `0` and normal `waterMarkLow` signal\n                                // will never trigger,\n                                // (because `ReadableStream` prevents reentrance of `pull`)\n                                // The stream will stuck.\n                                //\n                                // So we need a special signal for this case.\n                                zeroHighWaterMarkAllowEnqueue = false;\n                                controller.enqueue(chunk);\n                                logger?.({\n                                    source: \"producer\",\n                                    operation: \"enqueue\",\n                                    value: chunk,\n                                    phase: \"complete\",\n                                });\n                                return;\n                            }\n\n                            if (controller.desiredSize <= 0) {\n                                logger?.({\n                                    source: \"producer\",\n                                    operation: \"enqueue\",\n                                    value: chunk,\n                                    phase: \"waiting\",\n                                });\n\n                                waterMarkLow = new PromiseResolver<void>();\n                                await waterMarkLow.promise;\n\n                                // Recheck consumer cancellation after async operations.\n                                if (abortController.signal.aborted) {\n                                    logger?.({\n                                        source: \"producer\",\n                                        operation: \"enqueue\",\n                                        value: chunk,\n                                        phase: \"ignored\",\n                                    });\n                                    return;\n                                }\n                            }\n\n                            controller.enqueue(chunk);\n                            logger?.({\n                                source: \"producer\",\n                                operation: \"enqueue\",\n                                value: chunk,\n                                phase: \"complete\",\n                            });\n                        },\n                        close() {\n                            logger?.({\n                                source: \"producer\",\n                                operation: \"close\",\n                                explicit: true,\n                                phase: \"start\",\n                            });\n\n                            // Since `enqueue` on an cancelled stream won't throw an error,\n                            // so does `close`.\n                            if (abortController.signal.aborted) {\n                                logger?.({\n                                    source: \"producer\",\n                                    operation: \"close\",\n                                    explicit: true,\n                                    phase: \"ignored\",\n                                });\n                                return;\n                            }\n\n                            controller.close();\n                            logger?.({\n                                source: \"producer\",\n                                operation: \"close\",\n                                explicit: true,\n                                phase: \"complete\",\n                            });\n                        },\n                        error(e) {\n                            logger?.({\n                                source: \"producer\",\n                                operation: \"error\",\n                                explicit: true,\n                                phase: \"start\",\n                            });\n\n                            // Calling `error` on an already closed or errored stream is a no-op.\n                            controller.error(e);\n\n                            logger?.({\n                                source: \"producer\",\n                                operation: \"error\",\n                                explicit: true,\n                                phase: \"complete\",\n                            });\n                        },\n                    });\n\n                    if (result && \"then\" in result) {\n                        // If `source` returns a `Promise`,\n                        // close the stream when the `Promise` is resolved,\n                        // and error the stream when the `Promise` is rejected.\n                        // The producer can return a never-settling `Promise`\n                        // to disable this behavior.\n                        result.then(\n                            () => {\n                                logger?.({\n                                    source: \"producer\",\n                                    operation: \"close\",\n                                    explicit: false,\n                                    phase: \"start\",\n                                });\n\n                                try {\n                                    controller.close();\n\n                                    logger?.({\n                                        source: \"producer\",\n                                        operation: \"close\",\n                                        explicit: false,\n                                        phase: \"complete\",\n                                    });\n                                } catch {\n                                    logger?.({\n                                        source: \"producer\",\n                                        operation: \"close\",\n                                        explicit: false,\n                                        phase: \"ignored\",\n                                    });\n\n                                    // The stream is already closed by the producer,\n                                    // Or cancelled by the consumer.\n                                }\n                            },\n                            (e) => {\n                                logger?.({\n                                    source: \"producer\",\n                                    operation: \"error\",\n                                    explicit: false,\n                                    phase: \"start\",\n                                });\n\n                                controller.error(e);\n\n                                logger?.({\n                                    source: \"producer\",\n                                    operation: \"error\",\n                                    explicit: false,\n                                    phase: \"complete\",\n                                });\n                            },\n                        );\n                    }\n                },\n                pull: () => {\n                    logger?.({\n                        source: \"consumer\",\n                        operation: \"pull\",\n                        phase: \"start\",\n                    });\n\n                    if (waterMarkLow) {\n                        waterMarkLow.resolve();\n                    } else if (strategy?.highWaterMark === 0) {\n                        zeroHighWaterMarkAllowEnqueue = true;\n                    }\n\n                    logger?.({\n                        source: \"consumer\",\n                        operation: \"pull\",\n                        phase: \"complete\",\n                    });\n                },\n                cancel: (reason) => {\n                    logger?.({\n                        source: \"consumer\",\n                        operation: \"cancel\",\n                        phase: \"start\",\n                    });\n\n                    abortController.abort(reason);\n                    // Resolve it on cancellation. `pull` will check `abortSignal.aborted` again.\n                    waterMarkLow?.resolve();\n\n                    logger?.({\n                        source: \"consumer\",\n                        operation: \"cancel\",\n                        phase: \"complete\",\n                    });\n                },\n            },\n            strategy,\n        );\n    }\n}\n", "import type { BufferedReadableStream } from \"./buffered.js\";\nimport type { PushReadableStreamController } from \"./push-readable.js\";\nimport type {\n    ReadableStream,\n    ReadableStreamDefaultController,\n    ReadableStreamDefaultReader,\n    WritableStreamDefaultWriter,\n} from \"./stream.js\";\n\nexport function tryClose(\n    controller: PushReadableStreamController<unknown>,\n): boolean;\nexport function tryClose(\n    controller: ReadableStreamDefaultController<unknown>,\n): boolean;\nexport function tryClose(writer: WritableStreamDefaultWriter<never>): boolean;\nexport function tryClose(controller: { close(): void }) {\n    try {\n        controller.close();\n        return true;\n    } catch {\n        return false;\n    }\n}\n\nexport async function tryCancel(\n    stream: ReadableStream<unknown>,\n): Promise<boolean>;\nexport async function tryCancel(\n    stream: BufferedReadableStream,\n): Promise<boolean>;\nexport async function tryCancel(\n    reader: ReadableStreamDefaultReader<unknown>,\n): Promise<boolean>;\nexport async function tryCancel(stream: {\n    cancel(): Promise<void>;\n}): Promise<boolean> {\n    try {\n        await stream.cancel();\n        return true;\n    } catch {\n        return false;\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport type { AsyncExactReadable } from \"@yume-chan/struct\";\nimport { bipedal, ExactReadableEndedError } from \"@yume-chan/struct\";\n\nimport { PushReadableStream } from \"./push-readable.js\";\nimport type { ReadableStream, ReadableStreamDefaultReader } from \"./stream.js\";\nimport { tryCancel } from \"./try-close.js\";\n\nexport class BufferedReadableStream implements AsyncExactReadable {\n    #buffered: Uint8Array | undefined;\n    // PERF: `subarray` is slow\n    // don't use it until absolutely necessary\n    #bufferedOffset = 0;\n    #bufferedLength = 0;\n\n    #position = 0;\n    get position() {\n        return this.#position;\n    }\n\n    protected readonly stream: ReadableStream<Uint8Array>;\n    protected readonly reader: ReadableStreamDefaultReader<Uint8Array>;\n\n    constructor(stream: ReadableStream<Uint8Array>) {\n        this.stream = stream;\n        this.reader = stream.getReader();\n    }\n\n    #readBuffered(length: number) {\n        if (!this.#buffered) {\n            return undefined;\n        }\n\n        const value = this.#buffered.subarray(\n            this.#bufferedOffset,\n            this.#bufferedOffset + length,\n        );\n\n        // PERF: Synchronous path for reading from internal buffer\n        if (this.#bufferedLength > length) {\n            this.#position += length;\n            this.#bufferedOffset += length;\n            this.#bufferedLength -= length;\n            return value;\n        }\n\n        this.#position += this.#bufferedLength;\n        this.#buffered = undefined;\n        this.#bufferedOffset = 0;\n        this.#bufferedLength = 0;\n        return value;\n    }\n\n    async #readSource(length: number): Promise<Uint8Array> {\n        const { done, value } = await this.reader.read();\n        if (done) {\n            throw new ExactReadableEndedError();\n        }\n\n        if (value.length > length) {\n            this.#buffered = value;\n            this.#bufferedOffset = length;\n            this.#bufferedLength = value.length - length;\n            this.#position += length;\n            return value.subarray(0, length);\n        }\n\n        this.#position += value.length;\n        return value;\n    }\n\n    iterateExactly(\n        length: number,\n    ): Iterator<MaybePromiseLike<Uint8Array>, void, void> {\n        let state = this.#buffered ? 0 : 1;\n        return {\n            next: () => {\n                switch (state) {\n                    case 0: {\n                        const value = this.#readBuffered(length)!;\n                        if (value.length === length) {\n                            state = 2;\n                        } else {\n                            length -= value.length;\n                            state = 1;\n                        }\n                        return { done: false, value };\n                    }\n                    case 1:\n                        state = 3;\n                        return {\n                            done: false,\n                            value: this.#readSource(length).then((value) => {\n                                if (value.length === length) {\n                                    state = 2;\n                                } else {\n                                    length -= value.length;\n                                    state = 1;\n                                }\n                                return value;\n                            }),\n                        };\n                    case 2:\n                        return { done: true, value: undefined };\n                    case 3:\n                        throw new Error(\n                            \"Can't call `next` before previous Promise resolves\",\n                        );\n                    default:\n                        throw new Error(\"unreachable\");\n                }\n            },\n        };\n    }\n\n    readExactly = bipedal(function* (\n        this: BufferedReadableStream,\n        then,\n        length: number,\n    ) {\n        let result: Uint8Array | undefined;\n        let index = 0;\n\n        const initial = this.#readBuffered(length);\n        if (initial) {\n            if (initial.length === length) {\n                return initial;\n            }\n\n            result = new Uint8Array(length);\n            result.set(initial, index);\n            index += initial.length;\n            length -= initial.length;\n        } else {\n            result = new Uint8Array(length);\n        }\n\n        while (length > 0) {\n            const value = yield* then(this.#readSource(length));\n            result.set(value, index);\n            index += value.length;\n            length -= value.length;\n        }\n\n        return result;\n    });\n\n    /**\n     * Return a readable stream with unconsumed data (if any) and\n     * all data from the wrapped stream.\n     * @returns A `ReadableStream`\n     */\n    release(): ReadableStream<Uint8Array> {\n        if (this.#bufferedLength > 0) {\n            return new PushReadableStream<Uint8Array>(async (controller) => {\n                // Put the remaining data back to the stream\n                const buffered = this.#buffered!.subarray(this.#bufferedOffset);\n                await controller.enqueue(buffered);\n\n                controller.abortSignal.addEventListener(\"abort\", () => {\n                    void tryCancel(this.reader);\n                });\n\n                // Manually pipe the stream\n                while (true) {\n                    const { done, value } = await this.reader.read();\n                    if (done) {\n                        return;\n                    }\n\n                    await controller.enqueue(value);\n                }\n            });\n        } else {\n            // Simply release the reader and return the stream\n            this.reader.releaseLock();\n            return this.stream;\n        }\n    }\n\n    async cancel(reason?: unknown) {\n        await this.reader.cancel(reason);\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport { StructEmptyError } from \"@yume-chan/struct\";\n\nimport { BufferedReadableStream } from \"./buffered.js\";\nimport type { PushReadableStreamController } from \"./push-readable.js\";\nimport { PushReadableStream } from \"./push-readable.js\";\nimport type {\n    ReadableWritablePair,\n    WritableStreamDefaultController,\n} from \"./stream.js\";\nimport { ReadableStream, WritableStream } from \"./stream.js\";\n\n// TODO: BufferedTransformStream: find better implementation\nexport class BufferedTransformStream<T>\n    implements ReadableWritablePair<T, Uint8Array>\n{\n    #readable: ReadableStream<T>;\n    get readable() {\n        return this.#readable;\n    }\n\n    #writable: WritableStream<Uint8Array>;\n    get writable() {\n        return this.#writable;\n    }\n\n    constructor(\n        transform: (stream: BufferedReadableStream) => MaybePromiseLike<T>,\n    ) {\n        // Convert incoming chunks to a `BufferedReadableStream`\n        let bufferedStreamController!: PushReadableStreamController<Uint8Array>;\n\n        let writableStreamController!: WritableStreamDefaultController;\n\n        const buffered = new BufferedReadableStream(\n            new PushReadableStream<Uint8Array>((controller) => {\n                bufferedStreamController = controller;\n            }),\n        );\n\n        this.#readable = new ReadableStream<T>({\n            async pull(controller) {\n                try {\n                    const value = await transform(buffered);\n                    controller.enqueue(value);\n                } catch (e) {\n                    // Treat `StructEmptyError` as a normal end.\n                    // If the `transform` method doesn't have enough data to return a value,\n                    // it should throw another error to indicate that.\n                    if (e instanceof StructEmptyError) {\n                        controller.close();\n                        return;\n                    }\n                    throw e;\n                }\n            },\n            cancel: (reason) => {\n                // If a `ReadableStream` is piping into `#writable`,\n                // This will cancel the `ReadableStream` immediately.\n                // If upstream is writing using `#writable`'s writer, this will\n                // throw errors for any future writes\n                return writableStreamController.error(reason);\n            },\n        });\n\n        this.#writable = new WritableStream({\n            start(controller) {\n                writableStreamController = controller;\n            },\n            async write(chunk) {\n                await bufferedStreamController.enqueue(chunk);\n            },\n            abort() {\n                bufferedStreamController.close();\n            },\n            close() {\n                bufferedStreamController.close();\n            },\n        });\n    }\n}\n", "import { PromiseResolver } from \"@yume-chan/async\";\nimport { EmptyUint8Array } from \"@yume-chan/struct\";\n\nimport type { ReadableStreamDefaultController } from \"./stream.js\";\nimport { ReadableStream, WritableStream } from \"./stream.js\";\n\nexport interface ConcatStringReadableStream\n    extends ReadableStream<string>,\n        Promise<string> {}\n\n// `TransformStream` only calls its `source.flush` method when its `readable` is being read.\n// If the user want to use the `Promise` interface, the `flush` method will never be called,\n// so the `PromiseResolver` will never be resolved.\n// Thus we need to implement our own `TransformStream` using a `WritableStream` and a `ReadableStream`.\n\n/**\n * A `TransformStream` that concatenates strings.\n *\n * Its `readable` is also a `Promise<string>`, so it's possible to `await` it to get the result.\n *\n * ```ts\n * const result: string = await readable.pipeThrough(new ConcatStringStream());\n * ```\n */\nexport class ConcatStringStream {\n    // PERF: rope (concat strings) is faster than `[].join('')`\n    #result = \"\";\n\n    #resolver = new PromiseResolver<string>();\n\n    #writable = new WritableStream<string>({\n        write: (chunk) => {\n            this.#result += chunk;\n        },\n        close: () => {\n            this.#resolver.resolve(this.#result);\n            this.#readableController.enqueue(this.#result);\n            this.#readableController.close();\n        },\n        abort: (reason) => {\n            this.#resolver.reject(reason);\n            this.#readableController.error(reason);\n        },\n    });\n    get writable(): WritableStream<string> {\n        return this.#writable;\n    }\n\n    #readableController!: ReadableStreamDefaultController<string>;\n    #readable = new ReadableStream<string>({\n        start: (controller) => {\n            this.#readableController = controller;\n        },\n    }) as ConcatStringReadableStream;\n    get readable(): ConcatStringReadableStream {\n        return this.#readable;\n    }\n\n    constructor() {\n        void Object.defineProperties(this.#readable, {\n            then: {\n                get: () =>\n                    this.#resolver.promise.then.bind(this.#resolver.promise),\n            },\n            catch: {\n                get: () =>\n                    this.#resolver.promise.catch.bind(this.#resolver.promise),\n            },\n            finally: {\n                get: () =>\n                    this.#resolver.promise.finally.bind(this.#resolver.promise),\n            },\n        });\n    }\n}\n\nexport interface ConcatBufferReadableStream\n    extends ReadableStream<Uint8Array>,\n        Promise<Uint8Array> {}\n\n/**\n * A `TransformStream` that concatenates `Uint8Array`s.\n *\n * If you want to decode the result as string,\n * prefer `.pipeThrough(new TextDecoderStream()).pipeThrough(new ConcatStringStream())`,\n * than `.pipeThough(new ConcatBufferStream()).pipeThrough(new TextDecoderStream())`,\n * because of JavaScript engine optimizations,\n * concatenating strings is faster than concatenating `Uint8Array`s.\n */\nexport class ConcatBufferStream {\n    #segments: Uint8Array[] = [];\n\n    #resolver = new PromiseResolver<Uint8Array>();\n\n    #writable = new WritableStream<Uint8Array>({\n        write: (chunk) => {\n            this.#segments.push(chunk);\n        },\n        close: () => {\n            let result: Uint8Array;\n            let offset = 0;\n            switch (this.#segments.length) {\n                case 0:\n                    result = EmptyUint8Array;\n                    break;\n                case 1:\n                    result = this.#segments[0]!;\n                    break;\n                default:\n                    result = new Uint8Array(\n                        this.#segments.reduce(\n                            (prev, item) => prev + item.length,\n                            0,\n                        ),\n                    );\n                    for (const segment of this.#segments) {\n                        result.set(segment, offset);\n                        offset += segment.length;\n                    }\n                    break;\n            }\n\n            this.#resolver.resolve(result);\n            this.#readableController.enqueue(result);\n            this.#readableController.close();\n        },\n        abort: (reason) => {\n            this.#resolver.reject(reason);\n            this.#readableController.error(reason);\n        },\n    });\n    get writable(): WritableStream<Uint8Array> {\n        return this.#writable;\n    }\n\n    #readableController!: ReadableStreamDefaultController<Uint8Array>;\n    #readable = new ReadableStream<Uint8Array>({\n        start: (controller) => {\n            this.#readableController = controller;\n        },\n    }) as ConcatBufferReadableStream;\n    get readable(): ConcatBufferReadableStream {\n        return this.#readable;\n    }\n\n    constructor() {\n        void Object.defineProperties(this.#readable, {\n            then: {\n                get: () =>\n                    this.#resolver.promise.then.bind(this.#resolver.promise),\n            },\n            catch: {\n                get: () =>\n                    this.#resolver.promise.catch.bind(this.#resolver.promise),\n            },\n            finally: {\n                get: () =>\n                    this.#resolver.promise.finally.bind(this.#resolver.promise),\n            },\n        });\n    }\n}\n", "import { Consumable } from \"../consumable.js\";\nimport type { QueuingStrategy } from \"../stream.js\";\nimport { ReadableStream } from \"../stream.js\";\n\nexport interface ConsumableReadableStreamController<T> {\n    enqueue(chunk: T): Promise<void>;\n    close(): void;\n    error(reason: unknown): void;\n}\n\nexport interface ConsumableReadableStreamSource<T> {\n    start?(\n        controller: ConsumableReadableStreamController<T>,\n    ): void | PromiseLike<void>;\n    pull?(\n        controller: ConsumableReadableStreamController<T>,\n    ): void | PromiseLike<void>;\n    cancel?(reason: unknown): void | PromiseLike<void>;\n}\n\nexport class ConsumableReadableStream<T> extends ReadableStream<Consumable<T>> {\n    static async enqueue<T>(\n        controller: { enqueue: (chunk: Consumable<T>) => void },\n        chunk: T,\n    ) {\n        const output = new Consumable(chunk);\n        controller.enqueue(output);\n        await output.consumed;\n    }\n\n    constructor(\n        source: ConsumableReadableStreamSource<T>,\n        strategy?: QueuingStrategy<T>,\n    ) {\n        let wrappedController!: ConsumableReadableStreamController<T>;\n\n        let wrappedStrategy: QueuingStrategy<Consumable<T>> | undefined;\n        if (strategy) {\n            wrappedStrategy = {};\n            if (\"highWaterMark\" in strategy) {\n                wrappedStrategy.highWaterMark = strategy.highWaterMark;\n            }\n            if (\"size\" in strategy) {\n                wrappedStrategy.size = (chunk) => {\n                    return strategy.size!(chunk.value);\n                };\n            }\n        }\n\n        super(\n            {\n                start(controller) {\n                    wrappedController = {\n                        enqueue(chunk) {\n                            return ConsumableReadableStream.enqueue(\n                                controller,\n                                chunk,\n                            );\n                        },\n                        close() {\n                            controller.close();\n                        },\n                        error(reason) {\n                            controller.error(reason);\n                        },\n                    };\n\n                    return source.start?.(wrappedController);\n                },\n                pull() {\n                    return source.pull?.(wrappedController);\n                },\n                cancel(reason) {\n                    return source.cancel?.(reason);\n                },\n            },\n            wrappedStrategy,\n        );\n    }\n}\n", "import type { Consumable } from \"../consumable.js\";\nimport { ReadableStream } from \"../stream.js\";\n\nimport { ConsumableReadableStream } from \"./readable.js\";\n\nexport class ConsumableWrapByteReadableStream extends ReadableStream<\n    Consumable<Uint8Array>\n> {\n    constructor(\n        stream: ReadableStream<Uint8Array>,\n        chunkSize: number,\n        min?: number,\n    ) {\n        const reader = stream.getReader({ mode: \"byob\" });\n        let array = new Uint8Array(chunkSize);\n        super({\n            async pull(controller) {\n                const { done, value } = await reader.read(array, { min });\n                if (done) {\n                    controller.close();\n                    return;\n                }\n\n                await ConsumableReadableStream.enqueue(controller, value);\n\n                array = new Uint8Array(value.buffer);\n            },\n            cancel(reason) {\n                return reader.cancel(reason);\n            },\n        });\n    }\n}\n", "import type { Consumable } from \"../consumable.js\";\nimport { WritableStream } from \"../stream.js\";\n\nexport class ConsumableWrapWritableStream<in T> extends WritableStream<\n    Consumable<T>\n> {\n    constructor(stream: WritableStream<T>) {\n        const writer = stream.getWriter();\n        super({\n            write(chunk) {\n                return chunk.tryConsume((chunk) => writer.write(chunk));\n            },\n            abort(reason) {\n                return writer.abort(reason);\n            },\n            close() {\n                return writer.close();\n            },\n        });\n    }\n}\n", "import { Consumable } from \"../consumable.js\";\nimport type {\n    QueuingStrategy,\n    WritableStreamDefaultController,\n    WritableStreamDefaultWriter,\n} from \"../stream.js\";\nimport { WritableStream } from \"../stream.js\";\n\nexport interface ConsumableWritableStreamSink<in T> {\n    start?(\n        controller: WritableStreamDefaultController,\n    ): void | PromiseLike<void>;\n    write?(\n        chunk: T,\n        controller: WritableStreamDefaultController,\n    ): void | PromiseLike<void>;\n    abort?(reason: unknown): void | PromiseLike<void>;\n    close?(): void | PromiseLike<void>;\n}\n\nexport class ConsumableWritableStream<in T> extends WritableStream<\n    Consumable<T>\n> {\n    static async write<T>(\n        writer: WritableStreamDefaultWriter<Consumable<T>>,\n        value: T,\n    ) {\n        const consumable = new Consumable(value);\n        await writer.write(consumable);\n        await consumable.consumed;\n    }\n\n    constructor(\n        sink: ConsumableWritableStreamSink<T>,\n        strategy?: QueuingStrategy<T>,\n    ) {\n        let wrappedStrategy: QueuingStrategy<Consumable<T>> | undefined;\n        if (strategy) {\n            wrappedStrategy = {};\n            if (\"highWaterMark\" in strategy) {\n                wrappedStrategy.highWaterMark = strategy.highWaterMark;\n            }\n            if (\"size\" in strategy) {\n                wrappedStrategy.size = (chunk) => {\n                    return strategy.size!(\n                        chunk instanceof Consumable ? chunk.value : chunk,\n                    );\n                };\n            }\n        }\n\n        super(\n            {\n                start(controller) {\n                    return sink.start?.(controller);\n                },\n                write(chunk, controller) {\n                    return chunk.tryConsume((chunk) =>\n                        sink.write?.(chunk, controller),\n                    );\n                },\n                abort(reason) {\n                    return sink.abort?.(reason);\n                },\n                close() {\n                    return sink.close?.();\n                },\n            },\n            wrappedStrategy,\n        );\n    }\n}\n", "export interface Task {\n    run<T>(callback: () => T): T;\n}\n\ninterface Console {\n    createTask(name: string): Task;\n}\n\ninterface GlobalExtension {\n    console?: Console;\n}\n\n// `createTask` allows browser DevTools to track the call stack across async boundaries.\nconst { console } = globalThis as unknown as GlobalExtension;\nexport const createTask: (name: string) => Task = /* #__PURE__ */ (() =>\n    console?.createTask?.bind(console) ??\n    (() => ({\n        run(callback) {\n            return callback();\n        },\n    })))();\n", "import { PromiseResolver, isPromiseLike } from \"@yume-chan/async\";\n\nimport type {\n    ConsumableReadableStreamController,\n    ConsumableReadableStreamSource,\n    ConsumableWritableStreamSink,\n} from \"./consumable/index.js\";\nimport {\n    ConsumableReadableStream,\n    ConsumableWrapByteReadableStream,\n    ConsumableWrapWritableStream,\n    ConsumableWritableStream,\n} from \"./consumable/index.js\";\nimport type { Task } from \"./task.js\";\nimport { createTask } from \"./task.js\";\n\nexport class Consumable<T> {\n    static readonly WritableStream = ConsumableWritableStream;\n    static readonly WrapWritableStream = ConsumableWrapWritableStream;\n    static readonly ReadableStream = ConsumableReadableStream;\n    static readonly WrapByteReadableStream = ConsumableWrapByteReadableStream;\n\n    readonly #task: Task;\n    readonly #resolver: PromiseResolver<void>;\n\n    readonly value: T;\n    readonly consumed: Promise<void>;\n\n    constructor(value: T) {\n        this.#task = createTask(\"Consumable\");\n        this.value = value;\n        this.#resolver = new PromiseResolver<void>();\n        this.consumed = this.#resolver.promise;\n    }\n\n    consume() {\n        this.#resolver.resolve();\n    }\n\n    error(error: unknown) {\n        this.#resolver.reject(error);\n    }\n\n    tryConsume<U>(callback: (value: T) => U) {\n        try {\n            let result = this.#task.run(() => callback(this.value));\n            if (isPromiseLike(result)) {\n                result = result.then(\n                    (value) => {\n                        this.#resolver.resolve();\n                        return value;\n                    },\n                    (e) => {\n                        this.#resolver.reject(e);\n                        throw e;\n                    },\n                ) as U;\n            } else {\n                this.#resolver.resolve();\n            }\n            return result;\n        } catch (e) {\n            this.#resolver.reject(e);\n            throw e;\n        }\n    }\n}\n\nexport namespace Consumable {\n    export type WritableStreamSink<T> = ConsumableWritableStreamSink<T>;\n    export type WritableStream<in T> = typeof ConsumableWritableStream<T>;\n\n    export type WrapWritableStream<in T> =\n        typeof ConsumableWrapWritableStream<T>;\n\n    export type ReadableStreamController<T> =\n        ConsumableReadableStreamController<T>;\n    export type ReadableStreamSource<T> = ConsumableReadableStreamSource<T>;\n    export type ReadableStream<T> = typeof ConsumableReadableStream<T>;\n\n    export type WrapByteReadableStream =\n        typeof ConsumableWrapByteReadableStream;\n}\n", "export * from \"./utils.js\";\nexport { MaybeConsumableWrapWritableStream as WrapWritableStream } from \"./wrap-writable.js\";\nexport { MaybeConsumableWritableStream as WritableStream } from \"./writable.js\";\nexport type { MaybeConsumableWritableStreamSink as WritableStreamSink } from \"./writable.js\";\n", "import { Consumable } from \"../consumable.js\";\nimport type { MaybeConsumable } from \"../maybe-consumable.js\";\n\nexport function getValue<T>(value: MaybeConsumable<T>): T {\n    return value instanceof Consumable ? value.value : value;\n}\n\nexport function tryConsume<T, R>(\n    value: T,\n    callback: (value: T extends Consumable<infer U> ? U : T) => R,\n): R {\n    if (value instanceof Consumable) {\n        return value.tryConsume(callback);\n    } else {\n        return callback(value as never);\n    }\n}\n", "import type { MaybeConsumable } from \"../maybe-consumable.js\";\nimport { WritableStream } from \"../stream.js\";\n\nimport { tryConsume } from \"./utils.js\";\n\nexport class MaybeConsumableWrapWritableStream<T> extends WritableStream<\n    MaybeConsumable<T>\n> {\n    constructor(stream: WritableStream<T>) {\n        const writer = stream.getWriter();\n        super({\n            write(chunk) {\n                return tryConsume(chunk, (chunk) => writer.write(chunk as T));\n            },\n            abort(reason) {\n                return writer.abort(reason);\n            },\n            close() {\n                return writer.close();\n            },\n        });\n    }\n}\n", "import { Consumable } from \"../consumable.js\";\nimport type { MaybeConsumable } from \"../maybe-consumable.js\";\nimport type {\n    QueuingStrategy,\n    WritableStreamDefaultController,\n} from \"../stream.js\";\nimport { WritableStream } from \"../stream.js\";\n\nimport { tryConsume } from \"./utils.js\";\n\nexport interface MaybeConsumableWritableStreamSink<in T> {\n    start?(\n        controller: WritableStreamDefaultController,\n    ): void | PromiseLike<void>;\n    write?(\n        chunk: T,\n        controller: WritableStreamDefaultController,\n    ): void | PromiseLike<void>;\n    abort?(reason: unknown): void | PromiseLike<void>;\n    close?(): void | PromiseLike<void>;\n}\n\nexport class MaybeConsumableWritableStream<in T> extends WritableStream<\n    MaybeConsumable<T>\n> {\n    constructor(\n        sink: MaybeConsumableWritableStreamSink<T>,\n        strategy?: QueuingStrategy<T>,\n    ) {\n        let wrappedStrategy: QueuingStrategy<MaybeConsumable<T>> | undefined;\n        if (strategy) {\n            wrappedStrategy = {};\n            if (\"highWaterMark\" in strategy) {\n                wrappedStrategy.highWaterMark = strategy.highWaterMark;\n            }\n            if (\"size\" in strategy) {\n                wrappedStrategy.size = (chunk) => {\n                    return strategy.size!(\n                        chunk instanceof Consumable ? chunk.value : chunk,\n                    );\n                };\n            }\n        }\n\n        super(\n            {\n                start(controller) {\n                    return sink.start?.(controller);\n                },\n                write(chunk, controller) {\n                    return tryConsume(chunk, (chunk) =>\n                        sink.write?.(chunk as T, controller),\n                    );\n                },\n                abort(reason) {\n                    return sink.abort?.(reason);\n                },\n                close() {\n                    return sink.close?.();\n                },\n            },\n            wrappedStrategy,\n        );\n    }\n}\n", "import { Consumable } from \"./consumable.js\";\nimport { MaybeConsumable } from \"./maybe-consumable.js\";\nimport { TransformStream } from \"./stream.js\";\n\n/**\n * Splits or combines buffers to specified size.\n */\nexport class BufferCombiner {\n    #capacity: number;\n    readonly #buffer: Uint8Array;\n    #offset: number;\n    #available: number;\n\n    constructor(size: number) {\n        this.#capacity = size;\n        this.#buffer = new Uint8Array(size);\n        this.#offset = 0;\n        this.#available = size;\n    }\n\n    /**\n     * Pushes data to the combiner.\n     * @param data The input data to be split or combined.\n     * @returns\n     * A generator that yields buffers of specified size.\n     * It may yield the same buffer multiple times, consume the data before calling `next`.\n     */\n    *push(data: Uint8Array): Generator<Uint8Array, void, void> {\n        let offset = 0;\n        let available = data.length;\n\n        if (this.#offset !== 0) {\n            if (available >= this.#available) {\n                this.#buffer.set(\n                    data.subarray(0, this.#available),\n                    this.#offset,\n                );\n                offset += this.#available;\n                available -= this.#available;\n\n                yield this.#buffer;\n                this.#offset = 0;\n                this.#available = this.#capacity;\n\n                if (available === 0) {\n                    return;\n                }\n            } else {\n                this.#buffer.set(data, this.#offset);\n                this.#offset += available;\n                this.#available -= available;\n                return;\n            }\n        }\n\n        while (available >= this.#capacity) {\n            const end = offset + this.#capacity;\n            yield data.subarray(offset, end);\n            offset = end;\n            available -= this.#capacity;\n        }\n\n        if (available > 0) {\n            this.#buffer.set(data.subarray(offset), this.#offset);\n            this.#offset += available;\n            this.#available -= available;\n        }\n    }\n\n    flush(): Uint8Array | undefined {\n        if (this.#offset === 0) {\n            return undefined;\n        }\n\n        const output = this.#buffer.subarray(0, this.#offset);\n        this.#offset = 0;\n        this.#available = this.#capacity;\n        return output;\n    }\n}\n\nexport class DistributionStream extends TransformStream<\n    MaybeConsumable<Uint8Array>,\n    MaybeConsumable<Uint8Array>\n> {\n    constructor(size: number, combine = false) {\n        const combiner = combine ? new BufferCombiner(size) : undefined;\n        super({\n            async transform(chunk, controller) {\n                await MaybeConsumable.tryConsume(chunk, async (chunk) => {\n                    if (combiner) {\n                        for (const buffer of combiner.push(chunk)) {\n                            await Consumable.ReadableStream.enqueue(\n                                controller,\n                                buffer,\n                            );\n                        }\n                    } else {\n                        let offset = 0;\n                        let available = chunk.length;\n                        while (available > 0) {\n                            const end = offset + size;\n                            await Consumable.ReadableStream.enqueue(\n                                controller,\n                                chunk.subarray(offset, end),\n                            );\n                            offset = end;\n                            available -= size;\n                        }\n                    }\n                });\n            },\n            flush(controller) {\n                if (combiner) {\n                    const data = combiner.flush();\n                    if (data) {\n                        controller.enqueue(data);\n                    }\n                }\n            },\n        });\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\n\nimport type {\n    QueuingStrategy,\n    ReadableStreamDefaultController,\n    ReadableStreamDefaultReader,\n} from \"./stream.js\";\nimport { ReadableStream } from \"./stream.js\";\n\nexport type WrapReadableStreamStart<T> = (\n    controller: ReadableStreamDefaultController<T>,\n) => MaybePromiseLike<ReadableStream<T>>;\n\nexport interface ReadableStreamWrapper<T> {\n    start: WrapReadableStreamStart<T>;\n    cancel?: (reason?: unknown) => MaybePromiseLike<void>;\n    close?: () => MaybePromiseLike<void>;\n    error?: (reason?: unknown) => MaybePromiseLike<void>;\n}\n\nfunction getWrappedReadableStream<T>(\n    wrapper:\n        | ReadableStream<T>\n        | WrapReadableStreamStart<T>\n        | ReadableStreamWrapper<T>,\n    controller: ReadableStreamDefaultController<T>,\n) {\n    if (\"start\" in wrapper) {\n        return wrapper.start(controller);\n    } else if (typeof wrapper === \"function\") {\n        return wrapper(controller);\n    } else {\n        // Can't use `wrapper instanceof ReadableStream`\n        // Because we want to be compatible with any ReadableStream-like objects\n        return wrapper;\n    }\n}\n\n/**\n * This class has multiple usages:\n *\n * 1. Get notified when the stream is cancelled or closed.\n * 2. Synchronously create a `ReadableStream` by asynchronously return another `ReadableStream`.\n * 3. Convert native `ReadableStream`s to polyfilled ones so they can `pipe` between.\n */\nexport class WrapReadableStream<T> extends ReadableStream<T> {\n    readable!: ReadableStream<T>;\n\n    #reader!: ReadableStreamDefaultReader<T>;\n\n    constructor(\n        wrapper:\n            | ReadableStream<T>\n            | WrapReadableStreamStart<T>\n            | ReadableStreamWrapper<T>,\n        strategy?: QueuingStrategy<T>,\n    ) {\n        super(\n            {\n                start: async (controller) => {\n                    const readable = await getWrappedReadableStream(\n                        wrapper,\n                        controller,\n                    );\n                    // `start` is called in `super()`, so can't use `this` synchronously.\n                    // but it's fine after the first `await`\n                    this.readable = readable;\n                    this.#reader = this.readable.getReader();\n                },\n                pull: async (controller) => {\n                    const { done, value } = await this.#reader\n                        .read()\n                        .catch((e) => {\n                            if (\"error\" in wrapper) {\n                                wrapper.error(e);\n                            }\n                            throw e;\n                        });\n\n                    if (done) {\n                        controller.close();\n                        if (\"close\" in wrapper) {\n                            await wrapper.close?.();\n                        }\n                    } else {\n                        controller.enqueue(value);\n                    }\n                },\n                cancel: async (reason) => {\n                    await this.#reader.cancel(reason);\n                    if (\"cancel\" in wrapper) {\n                        await wrapper.cancel?.(reason);\n                    }\n                },\n            },\n            strategy,\n        );\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport { PromiseResolver } from \"@yume-chan/async\";\n\nimport type {\n    QueuingStrategy,\n    ReadableStream,\n    ReadableStreamDefaultController,\n    WritableStreamDefaultWriter,\n} from \"./stream.js\";\nimport { WritableStream } from \"./stream.js\";\nimport { tryClose } from \"./try-close.js\";\nimport { WrapReadableStream } from \"./wrap-readable.js\";\n\nconst NOOP = () => {\n    // no-op\n};\n\nexport interface DuplexStreamFactoryOptions {\n    /**\n     * Callback when any `ReadableStream` is cancelled (the user doesn't need any more data),\n     * or `WritableStream` is ended (the user won't produce any more data),\n     * or `DuplexStreamFactory#close` is called.\n     *\n     * Usually you want to let the other peer know that the duplex stream should be closed.\n     *\n     * `dispose` will automatically be called after `close` completes,\n     * but if you want to wait another peer for a close confirmation and call\n     * `DuplexStreamFactory#dispose` yourself, you can return `false`\n     * (or a `Promise` that resolves to `false`) to disable the automatic call.\n     */\n    close?: (() => MaybePromiseLike<boolean | void>) | undefined;\n\n    /**\n     * Callback when any `ReadableStream` is closed (the other peer doesn't produce any more data),\n     * or `WritableStream` is aborted (the other peer can't receive any more data),\n     * or `DuplexStreamFactory#abort` is called.\n     *\n     * Usually indicates the other peer has closed the duplex stream. You can clean up\n     * any resources you have allocated now.\n     */\n    dispose?: (() => void | Promise<void>) | undefined;\n}\n\n/**\n * A factory for creating a duplex stream.\n *\n * It can create multiple `ReadableStream`s and `WritableStream`s,\n * when any of them is closed, all other streams will be closed as well.\n */\nexport class DuplexStreamFactory<R, W> {\n    #readableControllers: ReadableStreamDefaultController<R>[] = [];\n    #writers: WritableStreamDefaultWriter<W>[] = [];\n\n    #writableClosed = false;\n    get writableClosed() {\n        return this.#writableClosed;\n    }\n\n    #closed = new PromiseResolver<void>();\n    get closed() {\n        return this.#closed.promise;\n    }\n\n    readonly #options: DuplexStreamFactoryOptions;\n\n    constructor(options?: DuplexStreamFactoryOptions) {\n        this.#options = options ?? {};\n    }\n\n    wrapReadable(\n        readable: ReadableStream<R>,\n        strategy?: QueuingStrategy<R>,\n    ): WrapReadableStream<R> {\n        return new WrapReadableStream<R>(\n            {\n                start: (controller) => {\n                    this.#readableControllers.push(controller);\n                    return readable;\n                },\n                cancel: async () => {\n                    // cancel means the local peer wants to close the connection.\n                    await this.close();\n                },\n                close: async () => {\n                    // stream end means the remote peer closed the connection first.\n                    await this.dispose();\n                },\n            },\n            strategy,\n        );\n    }\n\n    createWritable(stream: WritableStream<W>): WritableStream<W> {\n        const writer = stream.getWriter();\n        this.#writers.push(writer);\n\n        // `WritableStream` has no way to tell if the remote peer has closed the connection.\n        // So it only triggers `close`.\n        return new WritableStream<W>({\n            write: async (chunk) => {\n                await writer.write(chunk);\n            },\n            abort: async (reason) => {\n                await writer.abort(reason);\n                await this.close();\n            },\n            close: async () => {\n                // NOOP: the writer is already closed\n                await writer.close().catch(NOOP);\n                await this.close();\n            },\n        });\n    }\n\n    async close() {\n        if (this.#writableClosed) {\n            return;\n        }\n        this.#writableClosed = true;\n\n        // Call `close` first, so it can still write data to `WritableStream`s.\n        if ((await this.#options.close?.()) !== false) {\n            // `close` can return `false` to disable automatic `dispose`.\n            await this.dispose();\n        }\n\n        for (const writer of this.#writers) {\n            // NOOP: the writer is already closed\n            writer.close().catch(NOOP);\n        }\n    }\n\n    async dispose() {\n        this.#writableClosed = true;\n        this.#closed.resolve();\n\n        for (const controller of this.#readableControllers) {\n            tryClose(controller);\n        }\n\n        await this.#options.dispose?.();\n    }\n}\n", "import type { TransformStream } from \"./stream.js\";\n\nexport interface TextDecoderOptions {\n    fatal?: boolean;\n    ignoreBOM?: boolean;\n}\n\ndeclare class TextDecoderStreamType extends TransformStream<\n    ArrayBufferView | ArrayBuffer,\n    string\n> {\n    constructor(label?: string, options?: TextDecoderOptions);\n\n    readonly encoding: string;\n    readonly fatal: boolean;\n    readonly ignoreBOM: boolean;\n}\n\ndeclare class TextEncoderStreamType extends TransformStream<\n    string,\n    Uint8Array\n> {\n    constructor();\n\n    readonly encoding: string;\n}\n\ninterface GlobalExtension {\n    TextDecoderStream: typeof TextDecoderStreamType;\n    TextEncoderStream: typeof TextEncoderStreamType;\n}\n\nconst Global = globalThis as unknown as GlobalExtension;\n\nexport const TextDecoderStream = Global.TextDecoderStream;\nexport type TextDecoderStream = TextDecoderStreamType;\n\nexport const TextEncoderStream = Global.TextEncoderStream;\nexport type TextEncoderStream = TextEncoderStreamType;\n", "import { TransformStream } from \"./stream.js\";\n\nexport class InspectStream<T> extends TransformStream<T, T> {\n    constructor(callback: (value: T) => void) {\n        super({\n            transform(chunk, controller) {\n                callback(chunk);\n                controller.enqueue(chunk);\n            },\n        });\n    }\n}\n", "import type { ReadableWritablePair } from \"./stream.js\";\nimport { WritableStream } from \"./stream.js\";\n\n/**\n * Pipe `pair.readable` to `writable`, then returns `pair.writable`.\n *\n * This is the opposite of `ReadableStream#pipeThrough()`.\n *\n * @param writable The `WritableStream` to write to.\n * @param pair A `TransformStream` that converts chunks.\n * @returns `pair`'s `writable` stream.\n */\nexport function pipeFrom<W, T>(\n    writable: WritableStream<W>,\n    pair: ReadableWritablePair<W, T>,\n) {\n    const writer = pair.writable.getWriter();\n    const pipe = pair.readable.pipeTo(writable);\n    return new WritableStream<T>({\n        async write(chunk) {\n            await writer.write(chunk);\n        },\n        async close() {\n            await writer.close();\n            await pipe;\n        },\n    });\n}\n", "import { TransformStream } from \"./stream.js\";\n\nexport class SplitStringStream extends TransformStream<string, string> {\n    constructor(separator: string) {\n        let remaining: string | undefined = undefined;\n\n        super({\n            transform(chunk, controller) {\n                if (remaining) {\n                    chunk = remaining + chunk;\n                    remaining = undefined;\n                }\n\n                let start = 0;\n                while (start < chunk.length) {\n                    const index = chunk.indexOf(separator, start);\n                    if (index === -1) {\n                        remaining = chunk.substring(start);\n                        break;\n                    }\n\n                    controller.enqueue(chunk.substring(start, index));\n                    start = index + 1;\n                }\n            },\n            flush(controller) {\n                if (remaining) {\n                    controller.enqueue(remaining);\n                }\n            },\n        });\n    }\n}\n", "import type { StructDeserializer } from \"@yume-chan/struct\";\n\nimport { BufferedTransformStream } from \"./buffered-transform.js\";\n\nexport class StructDeserializeStream<T> extends BufferedTransformStream<T> {\n    constructor(struct: StructDeserializer<T>) {\n        super((stream) => {\n            return struct.deserialize(stream) as never;\n        });\n    }\n}\n", "import type { StructInit, StructSerializer } from \"@yume-chan/struct\";\n\nimport { TransformStream } from \"./stream.js\";\n\nexport class StructSerializeStream<\n    T extends StructSerializer<unknown>,\n> extends TransformStream<StructInit<T>, Uint8Array> {\n    constructor(struct: T) {\n        super({\n            transform(chunk, controller) {\n                controller.enqueue(struct.serialize(chunk));\n            },\n        });\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\n\nimport type { TransformStream, WritableStreamDefaultWriter } from \"./stream.js\";\nimport { WritableStream } from \"./stream.js\";\n\nexport type WrapWritableStreamStart<T> = () => MaybePromiseLike<\n    WritableStream<T>\n>;\n\nexport interface WritableStreamWrapper<T> {\n    start: WrapWritableStreamStart<T>;\n    close?(): void | Promise<void>;\n}\n\nasync function getWrappedWritableStream<T>(\n    start:\n        | WritableStream<T>\n        | WrapWritableStreamStart<T>\n        | WritableStreamWrapper<T>,\n) {\n    if (\"start\" in start) {\n        return await start.start();\n    } else if (typeof start === \"function\") {\n        return await start();\n    } else {\n        // Can't use `wrapper instanceof WritableStream`\n        // Because we want to be compatible with any WritableStream-like objects\n        return start;\n    }\n}\n\nexport class WrapWritableStream<T> extends WritableStream<T> {\n    writable!: WritableStream<T>;\n\n    #writer!: WritableStreamDefaultWriter<T>;\n\n    constructor(\n        start:\n            | WritableStream<T>\n            | WrapWritableStreamStart<T>\n            | WritableStreamWrapper<T>,\n    ) {\n        super({\n            start: async () => {\n                const writable = await getWrappedWritableStream(start);\n                // `start` is called in `super()`, so can't use `this` synchronously.\n                // but it's fine after the first `await`\n                this.writable = writable;\n                this.#writer = this.writable.getWriter();\n            },\n            write: async (chunk) => {\n                await this.#writer.write(chunk);\n            },\n            abort: async (reason) => {\n                await this.#writer.abort(reason);\n                if (start !== this.writable && \"close\" in start) {\n                    await start.close?.();\n                }\n            },\n            close: async () => {\n                // Close the inner stream first.\n                // Usually the inner stream is a logical sub-stream over the outer stream,\n                // closing the outer stream first will make the inner stream incapable of\n                // sending data in its `close` handler.\n                await this.#writer.close();\n                if (start !== this.writable && \"close\" in start) {\n                    await start.close?.();\n                }\n            },\n        });\n    }\n\n    bePipedThroughFrom<U>(transformer: TransformStream<U, T>) {\n        let promise: Promise<void>;\n        return new WrapWritableStream<U>({\n            start: () => {\n                promise = transformer.readable.pipeTo(this);\n                return transformer.writable;\n            },\n            async close() {\n                await promise;\n            },\n        });\n    }\n}\n"],
  "mappings": "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",
  "names": ["value", "result", "ReadableStream", "_writable", "_readable", "_resolver", "_readableController", "chunk", "chunk", "_resolver", "chunk", "chunk", "chunk"]
}
